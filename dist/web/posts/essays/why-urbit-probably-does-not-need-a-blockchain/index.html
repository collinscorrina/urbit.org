<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Posts</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div class="container mt-10"><div class="row fixed"><div class="col-sm-12 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-8 col-md-12 ml-1 mt-3 sm-2"><ul class="list-reset h-font"><a href="/posts"><li>All</li></a><a href="/posts/updates"><li>Updates</li></a><a href="/posts/essays"><li>Essays</li></a><a href="/posts/media"><li>Media</li></a></ul></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-3 col-md-offset-2"><div class="post col-sm-12"><div><h1 id="why-urbit-probably-doesn-t-need-a-blockchain-">Why Urbit Probably Doesn&#39;t Need a Blockchain </h1><img src="http://media.urbit.org/site/blog-1.jpg" border="12" /><p><i>~2017.7.14</i> </p><p>TLDR: Urbit (probably) doesn&#39;t need a blockchain, because the Urbit address-space PKI is a special case of a consensus ledger (itself a special case of Byzantine agreement). </p><p>Special cases are often easier to solve than general problems. The “New Jersey” or “worse-is-better” school of systems design emphasizes solving any problem with the weakest possible tools. </p><h2 id="the-worse-is-better-school-">The worse-is-better school </h2><p>Culturally, Urbit is best described as a functional stack built in the “New Jersey” school of system software design, as described in Richard Gabriel&#39;s famous <a href="https://en.wikipedia.org/wiki/Worse_is_better">“worse is better”</a> essay. </p><p>There are two kinds of mindsets when approaching hard technical problems. The “MIT” mindset, more typical among mathematicians and scientists, wants to attack the problem as its simplest and broadest case, producing the most general and powerful solution available. In short: better-is-better. </p><p>The “New Jersey” worse-is-better mentality, more typical among programmers and engineers, wants to do everything possible to <i>not</i> attack the problem. Can I produce a serviceable approximation to a true solution? Do I actually have to solve the general problem, or can I reduce it to an easier special case? Can I change the product so it doesn&#39;t have this problem? </p><p>Ideally, anyone building anything has both these mindsets in their toolbox. But it&#39;s worth noting that (a) Jersey designs (meaning the Bell Labs school that produced Unix, C, and Go) tend to beat MIT designs in the marketplace, and (b) there are very few pure-functional systems built with the true Jersey spirit. </p><h2 id="why-urbit--probably--doesn-t-need-a-blockchain-">Why Urbit (probably) doesn&#39;t need a blockchain </h2><p>Nakamoto consensus is an example of better-is-better. The blockchain design is actually more powerful than it needs to be. It&#39;s not just a trustless decentralized ledger; it&#39;s a trustless decentralized database and (as Ethereum has realized; but this idea is clearly present in Bitcoin&#39;s scripting language) a general-purpose, zero-trust decentralized computer. </p><p>Again, Urbit is not a general-purpose decentralized database or consensus computer. It&#39;s a special case of the former, which is a special case of the latter. Urbit is nothing but a digital title chain for network addresses. Our belief is that the special case is much easier than the general case, which is why Urbit (probably) doesn&#39;t need a blockchain. </p><p>The rest of this essay describes what makes this special case special, and how we can use that to not need full Nakamoto consensus, or any kind of general-purpose Byzantine agreement. </p><h2 id="the-double-sell-problem-">The double-sell problem </h2><p>Urbit has the same basic “double-spend” issue as Bitcoin. As Satoshi puts it: “The problem of course is the payee can&#39;t verify that one of the owners did not double-spend the coin.” But Urbit is not a currency, so we say “double-selling.” </p><p>“Double-selling” means signing over an Urbit address (<i>ship</i>) to two different parties at the same time, presumably with the intent to sell it to both and skip town with the loot. </p><p>Again, the logical problem is the same. Bitcoin attacks it as a broad theoretical breakthrough: better-is-better. Urbit attacks it as a narrow special case: worse-is-better. </p><p>Intuitively, Urbit&#39;s answer is that a real-estate transaction is substantively a very different thing from a credit-card payment. No real-estate agent ever has ever leaned over the desk, quickly grabbed <i>both</i> the check and the keys, and run laughing out the door. </p><p>To understand more rigorously how Urbit is a special case, let&#39;s take a quick look at the Urbit address space and PKI. </p><h2 id="the-urbit-address-space-and-pki-">The Urbit address space and PKI </h2><p>(NB: this description differs in minor ways from the running code. Where they differ, the description is right. Urbit is not at present secure: use for entertainment purpose only.) </p><p>An Urbit ship is an unsigned integer that serves four purposes: a cryptographic identity, a packet routing address, a stateful virtual computer, and a unique, human-memorable name. </p><p>Each ship is owned by a private key. To transfer a ship to a new keypair, sign the new public key with the old private key. This revokes the old key and activates the new key. Propagating this update globally makes the revocation global. This is essentially the digital title system a smart 12-year-old would design. </p><h3 id="ships-and-wills-">Ships and wills </h3><p>Ships are 128-bit numbers classified into tiers by bitwidth. An 8-bit ship (a number less than 256) is a <i>galaxy</i>. A 16-bit ship is a <i>star</i>. A 32-bit ship is a <i>planet</i>. A 64-bit ship is a <i>moon</i>. A 128-bit ship is a <i>comet</i>. </p><p>The chain of signatures for each ship is called a <i>will</i>. Unlike most certificate systems, there is no metadata in an Urbit will. Nothing is signed but the public-key fingerprint. The length of the will is the keypair version that owns the ship. This version is called its <i>life</i>. Each new signed fingerprint in the will is a <i>deed</i>. </p><p>Who gets to create a ship? Comets are fingerprints of a random keypair. Moons, planets and stars are created by their <i>prefix</i>, the ship whose bits are the bottom half of their formal width. For instance, the star <code>0xbeef</code> is the prefix of the planet <code>0xdeadbeef</code>. Galaxies have their fingerprints hardcoded in the official kernel. </p><p>Ship numbers are not generally written in hex. They&#39;re written in Hoon&#39;s <code>@p</code> syntax, a phonemic base-256. <code>@p</code> also permutes within tiers, to superficially conceal prefix structure; for instance, <code>0xdead.beef</code> is <code>~firbyr-napbes</code>, while <code>0xcafe.beef</code> is <code>~nissep-sopnub</code>. </p><h3 id="parent-hierarchy-">Parent hierarchy </h3><p>The prefix of a moon, planet, or star also becomes its <i>parent</i>. The parent of a ship is its natural locus of federated services. The most basic such service is to mediate P2P routing, as a so-called “supernode.” But the set of potential federated services is unbounded. </p><p>For moons, each new key update is signed by the parent. Planets and stars sign their own updates, making them independent. To prevent denial-of-service attacks by parents against children, stars and planets can <i>exit</i>, choosing a new parent. An exit deed is a key update also signed by the new parent. </p><p>The full public cryptographic record of a ship is its <i>dossier</i>. The dossier is the set of ship-will pairs, including all parents and prefixes recursively, needed to validate the ship&#39;s current key. A ship can process a dossier from an untrusted source. </p><p>The full set of ship-will pairs a ship knows is its <i>cabinet</i>. So the crucial question for PKI propagation is whether a submitted dossier is accepted into a ship&#39;s cabinet. </p><h3 id="propagation-race-">Propagation race </h3><p>The rule is simple: any deeds in the dossier which are new (not already in the cabinet) must not use keys superseded in the cabinet. Otherwise revocation doesn&#39;t work. But revocation affects only dossiers received in the future; nothing already in the cabinet can be revoked. </p><p>Intuitively, this algorithm creates a propagation race. Life <code>2</code> of <code>~firbyr-napbes</code> revokes life <code>1</code> of <code>~firbyr-napbes</code>, so propagating life <code>2</code> to the whole network ensures that anyone who steals the private key for life <code>1</code> can&#39;t use it in any way -- whether to launch children, or to sign a new, bogus life <code>2</code>. </p><h2 id="solving-the-special-case-">Solving the special case </h2><p>So how can we solve the double-sell problem, for the special case of the system designed above? </p><h3 id="double-spend-relaying-in-bitcoin-">Double-spend relaying in Bitcoin </h3><p>The first thing we need to notice about our special case is that <i>even Bitcoin</i>, not considered as a general consensus problem but just as a decentralized payment rail, isn&#39;t that far from <i>not</i> needing a blockchain. </p><p>As the Karame <a href="http://eprint.iacr.org/2012/248.pdf">“Two Bitcoins at the Price of One”</a> paper points out: </p><blockquote><p>An efficient countermeasure to combat double-spending on fast Bitcoin payments would be for Bitcoin peers to propagate alerts whenever they receive two or more transactions that share common inputs and different outputs. </p></blockquote><p>“Fast Bitcoin payments” means zero-confirmation, ie, Bitcoin without the blockchain. These double-spend alerts have never been integrated into Bitcoin Core, despite frequent proposals. Given that Bitcoin <i>does</i> have a blockchain, it seems quite sensible for purists to shun hacks that make zero-conf transactions somewhat more secure. Also, double-spend alerts in Bitcoin are a DoS vulnerability; Bitcoin has fees to control the cost of propagating transactions, but who pays for an alert? </p><p>In principle, however, we could imagine a version of Bitcoin without a blockchain, in which the mempool was the ledger, and there was an alerting and/or conflict model to detect and resolve double spends. An accepted transaction is simply one that propagates to one or more randomly chosen observer nodes. </p><p>This design, for the problem that Bitcoin is solving, intuitively feels weak and a little hacky. The Karame paper is not actually advocating for removing the blockchain from Bitcoin. At the same time, low-value zero-confirmation payments are commonly used. </p><p>One way to think about security is to flip the tables and think of the defender as the attacker, and vice versa. Just imagine you have some moral right to double spend. The rest of the world is unfairly trying to stop you. Can you defend yourself? </p><p>In the context of a gossip network that shares all the things, a procedure that involves telling one person one thing, and another person another conflicting thing, and not getting “hacked” by the unfair world which believes there should be only one truth, is inherently quite fragile. And where the attack is fragile, the defense is robust. </p><p>Most of the security in any digital title system comes from the PKI itself. The double-spend problem, the general issue of Byzantine failures in information propagation, is already a corner case. So perhaps we can solve it as a corner case. </p><p>Again: <i>even Bitcoin</i> isn&#39;t that far from being able to build a practical decentralized ledger without a blockchain. The same gossip model that broadcasts nonconflicting transactions is not at all incapable of reacting to conflicting transactions. We&#39;re not really recommending that Bitcoin ditch the blockchain, but this gives us hope with our fundamentally easier problem. </p><h2 id="various-specific-specialnesses-">Various specific specialnesses </h2><p>What are the differences between the Urbit double-sell problem and the Bitcoin double-spend problem? Is our special case really, truly, special? </p><p>In worse-is-better mode, we want every special-case advantage we can get. Every difference we find is one we can use as a leverage point. </p><h3 id="minimal-transaction-interdependency-">Minimal transaction interdependency </h3><p>The first major technical difference between the Urbit title history and the Bitcoin blockchain is that Bitcoin and its relatives are designed to secure a complete, interdependent, collective transaction history. Except for the parent-child relationship, Urbit wills are independent of each other. </p><p>Bitcoin&#39;s use of UTXOs rather than balances reduces interdependency somewhat. But the validity of each transaction is still dependent on all the transactions that created its inputs. (Ethereum drops the UTXO model, whose value in reducing dependencies may not match its cost in complexity.) </p><p>Urbit is not a payment system or a shared ledger. Bitcoins are divisible, but Urbit ships aren&#39;t. An Urbit will containing its parent chain is self-validating and has no dependencies. There is no collective history. There is no Merkle tree. There is no chain, with or without blocks. </p><p>This simplification doesn&#39;t eliminate the double-sell problem in theory, but makes it much more tractable in practice. The set of past transactions (key transfers) that a new transaction could conflict with is much smaller. </p><h3 id="trust-hierarchy-and-governance-structure-">Trust hierarchy and governance structure </h3><p>The second major technical difference is that Bitcoin is a flat, trustless, fully decentralized system. Urbit has a hierarchical, polycentric governance system which is a trust hierarchy. </p><p>Now and for quite some time, urbits default to automatically accepting OS updates from their parent, making this trust effectively absolute. This is not a novelty -- all “evergreen” browsers now work this way. You trust your browser quite a bit, which means you trust your browser vendor. </p><p>And since few Bitcoin node operators code their own daemons, the same dependency on a source distribution exists in Bitcoin. It&#39;s informal and off-chain, though, which is not really a good thing. (Urbit is like if Bitcoin Core hotpatched itself automatically by publishing source-code diffs on the blockchain.) </p><p>To be on the safe side, we should think of Urbit as a centralized system until the OS update that turns off automatic updates is shipped. This of course requires a certain measure of perfection, which cannot in any way be predicted. </p><p>After Arvo proper becomes “deciduous” (apps will of course always be remotely hotpatched), child-to-parent trust should diminish to the power of the parent to deny service to the child. This will always be present without some major redesign. </p><p>But it&#39;s opposed by the equal and opposite power of the child to switch to a different parent, creating a competitive market in governance. This should deliver service at the highest quality and lowest price, fortifying trust with incentives. The power of a restaurant owner to deny you service does not give the food industry the power to starve you to death. </p><p>And if no parent wants your business, with 2^16 stars who could accept it, you probably shouldn&#39;t be on the network at all. Urbit, like a real society, is designed to be a network of incentives that holds everyone in productive tension. We want everyone to be free, and no one to be unaccountable. </p><p>For example: a parent which extends its will also needs to send updated signatures to its children and former children. Either will otherwise be unable to propagate their dossiers to ships whose cabinets have the updated parent will, <i>even if some other parent adopts them</i>. </p><p>But Urbit is a collectively governed and updatable system. A star or galaxy which denies service to its own children will (a) get a bad reputation, (b) drive its children to other parents, and (c) force the network to hardcode a ship-specific exception into the propagation algorithm, overriding stale-key revocation. </p><p>In theory, a parent can extort its children by denying service. In practice, since Urbit is self-governing, not ungoverned, and its government can right this wrong with a source-code patch, the extortion won&#39;t work. So it won&#39;t happen. So the act of government won&#39;t be necessary, and won&#39;t happen either. </p><p>Of course a perfectly decentralized system would be freer. But worse, as usual, is better. And since we are paying for this worseness, imperfect decentralization, we&#39;d like to get all the mileage out of it that we can. </p><p>Again, Urbit, not being a trustless system, does not have to solve the trustless consensus problem -- although we still very much want to minimize and bound the delegation of trust. This is an obvious relaxation of Bitcoin&#39;s hard theoretical problem. </p><h3 id="routing--security-through-topology-">Routing: security through topology </h3><p>Please don&#39;t laugh. Security through routing topology isn&#39;t a joke -- unless firewalls are a joke. Cisco sells too many firewalls for them to be a joke. </p><p>In Bitcoin we may have all sorts of reasons to ask what ship holds what coins. In Urbit, when we ask what key controls an ship, we are either sending or receiving a message. Is our outgoing message safely sealed to the current owner? Is our incoming message properly signed by the current owner? </p><p>When the parent also forwards all packets until a P2P link is established (Urbit forwarding resolves to STUN if either party has full cone NAT, TURN if not), we can design in all kinds of interactions between routing and certificate management. </p><p>In particular, a parent which is a single source of truth in some sense is a very attractive design element. Again, we&#39;re paying for our imperfect decentralization. We might as well use it. </p><p>For example: I want to send a packet to ship X. Two parties, A and B, are competing for ownership of X. A is the rightful owner. I am secure against B if either of these conditions are true: my packet can only be decoded by A, or my packet is not sent to B. Both would be ideal, of course. Either will do. </p><h3 id="latency-and-friction-tolerance-">Latency and friction tolerance </h3><p>Confirmed Bitcoin payments aren&#39;t especially low-latency by payment standards. They&#39;re reasonably low-friction by payment standards. But fees are certainly a thing. </p><p>Urbit is digital real estate, not digital money. When we look at the standards of latency and friction in actual real estate -- where a transaction that takes a week is super-fast, a 5% payment overhead is normal, and a third-party intermediary is standard -- we see a much, much weaker set of requirements. </p><p>Obviously a week and a 5% overhead are incredibly sucky levels of latency and friction. The point is that even if this is the only level of performance Urbit can achieve, that&#39;s not necessarily the end of the world for Urbit. </p><p>For instance: if we wait a week for a double-sell alert, and we don&#39;t see one, either the gossip network is totally hosed (to a point we&#39;d surely find out about), or there wasn&#39;t a double-sell. This stuff is just not that hard. </p><p>(One little-made point about Bitcoin, by the way, is that Bitcoin enables trust-free <i>payments</i>, but not trust-free <i>exchanges</i>. The seller still needs to deliver the goods either before or after the payment; in either case, there is trust. Only Ethereum can solve this problem -- and only for digital exchanges.) </p><h2 id="we-can-afford-to-be-patient-">We can afford to be patient </h2><p>With a better-is-better, general-purpose solution, one size fits all until the end of time. With a worse-is-better, special-case solution, the details of that case are critical. </p><p>But we actually don&#39;t know these details. One rule of the worse-is-better school: never solve a problem before you have to. You don&#39;t know all the details, and you need those details. (Of course, with the better-is-better approach, the details don&#39;t matter at all.) </p><p>Is there such a thing as a transitive adjective? Grammarians are unclear. But technically, the adjective “secure” is always an error. Nothing is “secure.” “Secure against X” is the correct usage, where X is some threat model. </p><p>Urbit is an insecure test network with no sensitive data on it. This will remain true for a while. No Urbit ship has ever been transferred cryptographically. This will also remain the status quo for quite a while. </p><p>We <i>don&#39;t know the threat model</i>. We <i>can&#39;t solve the problem</i>. It&#39;s as simple as that. The best Urbit can do, at the present time, is map out the ballpark of solutions. </p><p>And we have time to proceed patiently. One way to think about the timing of cryptographic decentralization is to look at the DNS. It&#39;s clear that now, a decentralized DNS with cryptographic domain-name titles would be extremely desirable. It was never designed to happen. It will probably never happen. </p><p>But if we look at when cryptographic DNS with allodial title <i>should</i> have happened, it&#39;s probably sometime in the mid-90s. Ie, after over a decade of production use of the Domain Name System. In short: there&#39;s no need to hurry here. </p><h2 id="a-map-of-the-solution-space-">A map of the solution space </h2><p>But we still need a map of the worse-is-better ballpark. Let&#39;s look at some options, from least secure to most. </p><p>The essential question we can&#39;t answer, without a better sense of the threat model, is how aggressively we need to propagate wills. We especially are not sure about the threat model of malicious stars (16-bit ships) and/or galaxies (8-bit ships). </p><p>We need to know what kinds of double-sell attacks are plausible. Since we don&#39;t know this yet, we need not one propagation design, but a range of designs -- stretching all the way up to a full blockchain. </p><h3 id="acceptance-model-">Acceptance model </h3><p>What doesn&#39;t change is the will <i>acceptance</i> model. A ship will always accept a new will if (a) the new will extends the old will, (b) the parent signature on the initial public key is at least as recent as the ship&#39;s current version of that parent. </p><p>The parent clause implies that when a parent extends its will, it needs to send updated initial signatures to all the children it&#39;s launched. Otherwise, their own future updates will not be accepted by ships that have seen the parent&#39;s update. </p><p>This is not a big deal in the world of parent responsibilities. But like many such responsibilities, it lets a badly operated parent deny service to its children. </p><p>A ship accepts all wills, new or updated, and stores them permanently. If this is abused trivially as a DoS vector, Urbit will mitigate it by the usual technique of degrading service to non-scarce ship tiers. Scarcity rules. </p><h3 id="level-0--passive-propagation-only-">Level 0: passive propagation only </h3><p>The Ames protocol can piggyback a will on any packet. Each ship also permanently records which other ships hold which version of its own will. An update is automatically sent when needed. </p><p>With level 0 propagation, all key exchanges in Ames are passive and invisible to the programmer. When the sender has no will or symmetric key for the receiver, the packet is signed, bundled with the will, and sent as cleartext. </p><p>Signed cleartext? If you have no will for a peer, you&#39;ve never talked to this ship before. Your first words to a stranger probably won&#39;t be super secret. If this isn&#39;t true, the programmer has to send an innocuous message first and wait for it to be acknowledged. Kicking a rare corner case up to the programmer is a classic worse-is-better move. </p><p>With level 0 propagation only (the current implementation, because we don&#39;t even care about key updates yet), an updated does not effectively revoke the old key. If Alice updates to a new key, Mallory steals the old key, then Mallory talks to Bob before Alice does, Mallory can impersonate Alice. </p><p>So not only does level 0 not solve double-sell, it&#39;s also quite insecure. But it&#39;s still fine for now (because Urbit isn&#39;t really decentralized yet). </p><h3 id="level-1--neighbor-only-propagation-with-parent-filtering-">Level 1: neighbor-only propagation with parent filtering </h3><p>The list of other ships which hold your will, essentially the list of all ships you&#39;ve talked to, is your list of <i>neighbors</i>. You essentially have permanent, if perhaps very sporadic, conversations with all your cryptographic neighbors. Symmetric keys time out fast, but wills are held forever. </p><p>By proactively pinging all your neighbors when you extend your will, you prevent anyone who finds the old private key (ideally you update when your old key is stale, not when it&#39;s actually been <i>stolen</i>) from jumping into these conversations. </p><p>What about non-neighbors? We add a second feature: a parent will only forward a packet if its sender matches the current will. So updating your parent (who is always your neighbor) transforms it </p><p>There are two cases: where Alice&#39;s parent Trent is also Bob&#39;s parent, and where Bob has a separate parent Walter. In the first case, the expected packet flow is that Alice will send the packet to Trent, who sends it to Bob. In the second case, Trent sends it to Walter, who sends it to Bob. </p><p>In either flow, Bob or Walter is sure that the packet came through Trent. Since Trent is Alice&#39;s parent and hence Alice&#39;s neighbor, and hence is updated, Trent will forward no packets from Mallory. So Mallory has no way to reach Bob. </p><p>Non-neighborly packets not matching this flow can&#39;t be accepted. Suppose Mallory gets Bob&#39;s public IP address directly? If Bob gets a non-forwarded packet marked “Alice,” but Alice is not his neighbor, that&#39;s super weird. He must reject the packet. </p><p>Level 1 is nice because it provides a reasonable level of security, but it&#39;s still extremely simple. Not only does it not use a blockchain, it doesn&#39;t even need a gossip flood! </p><p>And level 1 propagation also does a competent worse-is-better job on the double-sell problem. Trent simply becomes the single source of truth. The buyer of Alice needs to check that Trent, her parent, has Alice&#39;s latest will from the buyer&#39;s perspective. If Alice&#39;s seller propagates a different fork to other ships, this damages Alice&#39;s ability to communicate, but produces no obvious gain for the seller. </p><p>Level 1 puts a lot of security weight on the parent. If Trent misbehaves, for example by not filtering Mallory&#39;s packets, Alice can be impersonated. And its solution to the double-sell problem is adequate, but not ideal. Level 1 is the worse-is-better sweet spot for a young Urbit, but will probably give way to level 2. </p><h3 id="level-2--broadcast-all-wills-">Level 2: broadcast all wills </h3><p>We can&#39;t say definitively that level 1 will be inadequate. But intuitively, it feels slightly weak. We will probably need a gossip protocol. </p><p>The only ships that can be transferred are galaxies, stars and planets; if all updates of all wills of all these major ships are broadcast, we hardly have a scaling problem like Bitcoin&#39;s. Even if changing the lock on your front door counted as a real-estate transaction, there are a lot fewer real-estate transactions than credit-card payments. </p><p>Moreover, conflict detection (double-sell alerts) is a natural part of any gossip protocol. Gossip should be between stars, not directly between planets; horizontal gossip, vertical distribution. Star-to-planet distribution may still be limited. </p><p>Especially since stars are somewhat trusted, ganking a gossip protocol with random update edges is incredibly hard and requires a pretty preposterous conspiracy. And flooding all planet wills does a lot to keep stars honest. It would be incredibly stupid for a star to try a double-sell attack against its own planets, but code is always more powerful than mere incentives. </p><p>Finally, the exit model isn&#39;t fully baked yet, but it will probably have more aggressive propagation needs. What&#39;s clear is that an exit statement is another type of will entry, involving a signature both from the previous key and the new parent. You can only escape to another ship of your parent&#39;s class that agrees to adopt you. </p><p>In general, because escaping need to work for routing (without the cooperation of the former parent), wills containing an exit statement (a planet moving to a new star, or a star moving to a new galaxy) exit) probably need to be flooded globally among all 8-bit galaxies and 16-bit stars. Exits should be rare, so they shouldn&#39;t present much of a scaling problem. </p><h3 id="level-3--full-blockchain-">Level 3: full blockchain </h3><p>Obviously a blockchain can solve Urbit&#39;s problem. Probably the right thing to do would be to use the Bitcoin blockchain, and confirm the current Urbit key version with a “colored coin” of some kind. (This should not be confused with the orthogonal idea of representing Urbit <i>invitations</i> as colored coins.) </p><p>This involves making all Urbit ships into Bitcoin SPV nodes at the least. Not the worst fate in the world, but also a cost. Alternatively, Urbit could have its own “altcoin” blockchain, with actual Urbit-specific mining. </p><p>Again, given that level 2 seems like it should work quite well, it&#39;s hard to see why level 3 propagation would be needed. But we can&#39;t really know at this point. There&#39;s a reason Urbit can update itself over the air. That&#39;s why we say: Urbit (probably) doesn&#39;t need a blockchain. If it does, we can retrofit it. </p><h2 id="retrospective-note-">Retrospective note </h2><p>This essay has presented the Urbit cryptographic title as a low-power, stripped-down, worse-is-better variation of Nakamoto consensus. That&#39;s clearly the right way to introduce it in 2016. </p><p>Actually, though, this part of Urbit was designed before the Bitcoin paper was published. There were other academic approaches to Byzantine consensus, but certainly none validated on a large scale as Nakamoto consensus has been. It never seemed appropriate to treat cryptographic titles to network addresses as a case of generalized Byzantine consensus, and without the existence of Bitcoin there was no temptation in this direction. </p><p>In a sense the secret of PKIs is that PKIs are easy. What&#39;s hard is adapting an existing identity and authorization structure into a PKI. If you build the simplest possible PKI, then force the human processes to fit themselves to the protocol instead of vice versa, you have a much easier job. Similarly, if you are not adding PKI to an existing network, but building the network and the PKI as one system, many simplifications are possible. This is once again the classic worse-is-better method. </p></div></div></div></div></div><footer class="container mb-36"><div class="row"><div class="col-sm-8 col-sm-offset-3 col-lg-4 col-md-offset-2"><div id="mc_embed_signup"><h2 class="mb-2">Updates</h2><p>Every month we send an email with community events and what we&#39;re up to. </p><iframe name="nothing" style="display:none;"></iframe><form id="mc-embedded-subscribe-form" class="validate" action="https://urbit.us11.list-manage.com/subscribe/post?u=972a03db9e0c6c25bb58de8c8&amp;amp;id=be143888d2" method="post" name="mc-embedded-subscribe-form" target="nothing"><div class="input-group text-mono" id="mc_embed_signup_scroll"><div class="mc-field-group"><input class="required mb-2" type="email" name="EMAIL" id="mce-EMAIL" placeholder="your@email.com"></input></div><div id="mce-responses" class="clear"><div id="mce-error-response" class="response" style="display:none"></div><div id="mce-success-response" class="response" style="display:none"></div></div><div style="position: absolute; left: -5000px;"><input type="text" name="b_972a03db9e0c6c25bb58de8c8_be143888d2"></input></div><div class="clear"><button id="mc-embedded-subscribe" class="bg-black white h-font" type="submit" name="subscribe"><span class="text-500">Subscribe</span></button></div></div></form></div></div></div><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>