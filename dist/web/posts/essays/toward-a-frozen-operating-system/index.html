<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Posts</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div class="container mt-10"><div class="row fixed"><div class="col-sm-12 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-8 col-md-12 ml-1 mt-3 sm-2"><ul class="list-reset h-font"><a href="/posts"><li>All</li></a><a href="/posts/updates"><li>Updates</li></a><a href="/posts/essays"><li>Essays</li></a><a href="/posts/media"><li>Media</li></a></ul></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-3 col-md-offset-2"><div class="post col-sm-12"><div><h1 id="toward-a-frozen-operating-system-">Toward a Frozen Operating System </h1><p><i>~2017.5.10</i> </p><p>Is it possible to freeze an entire OS, so that its codebase never changes and never has to change? Is the proposition even meaningful? Is it practical? And if so, why would we want a frozen OS? </p><p>Think about it intuitively. There&#39;s a reason we call an OS a “platform.” It&#39;s a piece of permanent infrastructure. Paul Graham wrote a <a href="http://www.paulgraham.com/hundred.html">great essay</a> about the “hundred-year language,” but the language is only one part of any complete platform. And in infrastructure terms, a hundred years isn&#39;t that long. </p><p>Why not think of structures that have lasted <i>thousands</i> of years? An aqueduct, a pyramid, a Parthenon? Why set our sights lower? Why isn&#39;t it time to aim for perfect and timeless code? If not now, when? </p><h2 id="scope-of-the-problem-">Scope of the problem </h2><p>More prosaically, a frozen OS just means your OS never changes. A frozen OS never gets any updates. Not because it can&#39;t update itself, just because it doesn&#39;t need to. </p><p>Is this even a meaningful concept? A frozen OS? First we&#39;ll have to decide what “OS” even means. Certainly, if “OS” means “the code that your hardware boots into,” hardware always changes and so will the OS. </p><p>A broader, more useful definition: the “OS” is <i>an opaque model of a persistent general-purpose computer</i>. This definition allows for arbitrary levels of virtualization. Linux on a droplet is an OS. A browser is an OS, because it&#39;s persistent (sorta) and opaque. But <code>node.js</code> is not an OS, because it&#39;s not opaque: it exports Linux system calls. </p><p>Within this opaque model, we have to decide what&#39;s “system” and “user” software. It clearly makes no sense to freeze userspace. Let&#39;s use the <a href="https://en.wikipedia.org/wiki/Trusted_computing_base">trusted codebase</a>: code is system software, if compromising it would compromise the whole system. </p><h2 id="infinite-maturity-">Infinite maturity </h2><p>It&#39;s important to remember that just because a system is designed to achieve frozenness, doesn&#39;t mean it&#39;s useless until it&#39;s frozen. It doesn&#39;t even mean it&#39;s immature. It just means that in the very long term, the system&#39;s maturity goals are infinite. </p><p>Systems designed to diverge infinitely (with normal X.X.X semantic versioning), even those designed to converge infinitely (as with <a href="http://www.tex.ac.uk/FAQ-TeXfuture.html">Knuth versioning</a>), also achieve maturity, often great maturity, without being quite frozen. </p><p>For example, C is a very mature language. C has long since mastered backward compatibility. We can be sure that any C program which compiles on today&#39;s correct C compilers will compile on any future correct C compiler. </p><p>But, since C is not frozen, we can&#39;t be sure that today&#39;s C compilers will compile any future C program. So C has not yet achieved perfect <i>forward</i> compatibility. By definition, a frozen system is compatible both forward and backward. So C is mature, but it could still get more mature. </p><p>The point of a frozen OS is to shoot for <i>infinite</i> maturity. Obviously a frozen platform is compatible forever in both directions. </p><p>Infinite maturity does exist in the real world. But only in a few simple file formats and protocols — IP, JSON, XML. And not all this maturity is the result of perfection. Some is just the accident of a missing update mechanism. </p><p>But IP, JSON, XML... this is how stable, how taken for granted, system software should be. And can be. Certainly, any JSON parser today will parse any JSON document made in the future. </p><p>The dream of absolute zero is an OS whose core components are so simple, so boring, and so mechanically straightforward that we can imagine them becoming finished and never changing. We need to freeze not just a format or a protocol, but a language, a kernel, a standard library. To succeed, we need to flush out each quirk, complexity, and creeping feature, until the system is so boring and obvious that no one even wants to change it. </p><h2 id="kelvin-versioning-">Kelvin versioning </h2><p>“Kelvin versioning” is one way to track a project designed to be frozen. </p><p>In Kelvin versioning, a version is an integer in degrees Kelvin. Absolute zero is frozen — no further updates are possible. If your Kelvin versions don&#39;t track your actual progress, you run out of integers. This danger is a concrete incentive for the project to track its own progress accurately. </p><p>(Kelvin versioning isn&#39;t useful only at lifecycle scale. It can be used for any development process with an irreversible end — as build numbers for a release, for example.) </p><h2 id="the-palm-tree-dependency-model-">The palm-tree dependency model </h2><p>A whole OS can&#39;t have a single Kelvin number. It has to consist of multiple components which depend on each other. What&#39;s the right dependency model for the parts of a frozen OS? </p><p>One way to think about dependencies across a whole OS is the “palm-tree model.” Fundamentally, there are two kinds of components in a system: “exclusive” components (where we have to choose one version of the code), and “inclusive” ones (where different users can see different versions). </p><p>The exclusive components are the trunk of the palm tree: a stack of layers, each of which has one active copy. For instance, you are only running one kernel at a time. Different apps cannot use different versions of the kernel. </p><p>The inclusive components are the fronds, branching out in any direction they want. Not only can two apps use different versions of the same library, in many situations <i>one</i> app needs to be able to use two different versions of the same library. </p><h2 id="the-palm-trunk--telescoping-kelvins-">The palm trunk: telescoping Kelvins </h2><p>Any subsystem that serves as any kind of platform is exclusive, since anything that runs on top of the platform has to choose one version of the platform to run on. Since layers are good, this creates a natural stack which can get quite tall — and include components which are technically in userspace. </p><p>The right way for this trunk to approach absolute zero is to “telescope” its Kelvin versions. The rules of telescoping are simple: </p><p>1. If tool B sits on platform A, either both A and B must be at absolute zero, or B must be warmer than A. </p><p>2. Whenever the temperature of A (the platform) declines, the temperature of B (the tool) must also decline. </p><p>3. B must state the version of A it was developed against. A, when loading B, must state its own current version, and the warmest version of itself with which it&#39;s backward-compatible. </p><p>Of course, if B itself is a platform on which some higher-level tool C depends, it must follow the same constraints recursively. </p><p>The important effect of obeying rule 2: in a tall trunk, it&#39;s sufficient to state your dependency on the platform directly below you. Suppose C sits on B, which sits on A and exports features of A. C can state only the version of B it&#39;s written against, because when A chills, B must also chill. </p><p>If A could chill without B chilling, we could modify C to use new features of A. Then our new C would silently fail to work on an A-B stack which had not received the A update. </p><h2 id="the-palm-fronds--total-flexibility-">The palm fronds: total flexibility </h2><p>The goal of the trunk is to get to the fronds. In the fronds, no one should ever worry about dependency conflicts. And nothing is ever frozen, or has to be frozen. </p><p>The right way to solve dependencies in userspace is: within an organization, use a monorepo and link relative to its head. Between organizations, use pinned version numbers that are as immutable as possible. Avoid programming environments that create exclusion problems in userspace — for instance, that compel a single process to choose one version of a library when a diamond dependency exists. </p><p>There is almost never any good reason to automatically update dependencies with fresh versions of foreign code. In the case of a security update, the maintainer of an app which depends on a patched library needs to catch the patch and propagate the update in a new version of the app. An app shouldn&#39;t be security-critical to begin with, and propagating updates is a basic function of a modern OS. Also, if the app is security-critical, it could have its own bugs, so it needs a maintainer and an update pathway anyway. </p><h2 id="urbit--status-and-prospects-">Urbit: status and prospects </h2><p>Yes, we do believe it&#39;s possible to write a freezable OS. In fact, we wrote one. And it works. It&#39;s not yet frozen (except at the bottom layer), but it&#39;s getting there. </p><p>Urbit, a clean-slate functional OS, has been under development since 2002. It took a decade (as a one-man project) just to build a prototype of a freezable OS. The result in 2017 (now with a small company) is a telescoping Kelvin stack of layers from VM to UI. </p><p>At the bottom (the VM Nock), this stack is slightly warmer than liquid helium (5K). It&#39;s easy for Nock to get this cold, because it&#39;s defined in a page of axioms that gzips to 340 bytes. We are in no hurry to declare zero, but any change at this point would be both very unlikely and very difficult to implement. </p><p>Urbit&#39;s typed functional language, Hoon, which compiles itself to Nock, is closing in on liquid krypton at 143K. Hoon is defined in about 5,000 lines of Hoon, or 10,000 if you count the deep standard library. Nock will never need to change; Hoon is perfectly serviceable but has some well-known rough spots. </p><p>Above Hoon, the stack rapidly gets much warmer. Arvo is an event-driven microkernel that&#39;s 1,000 lines of Hoon. Above this are another 5,000 lines of system library, then 12,000 lines of Arvo modules: a peer-to-peer network, a PKI and private ledger, a revision-control system, an HTTP gateway, a functional build system, and an application sandbox. A trivial working system needs another 5,000 lines for basic chat and shell apps. </p><p>We haven&#39;t had meaningful Kelvin numbers for the Arvo layer, but this release will change that. About a third of Arvo has been or will be rewritten in the last year; we&#39;ll assign Kelvins once this code (which now compiles) is tested into existence, largely based on how close the last compiling draft was to the first working draft. But you&#39;ll certainly be able to cook eggs on it. </p><p>(Once again, not being frozen doesn&#39;t mean not working. Until all these layers are finished, we&#39;ll be updating them over the air. To be exact, Urbit distributes its own updates through subscriptions in its own revision-control system.) </p><p>The actual status of Urbit is that in 2017, we hope to make our last discontinuous update — meaning that instead of your Urbit node updating itself silently, you destroy and recreate it. Urbit works today, but it isn&#39;t really alive until today&#39;s Urbit data lives forever. </p><p>Even committing to continuity is a significant step toward the frozen OS, because we&#39;re committing to never making another change that the present platform can&#39;t install. Fortunately, the only layer that has to stay frozen for this is Nock. </p><h2 id="the-style-of-convergent-system-software-">The style of convergent system software </h2><p>We&#39;re obviously in no position to declare victory at any layer above Nock, but aiming at absolute zero creates a system design style we think works very well — even if we never get to zero. </p><p>Deep, onion-like layering is essential. A thin layer has no room to grow. A good example of this principle is the difference between Urbit and Lisp machines. Both Nock and Lisp are very simple axiomatic definitions of computing. But practical Lisp systems expand by extending the model, whereas Urbit layers over a frozen axiom system. </p><p>Software that expands by extension is inevitable. But we need to be able to kick it up to userspace. System software should be concerned with the fundamental problems of computing, which don&#39;t change. The few cases in which they do change — like crypto algorithms — are special cases, easily encapsulated. And even these changes can be expected to slow down in the long term. </p><p>Perhaps the best example of the convergent style in existing, mature system software is the relational database. The genius of the relational model is that it&#39;s designed to never grow hair. Even SQL, with its COBOL-era syntax, is essentially invulnerable to any significant non-cosmetic improvement. </p><p>The lesson: when we see a system that seems to want to expand indefinitely, we can and should look for a layer division within this system, separating an inner layer that tends to converge from an outer layer that naturally diverges. Layering is what distinguishes true system software from the giant balls of mud that all deep codebases want to become. </p><p>Are all balls of mud, or at least all the muddy parts of an OS, susceptible to this transformation? We think so. But we&#39;ll see. </p><p>As usual, comments are on fora. Check out <a href="https://urbit.org/fora/posts/~2017.5.12..20.30.11..0050~/">this thread</a>. </p></div></div></div></div></div><footer class="container mb-36"><div class="row"><div class="col-sm-8 col-sm-offset-3 col-lg-4 col-md-offset-2"><div id="mc_embed_signup"><h2 class="mb-2">Updates</h2><p>Every month we send an email with community events and what we&#39;re up to. </p><iframe name="nothing" style="display:none;"></iframe><form id="mc-embedded-subscribe-form" class="validate" action="https://urbit.us11.list-manage.com/subscribe/post?u=972a03db9e0c6c25bb58de8c8&amp;amp;id=be143888d2" method="post" name="mc-embedded-subscribe-form" target="nothing"><div class="input-group text-mono" id="mc_embed_signup_scroll"><div class="mc-field-group"><input class="required mb-2" type="email" name="EMAIL" id="mce-EMAIL" placeholder="your@email.com"></input></div><div id="mce-responses" class="clear"><div id="mce-error-response" class="response" style="display:none"></div><div id="mce-success-response" class="response" style="display:none"></div></div><div style="position: absolute; left: -5000px;"><input type="text" name="b_972a03db9e0c6c25bb58de8c8_be143888d2"></input></div><div class="clear"><button id="mc-embedded-subscribe" class="bg-black white h-font" type="submit" name="subscribe"><span class="text-500">Subscribe</span></button></div></div></form></div></div></div><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>