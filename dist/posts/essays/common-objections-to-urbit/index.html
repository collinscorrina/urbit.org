<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Posts</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div class="container mt-10"><div class="row fixed"><div class="col-sm-12 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-8 col-md-12 ml-1 mt-3 sm-2"><ul class="list-reset h-font"><a href="/posts"><li>All</li></a><a href="/posts/updates"><li>Updates</li></a><a href="/posts/essays"><li>Essays</li></a><a href="/posts/media"><li>Media</li></a></ul></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-3 col-md-offset-2"><div class="post col-sm-12"><div><h1 id="common-objections-to-urbit-">Common Objections to Urbit </h1><img src="http://media.urbit.org/site/blog-9.jpg" border="12" /><p><i>~2016.6.28</i> </p><p>We love crowdsourced criticism. We&#39;ve heard a lot of great objections to Urbit. Surely there&#39;s more out there! If so, comments are open at the bottom of the page. We&#39;ll revise this document to include anything new and interesting. </p><p>Here&#39;s our list right now: </p><ul><li><p><a href="#prime">Urbit is not ready for prime time.</a> </p></li><li><p><a href="#jets">Nock jets are a total hoax.</a> </p></li><li><p><a href="#log">Urbit needs an infinitely extending packet/event log.</a> </p></li><li><p><a href="#scam">Urbit is a total scamcoin. It&#39;s 100% premined.</a> </p></li><li><p><a href="#gov">Urbit isn&#39;t even really decentralized! It has a government!</a> </p></li><li><p><a href="#sand">Sandstorm/IPFS/Ethereum is way ahead of Urbit.</a> </p></li><li><p><a href="#planet">Urbit doesn&#39;t have enough planets for every human being.</a> </p></li><li><p><a href="#pwned">Cloud computing is inherently non-private.</a> </p></li><li><p><a href="#code">Urbit will never be able to call any existing code.</a> </p></li><li><p><a href="#program">Hoon is too weird. No one will be able to program in it.</a> </p></li><li><p><a href="#stuck">Urbit programmers are stuck with Hoon.</a> </p></li><li><p><a href="#user">Ordinary users will never be able to manage an Urbit server.</a> </p></li><li><p><a href="#killer">Urbit has no killer app.</a> </p></li><li><p><a href="#horse">Urbit is sniffed at by Houyhnhyms.</a> </p></li></ul><p><i>“We choose to go to the moon, not because it is easy, but because it is hard.”</i> — <a href="https://www.youtube.com/watch?v=g25G1M4EXrQ">John F. Kennedy</a> </p><h2><div id="prime">Urbit is not ready for prime time.</div></h2><p><b>TLDR</b>: we agree. </p><p>Urbit right now is a fun toy. It is fun to learn Hoon. It is even fun and quite practical to make actual contributions. (Hoon&#39;s IEEE floating-point was written by someone we&#39;ve never met: <code>~nym</code>, formerly <code>~nodpet-rinned</code>.) In fact, we have never seen anyone <i>not</i> have fun with Urbit. </p><p>But there is all kinds of stuff wrong with the codebase. Urbit&#39;s documentation is much improved, but remains incredibly weak -- Arvo is almost totally undocumented. Scaling is poor at best. Urbit&#39;s reliability is dubious. Its security is nil. </p><p>Urbit is feature-frozen. The only thing we&#39;re working on now, and for the rest of 2016, is doc, debugging and and self-hosting. In that order of importance -- teaching Urbit is more important than fixing it, which is more important than making it useful. But we&#39;re quite confident that these are all solvable problems. </p><p>The most important milestone about Urbit today is that it&#39;s ready for technical decisions to be made collectively. A system like Urbit can only be invented by a mad auteur. It can&#39;t be maintained or stabilized by a mad auteur. Our primary goal today is expanding the number of people who understand Urbit, and we expect these pioneers to participate in technical governance. </p><h2><div id="jets">Nock jets are a total hoax.</div></h2><p><b>TLDR</b>: all of computing is a hoax. You can&#39;t compare a hoax to nothing. You can only compare it to all the other hoaxes. </p><p>A “jet” is a sort of software device driver in Urbit. Urbit is precisely defined in terms of an interpreter that fits on a T-shirt, Nock. But a naive implementation of Nock is nowhere near practical, because Nock has only one integer operation: increment. For example, to decrement a number in Nock, you increment a counter up to the number under it. </p><p>The only way an efficient Nock interpreter can work is to recognize algorithms like decrement, and implement them non-naively. By far the easiest way to do this is not to analyze arbitrary code as it&#39;s being executed, but to register and match well-known implementations in the standard library. No one should be writing their own decrement. </p><p>But the semantics of the interpreter, <i>so long as the jet and the jet harness are defined correctly</i>, are exactly those of Nock. We are not extending or changing Nock in any way. We are just taking a shortcut in certain cases we understand perfectly. </p><p>It&#39;s not at all unprecedented to have implementations much more complex than the corresponding specification. The x86 instruction set is relatively simple; the complexity of its decoding and execution path in a modern CPU is enormous. This path may well have “peephole optimizations” that replace matched algorithms, and if it doesn&#39;t the modern compiler does. People, <i>bad</i> people, use “jets” to cheat on benchmarks all the time. </p><p>Nock is designed as a standard. It&#39;s built like a standard. Typically what causes real problems in standards is ambiguity. Two implementations are incompatible, but each swears it has the right interpretation of the natural-language spec. This simply cannot happen in the Nock world. If two implementations disagree, at least one of them is incorrect. This puts us firmly in “with enough eyeballs, all bugs are shallow” territory. </p><p>The fact remains, however, that a Nock interpreter without jets is completely useless. And there is not even an informal document that tells you what jets you need for a reasonably efficient Urbit. (There should be such a document.) </p><p>The correct way to think about jets is not to compare them to a perfect interpreter created by unicorns. Jets are a combined replacement for two other techniques in language implementation: intrinsics and a foreign-function interface. </p><p>Compared to both intrinsics and an FFI, your jets have one key disadvantage: they need to be specified in pure code. You may not have this executable specification, which means you need to write it. Is this really so bad for your development process? An executable specification? Which can be trivially tested against the efficient implementation? </p><p>Compared to intrinsics, jets give you true separation between mechanism and policy; only the interpreter, not the programmer and not the compiler, needs to know what&#39;s accelerated. </p><p>Compared to an FFI, jets preclude I/O, so can be trivially sandboxed. Except that the programmer needs to mark routines which may benefit from optimization with a hint, here too we separate mechanism (efficient implementation) from policy. </p><p>Yes, formal verification of jet equivalence is desirable. However, in the real world, many specifications, including quite complex ones, are tested into equivalence by brute force. </p><p>Urbit has some jet abuses. The equivalence between our markdown parser in Hoon and the CommonMark C library is super dubious. It should be revisited. </p><p>But the miscomputation resulting from a minor jet discrepancy is not a security hole or even fatal. It effectively means the event history, computed correctly, does not match the current state. The way to resolve this conflict is for the current state to win, and the event history to be discarded -- not abnormal anyway. See the next question. </p><h2><div id="log">Urbit needs an infinitely extending packet/event.</div></h2><p><b>TLDR</b>: no, it doesn&#39;t. Urbit can prune the log. </p><p>We can prune the event log because the Urbit transition function doesn&#39;t have any access to the event history -- just the current state and the current event. </p><p>Urbit defines the semantics of a complete event log. It doesn&#39;t and can&#39;t require an implementation to maintain the whole log. It can maintain a checkpoint and the log since that checkpoint. </p><p>However, any practical urbit maintains a periodically updated checkpoint. Our present implementation doesn&#39;t provide a way to prune the event log. But that&#39;s just a missing feature. We have one or two of those! </p><h2><div id="scam">Urbit is a total scamcoin.  It&#39;s 100% premined</div></h2><p><b>TLDR</b>: yeah. But at least it&#39;s not the DAO. </p><p>Like a cryptocurrency, Urbit is a digital title. But Urbit is digital land, not digital money. If you assess it as a currency, it&#39;s a lousy currency. If you assess a cat as a dog, it&#39;s a lousy dog. </p><p>In real-world economics, the crucial distinction between land and money is that land (a) has intrinsic utility and (b) is non-fungible. </p><p>Because of (b) alone, frictionless transactions in land are impossible. A blockchain is only needed to ensure zero-cost high-frequency transactions. So digital land doesn&#39;t need a blockchain. Which means it doesn&#39;t need mining. </p><p>Of course, just because a digital title system doesn&#39;t need mining, doesn&#39;t mean it can&#39;t distribute an initial allocation by proof-of-work -- or by any other arbitrary method which is careful not to benefit the system&#39;s own developers. Could we give away the Urbit address space randomly? Sure. But why? </p><p>Probably the purest design is the “proof-of-burn” initial allocation used by some coins. By any standard, proof-of-burn is technically beautiful and results in an extraordinary level of ethical independence. We can&#39;t help but admire it. </p><p>But any altcoin or metacoin is just way less work than Urbit. An altcoin can afford to burn even its creation energy, capturing no value at all from its seigniorage. Your altcoin doesn&#39;t have a clean-slate system software stack to drive. If your rocket has to go to the moon, it&#39;s going to leave a little bit of smoke in the air. </p><p>Ethically, what makes “premining” feel wrong is that the creators of the currency are rewarded disproportionately for their effort. The scamcoin is a get-rich-quick scheme, vaguely pyramid-shaped. Nothing about Urbit matches this pattern at all. </p><p>Curtis invented Urbit. So by the <a href="https://en.wikipedia.org/wiki/Homestead_principle">homestead principle</a>, he started out owning all of it. But by now, Urbit&#39;s 8-bit galaxies have already been distributed among <a href="https://github.com/urbit/arvo/blob/master/sys/vane/ames.hoon#L118-L373">57 separate individuals</a>. Curtis owns 20, or about 8%. </p><p>Tlon, the corporation which still runs Urbit development, has 95. (Without Tlon, there is basically no Arvo.) 50 are reserved for a hypothetical Urbit Foundation. Tlon employees have another 16. </p><p>The rest of the galaxies belong to donors, investors, contributors, contest winners, and just random people who were in the right place at the right time. One is a Silicon Valley tycoon. Another is an Orthodox nun in a monastery in Greece. A couple are ex-Tlon employees who might totally hate us. There is nothing they all have in common, which is sort of the point. </p><p>This property distribution looks a lot like land ownership in the real world -- complex and asymmetrical. That&#39;s no accident. If you have a problem living in New York because New York&#39;s real estate is not distributed equally among its residents, you may have a similar problem with Urbit. The reality is that Urbit, like New York, wasn&#39;t born yesterday and comes with a complex ownership history which we couldn&#39;t possibly change, even if we wanted to. </p><p>Decentralization is hard. The only real goal of a property system in address space is to create and maintain decentralization. The whole network has to exhibit centrifugal force, not centripetal force. Proof-of-work systems certainly seem to have unexpected centripetal qualities, producing unanticipated concentrations of centralized hashpower. See the next objection. </p><h2><div id="gov">Urbit isn&#39;t even really decentralized!  It has a government!</div></h2><p><b>TLDR</b>: it&#39;s technically impossible for Urbit to be decentralized at this stage of its life. Urbit is designed to achieve decentralization, not be born with it. </p><p>A young network can&#39;t afford to be decentralized. It has to act as a unit. Because it has no network effect, it needs every scrap of efficiency it can get. </p><p>A decentralized general-purpose computing network like Urbit can <i>only</i> be bootstrapped by a central government. For example, by default your urbit upgrades its OS automatically (like an “evergreen” browser) with signed network updates. Whoever signs these updates is a government by definition. </p><p>When it&#39;s impossible to eliminate centralized power, it becomes necessary to tame, stabilize, and limit it. This should not be surprising to anyone living under a constitutional government. </p><p>As we found out with the DAO, if a network isn&#39;t ready to be decentralized, its developers shouldn&#39;t even try. If Ethereum is hard-forked to roll back the DAO (which looks like the most probable result), it acknowledges that it both has a central government, and needs a central government. Decentralization is good. Pretend decentralization -- “decentralization theater” -- is harmful, and not a effective path to actual decentralization. </p><p>A key test of a free software project&#39;s health is whether it can fork. So long as the unity of the public-key hierarchy and the network protocol is maintained, the Arvo kernel and Urbit system can fork in all kinds of ways without disrupting the network. Any stress will fragment the “government” that develops the kernel, and as it fragments it grows more limited and stable. </p><p>Urbit is designed to govern itself collectively by address space ownership -- effectively, “proof of stake.” Any arbitrary power, will tend to fracture along these property lines. For instance, our hot updates are sent through the galaxy hierarchy; in a development fork, active galaxies would pick upstream sources. Two implementations of a standard are better than one. </p><p>And by fragmenting the galaxy space into 57 separate partitions, we&#39;ve created a global property map which is much more likely to splinter further, than reunite. </p><p>In the long run, every galaxy should have a separate owner, who is a human being rather than a corporation. Combining galaxy holdings will damage the reputation of both galaxies. The only reason to merge ownership is to move toward incipient monopoly. Whether a galaxy admits this openly or denies it dishonestly, its reputation will suffer. </p><p>The technical goal of Urbit is to create a network which, <i>if it actually takes over the world</i>, inevitably becomes decentralized. Even if Urbit takes over the world, no individual or coherent organization takes over the world. There is nothing even close to a single point of failure in a mature, successful Urbit. </p><p>This is the goal of all the new “web3” decentralized systems. If IPFS, Sandstorm or Ethereum takes over the world, nobody takes over the world. (The same is almost true of the Internet -- though it wouldn&#39;t be that surprising if a time traveler from 2116 revealed that ICANN had become a planetary government.) </p><p>Urbit, by starting out as a centralized network, just reduces the technical problem to match the actual goal. Only long-term decentralization matters. </p><p>It&#39;s very important that Urbit in 2116 be fully decentralized. For Urbit in 2016, pretending to be decentralized would be a joke at best, and a hoax at worst. And of course, no one can DAO us -- since the property system is still just a central registry. Among other things, we check it into Github. Github is not a blockchain -- but still, good luck with that. </p><h2><div id="sand">Sandstorm/IPFS/Ethereum is way ahead of Urbit.</div></h2><p>In general, web3 (next distributed web) solutions don&#39;t compete with each other. They support each other. Concretely, they are all part of each others&#39; network effect. </p><p>IPFS, Sandstorm, Ethereum, and Urbit can all take over the world at the same time. None of them competes with the others. They enable each other. </p><p>For instance, IPFS and Urbit are both global immutable namespaces. IPFS is a chord-routed, content-addressed namespace. Urbit is a direct-routed, identity-addressed namespace. Urbit is a typed revision-control system; IPFS is a blob store. IPFS isn&#39;t a computer; the work hasn&#39;t been done, but Urbit can easily mount the IPFS namespace and compute functionally against it. </p><p>So the better IPFS does, the less Urbit needs to struggle against its lack of network effect. The better Urbit does, the easier it is for IPFS to point to a functional language that can actually use its referential transparency directly. So their relationship is symbiotic, not competitive at all. </p><p>The closest thing to a general-purpose competitor that Urbit has is Sandstorm. Sandstorm, which by the way rocks, is also a personal server built around a network protocol. </p><p>But Sandstorm and Urbit compete in the way that, on the PC, the OS and the browser compete. In theory, the OS could solve the problems that the browser solves; or the browser could be the OS. In practice, Windows is a great OS to run a browser on. </p><p>Similarly, a world in which Sandstorm takes off is an awesome world for Urbit, because everyone who has a Sandstorm instance has a great platform for running Urbit on. Urbit on Sandstorm will be a sort of “double-hulled” personal server, safer and more friendly than either system alone. </p><p>Sandstorm and Urbit have very different approaches to network identification; Sandstorm uses capabilities, Urbit identity. Broadly speaking, we believe, capabilities are optimal for expressive power; but identity is optimal for the UI of the common case. We&#39;d need to see the Powerbox, Sandstorm&#39;s UI, more fully fleshed out to understand its UI approach better. </p><h2><div id="planet">Urbit doesn&#39;t have enough planets for every human</div></h2><p>A 32-bit planet is a tool, not a toy. Like a car, it&#39;s a device for a responsible and independent adult. There aren&#39;t 4 billion cars in the world, nor 4 billion independent adults. </p><p>If you aren&#39;t an independent adult, and you don&#39;t need or even shouldn&#39;t have unconditional digital freedom (no one&#39;s 8-year-old daughter needs unconditional digital freedom), a moon from someone else&#39;s planet is fine. (Even most of today&#39;s independent adults don&#39;t complain enough about being Facebook&#39;s moons.) </p><p>And limiting the supply of anything doesn&#39;t create a shortage. It sets a price. Ideally, in the long run, we think a planet should cost about $10. This could be off by an order of magnitude either way, and it wouldn&#39;t be the end of the world. </p><p>If a planet costs $10, that means you paid $10 to get a planet. A planet with no reputation has a positive reputation, because someone paid $10 for it and hasn&#39;t yet done anything wrong. Positive default reputation is the single quality that makes a social network social. </p><p>There is always a tradeoff between free speech and free beer. Urbit will always choose free speech. </p><h2><div id="pwned">Cloud computing is inherently non-private.</div></h2><p><b>TLDR</b>: a general-purpose cloud computer is much, much more private than a special-purpose cloud computer. In general, a cloud VM is secure against corporations but not governments. With a global adversary, compute in your closet -- or even on your body. </p><p>One reason we want the decentralized Internet is that we&#39;re tired of giant corporations spying on us. Think about it this way: Amazon is Netflix&#39;s main competitor. And yet, Netflix runs its whole operation on AWS. Why is Netflix sure that Amazon won&#39;t spy on it? </p><p>A general-purpose virtual machine is special from a privacy standpoint, just because it&#39;s commercially realistic to design terms of service that prevent the host from peeking and poking at the customer&#39;s machine. Crossing this moat is technically nontrivial and can&#39;t possibly happen by any reasonable accident. No hosting contract could contemplate it. </p><p>Whereas when your cloud computer is a special-purpose machine -- just a database row on some corporation&#39;s mainframe -- there is no way these services can promise not to handle your data. Handling your data is <i>what they do</i>. On a special-purpose server, the concept of privacy is not even defined. </p><p>Where even a general-purpose server falls down is where the user has a sovereign adversary, which can secretly violate explicit or implicit hosting contracts. Users with a sovereign adversary must rely only on their own physical security. </p><p>However, most users don&#39;t have a sovereign adversary. And those who do maximize their “herd immunity” if they can use the same protocols as those who don&#39;t. Otherwise, the adversary could simply focus on everyone who uses the secure protocols. </p><p>Also, the portability of a cloud server image is critical. Of course, since Urbit is formally specified, it&#39;s trivially portable. In fact, one strategy against sovereign adversaries may be continuous rotation between hosts, like an MX missile. </p><h2><div id="code">Urbit will never be able to call any existing code.</div></h2><p><b>TLDR</b>: neither will Javascript. And dear Unix, the browser does not miss interacting with your <code>$LD_LIBRARY_PATH</code> at all. </p><p>You can&#39;t talk to the OS or use system libraries from Javascript. Therefore, there is no point in having any kind of gateway, compatibility bridge, native methods, or other interface between Javascript and C. </p><p>When in doubt, remember that Urbit is “the browser for the server side.” It plays by the same general rules. Isolation means isolation. </p><h2><div id="weird">There&#39;s no way Urbit will ever be adopted.  It&#39;s too weird.</div></h2><p><b>TLDR</b>: Urbit adoption is designed to be driven by ordinary end users. Urbit isn&#39;t ready for ordinary end users yet. We&#39;re working on it -- come help. </p><p>Right now, Urbit is a developer tool. Or rather, a developer toy -- since the only thing it&#39;s useful for is developing Urbit. It also could be a much better toy. We&#39;re working on that too. </p><p>But it&#39;s absolutely wrong to think of Urbit being adopted as a developer tool in the conventional sense. If you think this is almost impossible, you&#39;re right. </p><p>If we look at the way most successful platforms are adopted, they&#39;re not adopted for their own virtues. They&#39;re adopted because they&#39;re part of a larger solution. It&#39;s very hard to displace a native component of an existing platform. Urbit is not trying to do this. </p><p>C is a better language than Pascal, but it didn&#39;t beat Pascal because it&#39;s a better language. C beat Pascal because C was the native language of Unix, and people wanted to program in Unix. People don&#39;t use Javascript because Javascript is a great language, but because it&#39;s the native language of the browser. Replacing the native language of a platform may be doable -- but it&#39;s incredibly hard. </p><p>Hoon is not competing with C, or even Haskell, as a Unix programming language. The only reason to program in Hoon is that it&#39;s the native language of Urbit. Urbit is not competing with node.js or Rails as a Web backend. The only reason to run Urbit is to run a personal server. </p><p>Nock is cool, but it only gets adopted if Hoon gets adopted. Hoon is cool, but it only gets adopted if Urbit gets adopted. Urbit only gets adopted if it&#39;s useful as a personal server for human beings -- most of whom won&#39;t be Hoon programmers, or programmers at all. </p><h2><div id="program">Hoon is too weird.  No one will be able to program in it.</div></h2><p><b>TLDR</b>: Hoon is ridiculously simple. Our documentation and tooling are just immature. </p><p>It&#39;s pretty fair to assume that (a) functional programming is hard and weird, (b) Hoon is weird even for a functional language, so (c) Hoon must be hard-squared. </p><p>Actually, Hoon is weird even for a functional language because it&#39;s an attempt to remove the hardest things about functional programming: category theory, lazy evaluation, and gratuitous abstraction. To know a language is to know what the compiler is doing; all the semantics of the Hoon compiler fit in 2000 lines of code. </p><p>It&#39;s too easy for us to wind up living in Isaac Asimov&#39;s Trantor, a world in which everything got invented thousands of years ago and the idea of new technology is just weird and scary. History isn&#39;t over yet, and nor is technical history. </p><p>New things are harder to learn than old things. We ask smart high-school students to learn calculus. Think about how much harder it was for Newton and Leibniz to invent calculus, or for their first students to pick it up. Hoon is nowhere near as hard as calculus. </p><p>Most of the difference is just the collective certainty that our society conveys to a high-school student that calculus is learnable. When you&#39;re learning Urbit, you don&#39;t have this collective knowledge; so you don&#39;t have the confidence that the problem is solvable. Confidence makes a huge difference. Moreover, any bug or glitch in the developer experience destroys this confidence and takes a long time to heal. </p><p>Yes, we know: Hoon remains quite hard to learn. Again, we have no reason to think this problem isn&#39;t solvable. Public enlightenment remains our main priority. </p><h2><div id="stuck">Urbit programmers are stuck with Hoon.</div></h2><p><b>TLDR</b>: patience, grasshopper. </p><p>There&#39;s quite a straightforward way to implement any perfectly specified language with a reliable interpreter in Hoon. First, write an interpreter for that language in Hoon. Second, jet that intepreter function with the existing implementation. </p><p>It is not clear that Javascript is <i>quite</i> well-defined enough for this treatment. But Lua probably is. </p><h2><div id="user">Ordinary users will never be able to manage an Urbit server.</div></h2><p><b>TLDR</b>: Urbit&#39;s technical simplicity has always been designed to drive human usability. But the polish is the last thing that goes on. So we can&#39;t evaluate this claim right now. </p><p>Right now, Urbit is only for geeks. You already need to be able to wrangle a Unix machine to run it. What&#39;s the point? </p><p>This Urbit isn&#39;t the real Urbit. It&#39;s an early milestone on the way to the real Urbit. </p><p>The real Urbit -- for normal human beings -- is a hosted service. Getting a planet is as easy as signing up for Facebook. Probably many users will think of it as another web account. They might not even know it can run more apps than the ones they use. </p><p>A deterministic, persistent cloud computer is something different from a traditional server. Normally when we think of a server in the cloud, we think of it like a live animal -- a creature that needs to be cared for, fed, and herded. A file in the cloud is more like a rock -- you can forget about it for ten years. </p><p>An urbit is a general-purpose computer, but it doesn&#39;t even have the concept of a reboot. It upgrades itself. If you don&#39;t feed it any packets for ten years, then turn it back on, it will spend a day or two upgrading itself, then be back to normal. Maybe it&#39;s something in between a rock and an animal -- a cactus? </p><p>Another huge difference versus an Internet server is that we&#39;re confident that Urbit&#39;s limited supply of identities will make it easy to keep abusers off the network. So far, so good -- but of course, no one abuses a young network. </p><p>The bottom line is that managing your urbit has to be as easy as managing your iPhone. Normally, it consists of deciding what apps you want to be running, and how much you trust them. Resources can&#39;t be free, so sometimes you have to play memory police. Humans have shown that they can handle these tasks. </p><p>Our &#39;70s OSes and networks, which were great designs in their day and have matured into excellent industrial tools, give us a totally misleading impression of how hard it should be to manage a general-purpose computer. Computing isn&#39;t scary or dangerous. Unix and the Internet are scary and dangerous. That&#39;s fine for an industrial tool, but not a personal tool. </p><h2><div id="killer">Urbit has no killer app.</div></h2><p><b>TLDR</b>: the killer app is personal API aggregation. </p><p>It&#39;s a truism that any new platform has to be fundamentally much better at solving some problem than the mature platform it seeks to replace. </p><p>We can look at Urbit&#39;s killer app from two perspectives: as a developer, and as a user. </p><p>From the developer&#39;s perspective, Urbit&#39;s advantage is that it&#39;s a network stack which provides exactly-once delivery of typed, validated, transactional, encrypted and authenticated messages. The difference between an Urbit API and a REST API is like the difference between a paved road and a dirt road. On the other hand, you do need to learn a new functional language. </p><p>From the user&#39;s perspective, there&#39;s one task that any personal server can perform, that can&#39;t be performed by any Web service: unrestricted API aggregation. </p><p>Well before Urbit is ready to <i>replace</i> any conventional web services, it should be ready to <i>command</i> them in place by API. (Or if needed, by scraping.) If all you care about is being in control of your own data, it&#39;s fine to leave it in the hands of these services, as you have the API secrets to get it out. </p><p>Managing a set of security connections to your existing services is one of the first important tasks of a modern personal server. This is a stateful task that typically requires both a durable API key and a temporary OAuth token. APIs change all the time, so connection maintenance also requires evergreen updates. </p><p>The origin of this API key will vary, but usually the best way to set it is BYOK: the user registers their own urbit as an “app.” And the neat thing about having your own API keys, for multiple services, on a single general-purpose computer, is that none of these services really has any practical way to control what you do with your own data. </p><p>Terms of service which constrain the use of data (as opposed to the abuse of the service) simply aren&#39;t realistic and will no longer apply. This enables a variety of novel user experiences which aren&#39;t implementable as traditional web services, and also aren&#39;t available via conventional third-party API aggregators. </p><p>Also, since Urbit is after all quite immature, it doesn&#39;t make much sense to restrict this security state to code within Urbit. The Urbit interpreter <code>vere</code> runs as a Unix daemon that implements the FUSE user-level filesystem protocol, and maps the data on your services into the Unix filesystem. For example, one of our demos lets you <code>ls</code> your Github issues. </p><p>So it&#39;s straightforward to build, for instance, a Python app that uses Urbit as a gateway to mash up a bunch of web services. As a Unix programmer, you might even just regard Urbit as a generic Web API gateway daemon, without worrying about its internals. </p><p>We have other ideas for initial killer apps. But this, we feel, is the best one. API libraries for <code>npm</code> et al abound. Stateful, self-updating, generic API aggregators with FUSE integration, also integrated with a reactive web server, are rarer. </p><h2><div id="horse">Urbit is sniffed at by Houyhnhyms.</div></h2><p>It&#39;s difficult to categorize <a href="http://ngnghm.github.io/blog/2016/06/11/chapter-10-houyhnhnms-vs-martians/">this awesome essay</a> in a single bullet point. So I&#39;ve saved it for last. </p><p>When reading this essay, it&#39;s important not to forget the amazing absence of genuine, mutually critical discourse in computer science (as in most sciences today). You never hear what Swift&#39;s designers think of Go, or vice versa. And critical public discourse decreases, not increases, with increasing academic legitimacy. </p><p>The basic test of any field purportedly scientific in nature is whether its researchers are genuinely interested in each others&#39; work, and willing to share these genuine responses publicly. If this practice does not exist, the field may still be useful and/or interesting. But it is not science. </p><p>What&#39;s awesome about Fare&#39;s essay is that he&#39;s <i>doing it right</i>. All the actual details are irrelevant. And mostly wrong. But that&#39;s of very little importance compared to <i>doing it right</i>. </p><p>Anyway, we&#39;ve already addressed the idea that jets are a sham. Some other points: </p><h3 id="event-sourcing-and-or-caching-is-a-pattern--not-a-layer-">Event-sourcing and/or caching is a pattern, not a layer </h3><p>Fare&#39; is perfectly right that “one size does not fit all” in persistence. Generally, Urbit uses event-sourced persistence. </p><p>But it has multiple layers of event-sourcing: in the definition of Urbit itself; in the application sandbox vane (Gall), and in the application itself. Urbit also has a completely orthogonal revision control system (Clay). </p><p>And there is not a single cache across the whole system, though arguably there should be; for instance, the functional build system (Ford, which Fare&#39; the master of build systems might appreciate) has its own internal cache. </p><p>It is a common mistake to confuse a design pattern with a layer or feature, and equally fatal whichever direction you fail. </p><h3 id="let-s-be-clear-about-why-dsls-suck-">Let&#39;s be clear about why DSLs suck </h3><p>DSLs suck not because they are difficult to newbies in the base language. DSLs suck because every time a programmer, even one <i>experienced</i> in the base language, comes into a new codebase or project, she has to learn a new custom language. </p><p>You need enormous wins to justify this cost. It&#39;s the goal of the base language designer to preempt these wins, creating a language which is almost never so tiresome and full of boilerplate that it requires a DSL or template layer. </p><p>Hoon is almost entirely made of macros -- but they are internal, fixed, built-in macros (with no gensyms). This fixed set of macros is essentially enough. Occasionally we want to add one or two. But we never, ever pine for context-dependent macros. </p><h3 id="determinism-is-not-consensus--and-is-not-constraining-">Determinism is not consensus, and is not constraining </h3><p>Fare&#39; is totally right that an urbit&#39;s data is meant for itself alone. In fact, an urbit has the right to compute incorrectly if it wants. We go to considerable lengths to ensure that you can&#39;t gain any particular advantage by incorrect computing. </p><p>The whole point of Nock is that it&#39;s so low-level that there is no conceivable advantage in upgrading it. Divergence is just pointless. This is not a question of network integrity, just of practical standardization. </p><p>This consistency stops at Nock. Without anyone violating the correctness of their lifecycle functions, anyone or everyone in Urbit could replace Hoon with Javascript. Determinism does not cramp Urbit&#39;s semantic style in any way, shape or form. </p></div></div></div></div></div><footer class="container mb-36"><div class="row"><div class="col-sm-8 col-sm-offset-3 col-lg-4 col-md-offset-2"><div id="mc_embed_signup"><h2 class="mb-2">Updates</h2><p>Every month we send an email with community events and what we&#39;re up to. </p><iframe name="nothing" style="display:none;"></iframe><form id="mc-embedded-subscribe-form" class="validate" action="https://urbit.us11.list-manage.com/subscribe/post?u=972a03db9e0c6c25bb58de8c8&amp;amp;id=be143888d2" method="post" name="mc-embedded-subscribe-form" target="nothing"><div class="input-group text-mono" id="mc_embed_signup_scroll"><div class="mc-field-group"><input class="required mb-2" type="email" name="EMAIL" id="mce-EMAIL" placeholder="your@email.com"></input></div><div id="mce-responses" class="clear"><div id="mce-error-response" class="response" style="display:none"></div><div id="mce-success-response" class="response" style="display:none"></div></div><div style="position: absolute; left: -5000px;"><input type="text" name="b_972a03db9e0c6c25bb58de8c8_be143888d2"></input></div><div class="clear"><button id="mc-embedded-subscribe" class="bg-black white h-font" type="submit" name="subscribe"><span class="text-500">Subscribe</span></button></div></div></form></div></div></div><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>