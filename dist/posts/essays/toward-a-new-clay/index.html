<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Posts</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div class="container mt-10"><div class="row fixed"><div class="col-sm-12 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-8 col-md-12 ml-1 mt-3 sm-2"><ul class="list-reset h-font"><a href="/posts"><li>All</li></a><a href="/posts/updates"><li>Updates</li></a><a href="/posts/essays"><li>Essays</li></a><a href="/posts/media"><li>Media</li></a></ul></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-3 col-md-offset-2"><div class="post col-sm-12"><div><h1 id="toward-a-new--clay-">Toward a New <code>%clay</code> </h1><p><i>~2016.7.14</i> </p><p>TLDR: (a) Urbit&#39;s revision-control system, <code>%clay</code>, is itself due for a (medium-sized) revision! (b) this time, you yourself can really help! (c) please don&#39;t give away the buried spoiler! </p><p>This explanation does not (or at least should not) require you to know anything about Urbit. </p><h3 id="but--clay-is-already-pretty-cool-">But <code>%clay</code> is already pretty cool </h3><p>Of course, nothing in Urbit is allowed to be <i>lame</i>. <code>%clay</code> is actually quite cool. It does need some work. But first, let&#39;s talk about what it is and why it&#39;s cool. </p><p><code>%clay</code> is the Arvo vane (Urbit kernel module) for revision control. It&#39;s an authenticated, human-memorable global immutable namespace which is also a typed revision-control system. It&#39;s also very good at subscription and synchronization. Urbit currently uses <code>%clay</code> to distribute live hotpatches; we transparently upgrade the whole network with one checkin. </p><h3 id="compared-to-other-revision-control-systems-">Compared to other revision-control systems </h3><p><code>%clay</code> is clearly a vanilla DVCS in the modern <code>git</code> style. Of deployed DVCS these days, <code>%clay</code> is probably closest in spirit to <code>bzr</code> or maybe <code>fossil</code>. </p><p>Obviously, as a part of a larger whole, you would expect any Urbit RCS to be brutally spartan. <code>%clay</code> is. It&#39;s even more spartan than <code>bzr</code>. </p><p>(In fact, it&#39;s really too spartan to fully use at the moment. We ourselves still use <code>%clay</code> mainly as a distribution system, and do all internal development on Github. This is because the present <code>%clay</code> lacks a few little conveniences, like commit messages. See upgrades, below.) </p><p>There are lots of normal DVCS things in <code>%clay</code>. But there are also cool and unusual ones. Let&#39;s take a brief tour of the high-level system, then describe what we think should change about it. </p><h3 id="anatomy-of-a-dvcs-">Anatomy of a DVCS </h3><p>A DVCS is a historical state graph. A point in this graph is a snapshot of some tree-structured system, like a filesystem. </p><p>These snapshots, including recursive internal nodes, are stored in a content-addressable store. Pointers in this store are used to construct a revision graph, whose edges are edit and/or merge actions. Some sort of namespace attaches meaningful names to current revisions in this graph. </p><p>There are six big questions in the design of a DVCS: </p><ul><li><p>how are snapshots named? </p></li><li><p>what is the data structure within a snapshot? </p></li><li><p>how does it map to the Unix filesystem? </p></li><li><p>how is the system queried? </p></li><li><p>how is the revision graph defined? </p></li><li><p>how does the content-addressable store work? </p></li></ul><h2 id="anatomy-of--clay-">Anatomy of <code>%clay</code> </h2><p>A good way to summarize <code>%clay</code> (at present) is that its answers to the first four questions are interesting, and its answers to the last two are boring. We&#39;ll talk about all six, though. </p><h3 id="global-namespace---ship-desk-case--">Global namespace: [ship desk case] </h3><p>The permanent global name of a <code>%clay</code> snapshot is a <code>++beak</code>. A beak is a triple: <code>[ship desk case]</code>. </p><p>The <code>++ship</code> is an Urbit ship. A ship is a network address, a human-memorable name and a cryptographic identity. The address width is variable; shorter addresses are more desirable. Most users have 32-bit addresses, which we map to four-syllable synthetic names like <code>~sorreg-namtyv</code>. </p><p>The <code>++desk</code> is a 4-letter word meaning “branch.” </p><p>The <code>++case</code> is a version, one of three kinds: a version sequence number, a named label, or a date. </p><p>In the Urbit path syntax, the beak is the first three segments of the path: <code>/ship/desk/case/my/cat/picture</code>. </p><p>In most cases, a path parser has a default ship, desk and case, each of which can be replaced by <code>=</code>. So <code>/=home=/my/cat/picture</code> is the data at <code>/my/cat/picture</code> on your own ship, in the <code>%home</code> desk, right now. Immutability doesn&#39;t have to be inconvenient. </p><p><code>%clay</code> has no concept of a mutable name or a magic <code>HEAD</code>. Use the current date. If you&#39;re referring to remote data and you&#39;re worried about clock skew, subtract a second or three, or be prepared to block. (Or keep your clock unskewed, which shouldn&#39;t be <i>that</i> hard.) It&#39;s not like mutable-name schemes work any better than this anyway. </p><p>(Immutability is central to <code>%clay</code>. <code>git</code> merely adopted the reflog. <code>%clay</code> was born in it, molded by it...) </p><p><code>%clay</code> is objective; each Urbit node hosts only one ship, but treats domestic and foreign data (almost) the same way. If you ask your <code>%clay</code> repository for someone else&#39;s data, it will block the request until it gets the data, which it then caches. At present, we always fulfill requests from the origin ship, though in future we could certainly use it as a tracker. </p><p>If <code>%clay</code> discards cached data, it keeps a hash, so that your urbit can&#39;t violate the local illusion of immutability. We can&#39;t, of course, prevent anyone else&#39;s ship from sending conflicting claims in different directions. But we can prevent programs on our own ship from hearing about them, meaning that we retain local referential transparency. </p><h3 id="local-structure--dome--arch--leaf-and-mark-">Local structure: dome, arch, leaf and mark </h3><p>A <code>%clay</code> snapshot is called a <code>++dome</code>. A dome is the <code>%clay</code> equivalent of a tree-structured filesystem. </p><p>Each node in this tree is one uniform structure, an <code>++arch</code>, which is both file and directory. A <code>++leaf</code> or data value in this arch is a typed document. </p><p>A logical document type is called a <code>++mark</code>. A mark is a symbolic pointer to a Hoon source file, in the same dome, for an engine that can validate, compare, and/or convert documents of that mark. </p><p>Let&#39;s go over arches and marks a little more closely... </p><h4 id="an-arch-is-a-uniform-filesystem-node-">An arch is a uniform filesystem node </h4><p>Most filesystems and RCS have modal nodes. For instance, a git data node can be a blob or a tree. <code>%clay</code> (and the Urbit namespace in general) has one kind of node, an <code>arch</code>: </p><pre>  ++  arch  (pair (unit leaf) (map knot arch))
  ++  leaf  (pair mark noun)
</pre><p>An arch has an optional typed-data leaf, and optional named children. In Unix terms, it&#39;s a file, a directory, or both. It can&#39;t be neither: an empty arch, with no data and no children, is auto-pruned. As in <code>git</code> (but not in Unix), the hierarchy is a pure function of its leaves. Paths exist only because of the data they point to. </p><p>The <code>++knot</code> names in an arch path are also a little special. They&#39;re typed, in a sense; any knot can be parsed invertibly into a typed atom. The atom is an arbitrary unsigned integer. Its type (an <code>++aura</code> if you know Hoon) defines the semantics and presentation of the atom: for instance, a symbol, a decimal, a date, etc. </p><p>Ultimately a filesystem is a database, and a path is a primary key. It&#39;s very useful to be able to store simple data in this key, in a standard and unambiguous way. </p><p>Why uniform nodes? One, they map nicely to information trees where a subtree may need some custom collective presentation, not an automatically generated Apache style directory listing. Two, non-uniform nodes introduce a whole pointless category of node type conflicts -- for which life is far too short. </p><h4 id="a-mark-is-an-executable-document-type-">A mark is an executable document type </h4><p>A mark is “like an executable MIME type.” It&#39;s best defined as a symbolic mapping from a filesystem to a schema engine. </p><p>If you have a MIME type <code>text/html</code>, you need to watch the Internets to track what the W3C thinks HTML is. If you have an Urbit mark <code>%html</code>, you can functionally construct (using our insanely powerful functional build vane <code>%ford</code>) a core which can validate or normalize HTML, apply patch and diff logic, and translate to and from other marks. <code>%ford</code> can even reason about translation paths and construct multistep conversions. </p><p>(Urbit does not actually have this super-smart <code>%html</code> mark right now. But it probably should, huh. And this page was composed in Markdown and translated to HTML by <code>%ford</code>.) </p><p>Where does the source code of a mark live? Within the same dome as the data it describes. <code>%html</code> files are described by the Hoon source at <code>/===/mar/html</code>, which perhaps gets mapped into your Unix filesystem at <code>$ship/home/mar/html.hoon</code>. </p><p>This Hoon file is not self-contained. It has dependencies. The <code>%html</code> mark may depend on various structures and libraries elsewhere in Urbit. But the source code for all them is within this dome. </p><p>One constraint this puts on domes is that <i>all domes are descendants of the base system dome</i>. Domes are versions of one reality, not fragments of that reality. You can&#39;t create a new empty dome -- you&#39;d have no mark source, and be unable to install any validated files. </p><p>Enforcing the rule that all domes are congruent (if only in that they all contain the base system files) costs us nothing in the implementation, does not inconvenience the user, and ensures that weird collisions between non-parallel things don&#39;t happen. </p><h3 id="unix-mapping-and-mounting-">Unix mapping and mounting </h3><p>Every DVCS is its own filesystem in a sense. But every DVCS works by mapping and mounting itself, in some sense, to Unix. </p><h4 id="mapping-arches-to-unix-">Mapping arches to Unix </h4><p>How do we map arches into Unix? The arch structure maps 1:1 to the Unix directory tree. When the arch has a leaf, we derive a dot extension from the file&#39;s mark. </p><p>So, supposing we have a leaf <code>foo</code> which is an HTML document (mark <code>%html</code>), with two children <code>bar</code> and <code>moo</code>, also HTML documents, in Unix we&#39;ll see: </p><pre>foo.html
foo/bar.html
foo/moo.html
</pre><p>This maps invertibly back into <code>%clay</code>, and it looks perfectly unremarkable from the Unix side. File completion sometimes gets a little annoying. </p><p>It would be if nice every possible Unix tree, even every plausible Unix tree, mapped cleanly and completely to a <code>%clay</code> dome. There are always horrid exceptions, even in common use -- like extensionless Makefiles. The trivial solution is that if <code>%clay</code> finds a file mysterious, it won&#39;t track it. </p><p>One often unquestioned assumption in new system software is that compatibility with old content is important. It&#39;s nice, but not that important. Most content in a new system is new content. The important compatibility direction is export, not import. So the new system should subset, not superset, the ancient formats. </p><h3 id="mounting-desks-to-unix-">Mounting desks to Unix </h3><p>If a <code>%clay</code> desk is <i>mounted</i>, it has a two-way live sync to the Unix directory of the same name within the pier. </p><p>When files in a mount directory change, <code>%clay</code> notices it through <code>libuv</code> filesystem watching (ultimately <code>inotify()</code> or <code>FSEvents</code>), computes diffs, and automatically commits them to the desk. And if <code>%clay</code> creates a new version for its own urbity reasons, it will revise the Unix files. </p><p>Keeping all mounted files in the same Unix subdirectory makes it easy to move the whole pier in a tarfile. Edits applied while the <code>urbit</code> process isn&#39;t running will be detected and applied the next time it starts. </p><p>In conventional DVCS terms, <code>%clay</code> has a 1:1 static mapping from branches to working directories. Why? </p><p>Why not? Do we need that “what branches are checked out in what directories” piece of state? Why force the user to worry about which branches are mounted to which directories? Why not just mount them under their own names? Is there some crippling global shortage of disk space for source files? Our planet is running out of inodes? Wut? </p><h3 id="queries--subscriptions-and-synchronization-">Queries, subscriptions and synchronization </h3><p>There are two ways to get data out of <code>%clay</code>: dereference the Urbit namespace, or send a request/subscription. Sync is in userspace. </p><h4 id="dereferencing-the-namespace-">Dereferencing the namespace </h4><p><code>%clay</code> is just part of the full Urbit namespace. The full namespace has a two-character prefix which expresses what vane to query (always <code>%c</code> for <code>%clay</code>). The suffix is a mode flag; <code>%x</code> for data, <code>%y</code> for a list of children, <code>%z</code> for the whole arch subtree, <code>%w</code> for the version number. (Each vane has its own modes.) </p><p>For example, the full path to my cat picture is </p><pre>/cx/~sorreg-namtyv/home/[now]/my/cat/picture
</pre><p>(where <code>now</code> is the current date). </p><p>If the data model is <code>++image</code> (hypothetical -- we don&#39;t really do image processing in Urbit right now), the normal way to load this data in a Hoon program is </p><pre>.^(image /cx/~sorreg-namtyv/home/[now]/my/cat/picture)
</pre><p>This produces a statically typed value (which works by dynamically checking <code>image</code> against the actual type of the value, but this comparison caches well). </p><p>Internally, an Urbit namespace request produces a <code>++cage</code>, which has a mark, a <code>++span</code> (language-level type), and an actual noun. The product is doubly optional, <code>(unit (unit cage))</code>; this is <code>~</code> if we don&#39;t know the value of this name at present but might learn it in future, <code>[~ ~]</code> if we know we&#39;ll never know it, or <code>[~ ~ value]</code> if we know it now. </p><p>In high-level shell programming (<code>:dojo</code>), we can make apparently “blocking” requests to <code>%clay</code>. What actually happens: when <code>%clay</code> produces <code>~</code>, we stop trying to compute this expression and wait on one or more blocking requests. When we are unblocked, we recompute again from scratch; the intermediate computation is not saved at all. </p><p>Urbit doesn&#39;t like to block. It likes to save coherent data structures, not incomplete computation contexts. When Urbit pretends to block for you, this is a courtesy service. You can return the courtesy of not expecting miracles from it. When in doubt, send an actual request. </p><h3 id="requests-and-subscriptions-">Requests and subscriptions </h3><p>A true request (local or remote) has access to the same namespace, but can (a) read across case (revision) ranges, and (b) filter by subtree. </p><p>If the revision range in a request stretches into the future, the request becomes a subscription. Urbit messaging always regards a single response as a special case of a subscription. </p><p>Generally, the response stream created by a request starts with all the data the server has available right now; updates will follow when they become available; the subscription will be closed when the request range is complete. </p><h4 id="userspace-synchronization-">Userspace synchronization </h4><p>Synchronization per se is done in userspace. In <code>%clay</code>, sync just means an application (typically the <code>%kiln</code> module in the system app <code>:hood</code>) subscribes to a remote desk, and saves its change stream locally. So sync is really an emergent feature of <code>%clay</code>. </p><h3 id="revision-graph-">Revision graph </h3><p><code>%clay</code>&#39;s revision graph is completely uninteresting at present. Some changes are proposed below, however. </p><p>As in any DVCS, a dome is the child of one parent dome (an edit) or more parents (a merge). Often the parent of any revision is the previous version in the sequence, but it can be anything. </p><h3 id="storage-model-">Storage model </h3><p><code>%clay</code>&#39;s storage model is completely uninteresting. It&#39;s also a little funky and I want to change it, so I&#39;ll be super vague. </p><p>A <code>++lobe</code>, a 128-bit atom, is the Merkle hash of a <code>blob</code>, which is essentially a leaf. All blobs are stored in a hash table (<code>(map lobe blob)</code>), and reference each other through lobes. </p><p>At present we don&#39;t GC this space at all, because we don&#39;t actually delete any roots. </p><p>A <code>blob</code> may be <code>%direct</code>, meaning it&#39;s defined as the data itself, or <code>%delta</code>, defined as a change against another blob. This is motivated by the desire not to store a full snapshot on every file change. But it may be misguided (see changes <code>0</code> and <code>1</code> below). </p><p>We cache the full arch tree (<code>++ankh</code>) of the latest state in each desk. For current queries, this mitigates a lot of the opportunities for slowness that this data model creates. But the disparity between the speed of the current version and the speed previous version is an undesirable glitch in the API. </p><h2 id="our-motivation-for-change-">Our motivation for change </h2><p>We actually have <i>three</i> motivations for change... </p><h3 id="we-need-to-develop-on--clay-">We need to develop on <code>%clay</code> </h3><p>At present, we&#39;re still using <code>git</code> as a development platform. <code>%clay</code> is certainly used, but just for its strength -- deployment. This is starving Urbit of essential experience and basically keeping it lame. So, change is necessary. </p><h3 id="change-must-come-from-the-community-">Change must come from the community </h3><p>“Why?” you ask? “Why must change come from the community?” Well, one, duh. Change always comes from the community. </p><p>But two, a great force for change has departed. Philip Monk, late maintainer of <code>%clay</code> (<code>~wictuc-folrex</code> in the old era, <code>~wicdev-wisryt</code> in the new), is tired of types and typing. He spent September roaming with the bison in Montana, and is now literally on his way to Patagonia. On the one hand, Phil still exists and is not at all unwilling to answer questions, even dumb questions. On the other hand, <i>Patagonia</i>. </p><p>So <code>%clay</code> needs a new owner, or owners. At this point, we think the community might be indoctrinated enough to take a stab. </p><p>Alas, <code>%clay</code> already has a pretty checkered ownership history. Long ago I built a <code>%clay</code> that was really the only serious design failure in Arvo. Then Jared Hance, a brilliant summer intern, took my broken <code>%clay</code> and reformed it into a minimal <code>git</code> in about a week. Then Philip modified Jared&#39;s <code>%clay</code> to be a <i>typed</i> revision-control system, which is a pretty cool thing. </p><p>But... in none of these transitions did <code>%clay</code> actually get <i>rewritten</i> per se. While it&#39;s a reasonably good vane, it does contain one or two historical decisions. </p><p>We know a lot more about Arvo than we used to, and I think we can revisit many of these decisions. The point of this post is to start a <code>%clay</code> design discussion that will evolve into actual collective action. </p><h3 id="pioneers-may-find-it-worth-their-time-">Pioneers may find it worth their time </h3><p>We&#39;re planning a rewards program for contributions to <code>%clay</code>. It&#39;ll simply involve setting a time period and a pool of real estate, and allocating the pool by judged contribution. </p><p>This is an experimental program. We&#39;ll say more about it later. It may not even happen. It may happen very differently. When in doubt, don&#39;t talk about Fight Club. </p><h2 id="some-openings-for-change-">Some openings for change </h2><p>Change, of course, must come from the community. No one can dictate change from the top down. We <i>know</i> this. But... </p><p>This list of suggested changes for the next <code>%clay</code> is not in any sort of order: priority, structure, difficulty, etc. Let&#39;s talk about the changes first; make actual plans second. The numbers here are just for convenience. </p><p><b>All changes in this program will happen on the next-generation (<code>cc-release</code>) branch.</b> </p><h3 id="change--0--state-reform-">Change #0: state reform </h3><p>As mentioned above, the storage model in <code>%clay</code>, as the code is at present, feels a little funky to me. There&#39;s nothing terribly awful about it, but it doesn&#39;t feel quite right and its scaling properties are very questionable. </p><p>Briefly, <code>%clay</code> today actually derives the hierarchy from its leaves -- rather than <i>logically</i> so deriving it. Only leaves are in the object store. This is just weird, and you can feel <code>%clay</code> trying to be something other than what it is. (I blame Jared, though it&#39;s actually my fault.) </p><p>To store a dome snapshot (<code>++yaki</code>), the present code keeps a <code>(map path blob)</code> at the root of the dome. This is enough to reconstruct the <code>++arch</code> structures the namespace exports. However, all kinds of basic arch operations, like basically <code>ls</code>, become <code>O(n)</code> in the number of leaves in the dome. This is obviously not quite right. </p><p>I believe the storage structure should be (removing everything that isn&#39;t needed to serve the namespace): </p><pre>  ++  clay  (pair safe (map term desk))
  ++  desk  (pair numb (map numb root))
  ++  dome  (pair date root)
  ++  leaf  (pair mark noun)
  ++  lobe  @uvH              ::  128-bit base32
  ++  numb  @ud               ::  decimal version number
  ++  root  (pair (unit leaf) (map knot lobe))
  ++  safe  (map lobe root)
</pre><p>Here a <code>++root</code> is the universal node, with children addressed by hash, but logically representing the abstract <code>++arch</code>. </p><p>Users of hierarchical filesystems basically expect performance qualities that match the filesystem structure. A huge directory in one place shouldn&#39;t affect search speeds somewhere else. And of course, <code>ls</code> can&#39;t be O(n) in the size of the filesystem. </p><h3 id="change--1--store-edges--cache-snapshots-">Change #1: store edges, cache snapshots </h3><p>The current <code>%clay</code> is snapshot-oriented, like <code>git</code>. The actual changes are discarded. I think this is a bad choice. </p><p><code>%clay</code> is not a research project, and has no idea of going as far as <code>darcs</code> in the “set-of-patches” direction. However, at present we actually throw away the patch (<code>++nori</code>). </p><p>I think the right DVCS design for <code>%clay</code> is a snapshot-oriented system which also keeps the patches. The revision graph has the same general shape as in the old <code>git</code> style. But rather than just deriving the diffs from the snapshots, we can also derive the snapshots from the diffs. When in doubt, we save space by dropping the snapshot, not the diff. </p><p>For an RCS which is also a general-purpose typed filesystem, it&#39;s clear that considering edges (deltas, diffs, changes, etc) as the primary state is optimal. You can use diff functions to derive deltas from snapshots, but in many data models this will always risk losing information from the original action. When in doubt, save what the user did. </p><p>This is even more true for operations on the tree structure, not on individual leaves. Consider the heuristic energy that <code>git</code> has to go through to figure out when <code>mv</code> has been used -- even when <code>git mv</code> has been used! (According to the <code>git</code> faq, this is because the lowest common denominator remains Linus&#39; style of working with emailed patches.) </p><p>Edges probably don&#39;t even need to be deduplicated. They also can contain metadata such as commit messages (which <code>%clay</code> has no place for at present). </p><p>Once edges are recognized as unreclaimed primary state, snapshots can always be derived from the edges. So we can reclaim memory being used for snapshots. </p><p>It&#39;s also straightforward to have a kind of edge which is a list of edges, letting us collapse feature branches trivially. </p><p>Finally, I think references in edges should wherever possible indirect through the namespace, rather than directly to the content address. The user has strictly more information if you say you merged <code>/~sorreg-namtyv/base/987/</code>, than if all you have is the hash that this reference refers to. </p><h3 id="change--2--unconfuse-merge-and-rebase-">Change #2: unconfuse merge and rebase </h3><p>The dispute between merge and rebase has all the bad smells of a historical wart. But here I&#39;m just not sure what&#39;s right. </p><p>The user has one <i>intent</i> whether merging or rebasing, which is to combine changes on one desk into another. The <i>algorithm</i> used to construct this change, whether operational transformation (rebasing) or a 3-way diff (merging) has one goal: use all available information to model the authors&#39; editing intent as realistically as possible. If we save edges, we should use edges. </p><p>Whether to define the resulting change graph with the typical structure of a merge, or the typical structure of a rebase, strikes me as quite arbitrary, and well into the land of “pick one and force everyone to stick with it.” But this call demands a real expert on RCS workflow, which I&#39;m not. </p><p>Since <code>%clay</code> is a humble part of a larger system and needs to keep its weight down, “do it both ways because people have different preferences” is not usually the right answer. </p><h3 id="change--3--comment-jihad-">Change #3: comment jihad </h3><p><code>%clay</code> needs to be brought up to the documentation standards of <code>%jael</code>. This means (a) the formatting matches; (b) the comments are at the same level of quality and ubiquity. </p><p>The basic commenting standards are: (a) every core (class) needs a block comment explanation; (b) every gate (function) needs a line comment; (c) every face (variable) needs a line comment. </p><p>This is obviously not just a clerical task. To write these comments, you need to actually understand the code. This is a nontrivial but extremely rewarding task, even if the code you&#39;re commenting will get replaced. </p><p>Also, the <i>symbols</i> in <code>%clay</code> must be brought up to <code>%jael</code> quality. There is still far too much four-letterism here. </p><p>NB: <code>%clay</code> is about 3000 lines of pretty clean Hoon, which is certainly not at all undocumented. We&#39;re not exactly looking at a Matterhorn of reverse engineering here. </p><h3 id="change--4--knot-to-coin-internal-paths-">Change #4: knot to coin internal paths </h3><p>One feature of Urbit paths, briefly mentioned above, is that a path segment or <code>++knot</code> (which is just a <code>@tas</code> text string, an ASCII symbol as an atom) must be within the range of the invertible noun printer, <code>++co</code>. </p><p><code>++co</code> maps a described data value, a <code>++coin</code>, to an ASCII string which is a valid URL segment and Unix filename. Its friend <code>++so</code> inverts the function, perfectly. </p><p>Almost every knot is the simplest kind of <code>coin</code>, a <code>dime.</code> A dime is a single atom with a rendering type (<code>aura</code> if you know Hoon). Auras include <code>@tas</code> for symbolic text, <code>@ud</code> for unsigned decimal, <code>@p</code> for Urbit ship, etc. <code>++co</code> can also print arbitrary cells, though less prettily. </p><p>This feature is cool because it lets us stuff data into names in a precise and predictable way. Usually the names in a namespace are human-meaningful and human-originated, and are therefore symbolic, but there are exceptions. For example, blogposts may want to be named by date. </p><p>However, it is slightly retarded for the fundamental state of our arches to store the <i>rendered</i> string (<code>++knot</code>), not the source data (<code>++coin</code>). It leads to all kinds of inefficiencies where we&#39;re doing way more parsing than we want to. (Parsing also should be jet-propelled, but is not.) It also makes it way too easy to sneak in bad data and make it <code>%clay</code>&#39;s problem. </p><p>So, logically, we&#39;d be shifting from </p><pre>  ++  arch  (pair (unit (pair mark noun)) (map knot arch))
</pre><pre>  ++  arch  (pair (unit (pair mark noun)) (map coin arch))
</pre><p>Also, a vanilla <code>++map</code> might not be quite the right data structure at this point -- we probably want a custom sorted tree, which separates auras and imposes a custom order on each. This would let us serve simple range queries quite efficiently, so long as they match the standard aura order (eg, alphabetical order for symbols). </p><h3 id="change--5--dome-semantics-by-reference-">Change #5: dome semantics by reference </h3><p>While the principle that a dome contains its own mark source is elegant, it&#39;s a pain in the ass to implement properly. <code>%clay</code> certainly does not do it justice at present. </p><p>The complexity is in checking every change to see whether it includes a change to the mark source (which is very unlikely), or a dependency of the mark source (slightly less unlikely). And if so, do we have to update all the leaves in the dome? This is also very unlikely. And yet, it happens. </p><p>Instead, we could simply designate, by beak (ship, desk, and case) a dome which contains the canonical mark source. This would rarely change -- you could upgrade a desk to a new mark dome, but it would be a manual operation and probably a rare one. </p><p>The common case would just be that everyone uses the current version of the <code>%base</code> desk when a desk is created, and never changes it. In practice, this means not every two-byte edit needs to get involved in detecting and/or applying schema evolution, a welcome simplification. </p><h3 id="change--6--mark-containers-">Change #6: mark containers </h3><p>Marks in present <code>%clay</code> are atomic and symbolic (like <code>%html</code>). Since they&#39;re also used for network protocols, and the proper design is one mark per message structure, the mark namespace gets overloaded fast. </p><p>So we added an app hierarchy within the mark namespace, using hep <code>-</code> as a divider. The <code>:talk</code> app expects messages with the mark <code>talk-message</code>, whose sources is in <code>/===/mar/talk/message</code>. </p><p>This helps, but it doesn&#39;t solve another two problems: trivial nouns and containers. </p><p>It&#39;s retarded to have to add a source file to send a <code>@ud</code> or a <code>*</code>. An aura (see above under <code>coin</code>) should be a trivial mark. </p><p>Also, we need to be able to construct standard containers of marks: lists, maps, sets, and tuples (or, as a database person would say, “rows”). </p><h3 id="change--7--meta-marks-">Change #7: meta-marks </h3><p>Another kind of complex mark that needs to exist: conflict, difference, and invalid marks. </p><p>Conflict data and difference data are two types of noun that are generated in normal RCS operation. If we have the concept of an <code>%html</code> noun, we also need the concept of an invertible change from one <code>%html</code> file to another; a merge conflict between two <code>%html</code> files; and even a conflict between two marks. </p><p>There are two kinds of changes to a dome: manual and automatic. Manual changes are initiated by the user and should crash, unless manually overridden. Automatic changes should not crash, ever, and should not lose data. If they create problems, which they shouldn&#39;t, these problems will need to be cleaned up manually. </p><p>This is a complex space to navigate, but it requires a conflicted merge to be able to resolve to a valid dome containing conflict leaves, not crash. The present <code>%clay</code> goes halfway there and resolves to a scratch desk, but we can go farther: the whole <code>git</code> dumpster-fire of “merge state” deserves destruction. One change is a merge that produces conflicts, the next is an edit that resolves them. </p><p>Similarly, all sorts of errors can produce invalid leaves. One particularly rare case which is nonetheless important is schema evolution: what happens to files in a mark, when the mark source code changes. They all need to be re-normalized. And this operation can fail, producing an invalid value. (We don&#39;t do any of this now, BTW, although <code>%ford</code> has the dependency mechanism to make it possible.) Again, in some cases this should crash the update to the mark source; in other cases, there is no local way to handle the crash. </p><p>So there must be a way to preserve invalid nouns that can be repaired by repair tools that expect invalid content, while not actually marking them as valid so that innocent code is deluded into using the bad content. </p><p>The bottom line: a mark needs to be split into two models: <code>++mark</code>, the original symbolic mark with its source engine, and something like <code>++logo</code>, the meta-mark or mark container. The mark is the building block; the logo is the building. </p><h3 id="change--8--filesystem-hierarchy-standard-">Change #8: filesystem hierarchy standard </h3><p>While all filesystems remain forks of one ur-filesystem, the standard tends to enforce itself. But not define itself. </p><p>I&#39;ve always hated the current <code>/mar</code> for marks, for instance. I prefer <code>/mac</code>. But others hate this. And so on. Also, by necessity, our nascent “FHS” is heavily biased toward system data, away from user data. This is retarded. </p><p>Please focus all bikeshedding energy on this problem! Better to bikeshed about what color to paint the bikeshed, then what shape the bike gears should be. </p><h3 id="change--9--security-and-access-control-">Change #9: security and access control </h3><p>Oh, yeah, that! They always say not to design security in at the last minute. Unfortunately, this is exactly what we did. There is no security at all in present <code>%clay</code>. (There is also no push operation in <code>%clay</code>, so it&#39;s not as mad as you think -- anyone can read anything, no one can write anything, which is fine in a young network where there are no secrets.) </p><p>Fortunately, we don&#39;t have anything super fancy planned in this area, just basic access-control lists. These obviously need to be designed along with the filesystem-hierarchy standard (see elsewhere). </p><p>Is it even possible to do ACLs properly in <code>%clay</code>? At this point, yes. There is an event-oriented security model in Arvo, though it isn&#39;t really hooked up to anything at the moment. There is also a privilege badge system in <code>%jael</code>. The combination of these two features is quite sufficient for a decent ACL model. </p><p>The idea of event-based security is that every event passed to <code>%clay</code> has a security <code>++mask</code>. The mask tells us: </p><ul><li><p>the set of ships that has <i>contaminated</i> this event </p></li><li><p>the set of ships that has <i>endorsed</i> this event </p></li><li><p>the set of ships that this event may be <i>released</i> to. </p></li></ul><p>To simplify this system a little and maybe explain it, the security question in any event is: (a) who has <i>caused</i> this event? (b) who may receive its <i>effects</i>? (These sets never include your urbit itself, of course, only neighbors.) </p><p>For example, if we&#39;re doing something because ship X sent us a packet, and we&#39;re going to leak the results of this something back in a response to ship X, once <code>%clay</code> knows what our ship thinks of its neighbor X, we should have a good picture of what effects this event should be allowed to cause. If <code>%jael</code> knows that X is our friend, <code>%clay</code> can know that X can see our cat picture. </p><p>Causality is separated out into contamination (data from ship X got into the event) and endorsement (ship X signed the whole event). (This may be overdesign.) All these sets can be defined as the empty set (eg, releasing to the empty set means no output) or the universal set (input from the universal set could be from anyone, ie, is unauthenticated). </p><h3 id="change--10--stop-using-mark-extended-paths-">Change #10: stop using mark-extended paths </h3><p>When you read a leaf from a <code>%clay</code> dome, <code>%clay</code> is happy to perform any necessary mark conversions (the actual work is done by the <code>%ford</code> build vane). You can also just ask for the leaf in whatever mark <code>%clay</code> has it. </p><p>It&#39;s confusing to think of this mark extension as part of the path. You shouldn&#39;t say <code>+cat /===/app/talk/hoon</code>. You should say <code>+cat /===/app/talk</code>, or maybe <code>+cat %hoon /===/app/talk</code>. </p><p>A mark-extended namespace may be added to <code>%ford</code>, to compensate. But type-converting reads are the rare case, not the common case. </p><h3 id="change--11--real-queries-and-indexes-">Change #11: real queries and indexes </h3><p>A filesystem should postpone being a database until it can no longer do so. So, please don&#39;t think about this problem yet. I&#39;m joking, of course! </p><h3 id="change--12--meta-query-">Change #12: meta-query </h3><p>Make it possible to query the list of desks in a ship :-) </p><h3 id="change--13--completely-redesign-unix-mounting-">Change #13: completely redesign Unix mounting </h3><p>This is actually a series of changes, described below. But broadly... </p><p>One of Urbit&#39;s experiments is live two-way synchronization between the Unix filesystem and the revision-control store. Dropbox style, as it were. I think this experiment is basically a failure. It may be right for cat pictures, but I don&#39;t think it&#39;s right for Urbit. </p><p>The fundamental problem is that there are all sorts of weird, flaky ways applications use a mutable filesystem. It&#39;s not at all unusual for an editor to change a file by deleting the old file, then writing the new one in its place. </p><p>You really don&#39;t want this to produce a delete change. A simple cooldown timer for the sync helps a lot with this, but causes other weirdnesses. In theory, a sync can even cause another change to the same version of the same desk. And so on. </p><p>The thing we fear is just too funky to work (there is some strange “reflux bug” still affecting it) is any sort of <i>two-way</i> synchronization between Unix and Urbit. </p><p>And what I think puts this feature into the deadpool, or at least cold storage, is that there&#39;s no useful workflow that actually uses it -- at least, when editing Urbit code. </p><p>It&#39;s actually really nice to have files on a disk that nothing will automatically modify. If you&#39;re using <code>git</code> and <code>%clay</code> in parallel, it&#39;s nice to mount your <code>git</code> working directory. The original Urbit workflow was to work out of a mounted directory, but the two-way updates were just too weird and scary, so now we tend to edit elsewhere and copy in -- which is lame. </p><h3 id="change--14--figure-out-what-to-do-with-fuse-">Change #14: figure out what to do with FUSE </h3><p>We actually have two forms of filesystem access to <code>%clay</code>: read-only FUSE (in a somewhat experimental state), and filesystem watching (using <code>inotify()</code> and <code>FSEvents</code> under a <code>libuv</code> wrapper). </p><p>The FUSE interface is a good one, though it needs more work. Moreover, it exports the whole Urbit namespace to Unix, not just <code>%clay</code>. For reading Urbit data, FUSE is basically ideal. </p><p>The obvious impulse is to make a read-write FUSE. But I don&#39;t think FUSE should be used for recording changes to an RCS, even though the FUSE API sends you changes as events. </p><p>There are three reasons for this. One, the actual filesystem writes that Unix apps make are typically of low quality and confusing. Some crack-brained editor will find it completely normal and unremarkable to modify a byte in a file, by deleting the file and rewriting it from scratch. You can use a cooldown timer to wait for this nonsense to converge, but leaving data in heuristic limbo seems like a very bad idea in FUSE-land. </p><p>The second is that people derive a lot of comfort from seeing actual files on an actual disk. The idea that your datas are stuck in Urbit is slightly terrifying as a user experience. We claim to be reliable. It&#39;s actually hard to imagine datas that couldn&#39;t be recovered from either snapshot or log. But how can you possibly believe us on this? </p><p>So I think it&#39;s correct to lean all the weight of reading data from Urbit on FUSE, and use filesystem watching for writing. Heuristic timeouts are fine in filesystem watching, because at least the data got written when the disk says it got written. And at least it&#39;s on the disk. </p><p>Also, FUSE is a daemon by definition, which forces us to think a little harder about how to run the Urbit process as a daemon. But this is a separate discussion. </p><h3 id="change--15--one-way--nonced-working-desk-">Change #15: one-way, nonced working desk </h3><p>A one-way mount is a much less crazy thing. It works the same way our two-way mount works today, but with only one writer: the user, via Unix. </p><p>Since a mount is one-way, it needs to have an absolute write lock on the desk it&#39;s writing to. We cannot have a <code>%home</code> desk which we are also editing with filesystem watching. </p><p>Instead, we have a temporary and anonymous state that&#39;s connected itself with your <code>%home</code> desk. Desk names have to be valid symbols, but we can use <code>hep</code>, <code>-</code>. A reasonable choice is to pick a random 32-bit name for each mount instance -- so the desk name is not <code>%home</code>, but <code>%home-bosdut-sigder</code>. (Randomizing instead of always using a fixed suffix, say, <code>%home-work</code>, just makes all kinds of screwups less likely.) </p><p>You create a mount simply by mkdiring the desk name in your pier. Just the base name, Urbit will come up with the <code>%bosdut-sigder</code> part and put it in a <code>.desk</code> file at the desk root. To forget the mount, just delete this file. This avoids the ugly confusion between unmounting a mount, and deleting all the data in it. </p><p>(Urbit will keep a set of the mount desks it&#39;s used and forgotten, not reuse them, and block all requests into them. By blocking, we can delete without losing referential transparency. Yes, Virginia, Urbit can forget!) </p><p>Note that the auto-reload behavior of applications is extremely useful when testing. When testing, you can either switch the active application desk from <code>%home</code> to <code>%home-bosdut-sigder</code>, or activate autosync from the latter to the former. </p><h3 id="change--16--commands-as-metafiles-">Change #16: commands as metafiles </h3><p>A new idea I&#39;d like to play with is that, since the basic model of the mount process is to read Unix files and suck their contents into Urbit, you should be able to control a mounted <code>%clay</code> desk through Unix filesystem operations alone. </p><p>No Urbit command-line access, not even any <code>urb/</code> HTTP control channels, should be required for the user to generate <code>%clay</code> data through filesystem mount, or to set up the mount. </p><p>An RCS experience that works entirely through Unix tools, in which the only connection between content creation tools and revision-control tools is shared access to the filesystem itself, is essential if your RCS has something so repulsive as a daemon. Otherwise, you&#39;re basically, like, reinventing Perforce. </p><p>More concretely, the Urbit experience today requires <code>:hood</code> pokes (Urbit shell commands, basically) for all nontrivial RCS operations, from mounting to merging. Again, there are lots of situations in which you can write into a mounted filesystem (the protocol for Unix communication could be easily adapted to communicate with a browser-based editor, for instance), but you don&#39;t want the user to have to bother with an Urbit shell. </p><p>Even commands like mounting and merging are easily communicated, through filesystem writes that any Unix tool (including many macro editors). </p><p>This is very easy for a filesystem watcher. One such protocol: if you want to send the daemon a command relative to some directory, write a <code>.ur-command</code> metafile in that directory. The daemon accepts the command by deleting it. </p><p>The user experience is that you configure your mounts by simply making the directories and configuring dotfiles in them. Unlike in the present system, Urbit will never modify your datas silently in the background. </p><p>Here&#39;s what this looks like: </p><p>Suppose you want to edit some data in the <code>%home</code> desk. Your data is in <code>/=home=/mar/talk</code>. You also want a read-only view of <code>/=home=/arvo</code>. </p><p>From Unix, you do something like this: </p><pre>  $ cd $pier
  $ mkdir -p home/mar/talk
  $ touch home/mar/talk/.edit
  $ mkdir home/arvo
  $ touch home/arvo/.read
</pre><p>Want to commit your changes? That means merging the working desk, <code>%home-bosdut-sigder</code>, into the <code>%home</code>. Put a commit message into <code>home/.commit</code> and it&#39;ll happen. If there&#39;s an error, it will appear as <code>.error</code>. </p><p>The mount has a .version file which simply contains the change number (of the working desk) which any edits are relative to. If the urbit daemon is running and watching, edits will be absorbed quickly (probably after a heuristic timeout), and the version incremented. But we always are confident that the edits are against the latest version, or at least we can use this as a sanity check. All kinds of insane things can happen to get a filesystem out of consistency. </p><p>This design obviously needs a little fleshing out, but I&#39;m quite confident it&#39;s a convenient and reliable way to drive <code>%clay</code> from Unix. </p><h2 id="in-conclusion-">In conclusion </h2><p>There&#39;s obviously a lot of fun here! There are two things you can do right now. </p><p>One, talk about <code>%clay</code> on <a href="http://urbit.org/~~/fora/posts/~2016.10.25..17.37.47..6937~/">this forum thread</a> or on <a href="http://urbit.org/stream">:talk</a>. Both hosted on Urbit itself! </p><p>Two, poke around the <a href="https://github.com/urbit/arvo/blob/cc-release/arvo/clay.hoon">code</a>. Make sure you&#39;re on the development branch (<code>cc-release</code>). </p><p>Phasing in this work will be a fun and interesting challenge. (My suspicion is that the right first task is the Unix mount.) Let&#39;s talk... </p></div></div></div></div></div><footer class="container mb-36"><div class="row"><div class="col-sm-8 col-sm-offset-3 col-lg-4 col-md-offset-2"><div id="mc_embed_signup"><h2 class="mb-2">Updates</h2><p>Every month we send an email with community events and what we&#39;re up to. </p><iframe name="nothing" style="display:none;"></iframe><form id="mc-embedded-subscribe-form" class="validate" action="https://urbit.us11.list-manage.com/subscribe/post?u=972a03db9e0c6c25bb58de8c8&amp;amp;id=be143888d2" method="post" name="mc-embedded-subscribe-form" target="nothing"><div class="input-group text-mono" id="mc_embed_signup_scroll"><div class="mc-field-group"><input class="required mb-2" type="email" name="EMAIL" id="mce-EMAIL" placeholder="your@email.com"></input></div><div id="mce-responses" class="clear"><div id="mce-error-response" class="response" style="display:none"></div><div id="mce-success-response" class="response" style="display:none"></div></div><div style="position: absolute; left: -5000px;"><input type="text" name="b_972a03db9e0c6c25bb58de8c8_be143888d2"></input></div><div class="clear"><button id="mc-embedded-subscribe" class="bg-black white h-font" type="submit" name="subscribe"><span class="text-500">Subscribe</span></button></div></div></form></div></div></div><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>