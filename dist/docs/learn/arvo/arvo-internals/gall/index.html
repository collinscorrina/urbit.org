<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Docs</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div id="sidebar-mobile" class="bg-gray-light sidebar-hide overflow-y"><div class="container"><div class="col-sm-10"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div><div class="col-sm-1 sidebar-toggle fixed" style="top: 20px; right: 1em"><img class="w-8 h-8 dropdown-right" src="/assets/dropdown.svg" /></div></div></div><div class="container mt-10"><div class="sidebar-container row col-sm-3 fixed pb-30 h-100-md"><div class="col-sm-3 col-lg-6 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-12 mt-7 sidebar-toggle md-hide"><img class="w-8 h-8 dropdown-left" src="/assets/dropdown.svg" /></div><div class="h-100 col-sm-8 col-md-11 overflow-y sm-hide"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-2 col-md-offset-3 docs"><div><div><h1 id="gall-apps-">Gall Apps </h1><p>This is documentation about how to write Gall apps. Some knowledge of Hoon is assumed. </p><blockquote><p>Note: the last major revision of these lessons was in 2016. They need to be rewritten; in some ways they are outdated, and in other ways they were not always accessible enough to beginners. We are planning to rewrite these in the near future. There is still useful information to be found in the meantime. </p></blockquote><h2><div id="api">API Connectors</div></h2><blockquote><p>Note: This lesson depends on some code that needs to be updated before the examples will work correctly. This will be addressed in the near future. We apologize! </p></blockquote><p>Most people have lots of data stored in online services, many of which have APIs. API connectors allow the user to access this data from within their Urbit. </p><p>A security driver allows the user to make authenticated requests to the service&#39;s API, but the user still needs to know the API and send and receive JSON. An API connector puts a layer of porcelain over this to allow the user easier control over their data. </p><p>Each connector should perform two basic functions. First, it should expose a tree of the data in the service that&#39;s accessible through <code>.^</code> and FUSE. Second, it should expose event streams as actions occur in the service. Let&#39;s take a look at how the <code>%gh</code> app accomplishes both for Github. </p><p>After starting <code>%gh</code> (<code>|start %gh</code>), let&#39;s look at the root of the tree that <code>%gh</code> exposes: </p><pre>~your-urbit:dojo&gt; .^(arch %gy /=gh=)
[fil=~ dir={[p=~.issues q=~]}]
</pre><p><code>%gh</code> is currently a skeleton -- it contains examples of all the functionality necessary for a connector, but many endpoints aren&#39;t implemented. As we can see here, only issues are implemented. We can explore this tree: </p><pre>~your-urbit:dojo&gt; .^(arch %gy /=gh=/issues)
[fil=~ dir={[p=~.by-repo q=~] [p=~.mine q=~]}]
</pre><p>And eventually: </p><pre>/-  gh
.^(issue:gh %gx /=gh=/issues/by-repo/philipcmonktest/testing/7)
&lt;issue...&gt;
login.user:.^(issue:gh %gx /=gh=/issues/by-repo/philipcmonktest/testing/7)
&#39;philipcmonktest&#39;
</pre><p>The other thing an API connector needs to do is expose event streams. One straightforward way to use this capacity is with the <code>:pipe</code> app: </p><pre>:pipe|connect %gh /listen/philipcmonktest/testing/issues/&#39;issue_comment&#39; %public
</pre><p>Now creating an issue results in the following message in your <code>%public</code> <code>:talk</code> channel: </p><pre>~your-urbit[philipcmonktest@github]: opened issue ##11: i found a bug!
</pre><p>You&#39;ll also get notifications of issue status changes and comments. </p><p>As is often the case, the best way to write an API connector is to copy an existing one and modify it. We&#39;ll dissect the Github connector here. This code is in <code>/=home=/app/gh/hoon</code>, and it&#39;s also reproduced at the bottom of this page (in case the code drifts out of sync with this doc). </p><p>We&#39;ll go over the two parts to an API connector (one-time reading vs listening for events) separately. </p><h4 id="reading-">Reading </h4><p>A connector exposes a tree of data. Every read request has a <code>care</code>, which is generally either <code>%x</code> or <code>%y. </code>%x<code> is a request for a particular piece of data, while </code>%y<code> is a request for a directory listing. Roughly, </code>%x<code> means Unix </code>cat<code> and </code>%y<code> means Unix </code>ls`. </p><blockquote><p>Sometimes you wish to expose a tree where a part of the path can&#39;t be enumerated. For example, a <code>%y</code> of <code>/issues/by-repo</code> “should” produce a list of all Github users, but we don&#39;t do that because it&#39;s too long. Instead, we just produce our own username (from the <code>web.plan</code> file). You can still access repos from other users, you just don&#39;t see them in the directory listing. </p></blockquote><p>The usual flow for implementing this tree of data makes heavy use of the <code>connector</code> library. This library is well documented in the source, so check out <code>/=home=/lib/connector/hoon</code>. </p><p>The <code>connector</code> library needs to be initialized with definitions of <code>move</code> and <code>sub-result</code> (all the types of data that can be returned by a place). This can just be a line at the top of the main core: </p><pre>=+  connector=(connector move sub-result)  ::  Set up connector library
</pre><p>Most of the Github-specific logic is in <code>++places</code>, which is a list of all the places we can request. A place consists of: </p><pre>++  place
  $:  guard/mold
      read-x/$-(path move)
      read-y/$-(path move)
      sigh-x/$-(jon/json (unit sub-result))
      sigh-y/$-(jon/json (unit arch))
  ==
</pre><ul><li><p><code>guard</code>, the type of the paths we should match. For example, to match <code>/issues/&lt;user&gt;/&lt;repo&gt;</code> use <code>{$issues @t @t $~}</code>. </p></li><li><p><code>read-x</code>, called when someone tries to read the place with <code>care</code> <code>%x</code>. Should produce a single move, usually either a <code>%diff</code> response if we can immediately answer or a <code>%hiss</code> http request if we need to make a request to the api. See the <code>++read-*</code> functions in <code>++helpers</code> for some common handlers. </p></li><li><p><code>read-y</code>, same as <code>read-x</code> except with care <code>%y</code>. </p></li><li><p><code>sigh-x</code>, called when an http response comes back on this place. You&#39;re given the json of the result, and you should produce either a result or null. Null represents an error. If you didn&#39;t create an http request in <code>read-x</code>, then this should never be called. Use <code>++sigh-strange</code> from <code>++helpers</code> to unconditionally signal an error. </p></li><li><p><code>sigh-y</code>, same as <code>sigh-x</code> except with care <code>%y</code>. Note that a <code>%y</code> request must produce an arch, unlike a <code>%x</code> request, which may produce data of any mark. </p></li></ul><p>Filling out the list of places is a lot of grunt work, but most places are fairly straightforward, and the <code>++read-*</code> helper functions are useful. Check out the library source for more information on those. </p><p>Besides the list of places, we just need to handle the flow of control. <code>++peek</code> and <code>++peer-scry</code> are the interface we expose to the rest of the system while <code>++sigh-httr</code> and <code>++sigh-tang</code> are used to handle responses when we make HTTP requests. </p><ul><li><p><code>++peek</code> should usually just produce <code>~</code>. If there are cases where we can respond directly to a <code>.^</code> request without blocking on anything, we could do it here, but it&#39;s generally not worth the hassle since the same logic should be duplicated in <code>++peer-scry</code>. </p></li><li><p><code>++peer-scry</code> is where the actual handling for a read request goes. In general, we just need to call <code>++read</code> from the <code>connector</code> library with the bone, list of places, care, and path. This will match the path to the appropriate place and run either <code>++read-x</code> or <code>++read-y</code>, depending on the care. </p></li><li><p>If <code>++read-x</code> or <code>++read-y</code> made a successful API request, then the response will come back on <code>++sigh-httr</code>. Here, we just need to parse out the wire and call <code>++sigh</code> from the <code>connector</code> library with the list of places, care, path, and HTTP result. This will match the path to the appropriate place and run either <code>++sigh-x</code> or <code>++sigh-y</code>, depending on the care. </p></li><li><p>If <code>++read-x</code> or <code>++read-y</code> made an API request that failed, then we&#39;ll get a stack trace in <code>++sigh-tang</code>. Here, we just print it out and move on. </p></li></ul><p>That&#39;s really all there is to the reading portion of API connectors. </p><p>One of the most accessible ways to jump into Arvo programming is to just add more places to an existing API connector. It&#39;s useful, small in scope, and comes in bite-sized chunks since most places are less than ten lines of code. </p><h4 id="listening-">Listening </h4><p>Listening for events is fairly service-specific. In some services, we poll for changes. The Twitter connector has an example of this, but note that it predates the <code>connector</code> library and is thus more complicated than it needs to be, and the interface it exposes isn&#39;t standard. In Github, we power our event streams with webhooks. </p><p>For Github, when someone subscribes to <code>/listen/&lt;user&gt;/&lt;repo&gt;/&lt;events...&gt;</code>, we want to produce well-typed results when they occur. </p><p>We only want to create one webhook per event, so in our state we have <code>hook</code>, which is a map of event names to the set of bones which are subscribed to that event. We must always keep this up-to-date. </p><p>Flow of control starts in <code>++peer-listen</code>, where we just call <code>++listen</code>. In <code>++listen</code>, for each event in the list of events, we check to see if we have that hook set up (by checking whether it exists in <code>hook</code>). If so, we call <code>++update-hook</code> to add the current bone to the set of listeners. Otherwise, we call <code>++create-hook</code>, which sends a request to Github to set up the new webhook. We also create an entry in <code>hook</code> with the current bone. </p><p>When we created the webhook, we told Github to send the event to <code>/~/to/gh/gh-&lt;event&gt;.json?anon&amp;wire=/</code>. This turns into a poke. Let&#39;s parse out this url. The first <code>gh</code> is the app name to poke. The next portion, <code>gh-&lt;event&gt;</code> is the mark to convert the JSON to. For example, when the “issues” event fires, it&#39;ll get converted to mark <code>gh-issues</code>. This mark has a conversion routine from <code>json</code> to the <code>issues</code> type, which is defined in the <code>gh</code> structure (<code>/=home=/sur/gh/hoon</code>). Once this conversion happens, the <code>gh</code> app will get poked with the correctly marked data in <code>++poke</code>. </p><p>In <code>++poke</code>, we check <code>hook</code> to find the subscribers to the event that was fired, and we update them. </p><p>That&#39;s really all there is to it. Webhook flow isn&#39;t well standardized, so even if your chosen service is powered by webhooks, your listening code might look rather different. The point is to expose the correct interface. </p><h4 id="github-api-connector-code-">Github API Connector Code </h4><p>In case the code in <code>/=home=/app/gh/hoon</code> drifts out of sync with this doc: </p><pre>::  This is a connector for the Github API v3.
::
::  You can interact with this in a few different ways:
::
::    - .^({type} %gx /=gh={/endpoint}) to read data or
::      .^(arch %gy /=gh={/endpoint}) to explore the possible
::      endpoints.
::
::    - subscribe to /listen/{owner}/{repo}/{events...} for
::      webhook-powered event notifications.  For event list, see
::      https://developer.github.com/webhooks/.
::
::  This is written with the standard structure for api
::  connectors, as described in lib/connector.hoon.
::
/?  314
/-  gh, plan-acct
/+  gh-parse, connector
::
!:
=&gt;  |%
    +$  move  (pair bone card)
    +$  card
      $%  [%diff sub-result]
          [%them wire (unit hiss:eyre)]
          [%hiss wire [%~ %~] %httr [%hiss hiss:eyre]]
      ==
    ::
    ::  Types of results we produce to subscribers.
    ::
    +$  sub-result
      $%  [%arch arch]
          [%gh-issue issue:gh]
          [%gh-list-issues (list issue:gh)]
          [%gh-issues issues:gh]
          [%gh-issue-comment issue-comment:gh]
          [%json json]
          [%null %~]
      ==
    ::
    ::  Types of webhooks we expect.
    ::
    +$  hook-response
      $%  [%gh-issues issues:gh]
          [%gh-issue-comment issue-comment:gh]
      ==
    --
=+  connector=(connector move sub-result)  ::  Set up connector library
::
|_  $:  hid=bowl:gall
        hook=(map @t [id=@t listeners=(set bone)])  ::  map events to listeners
    ==
::  ++  prep  _`.  ::  Clear state when code changes
::
::  List of endpoints
::
++  places
  |=  wir=wire
  ^-  (list place:connector)
  =+  (helpers:connector ost.hid wir &quot;https://api.github.com&quot;)
  =&gt;  |%                              ::  gh-specific helpers
      ++  sigh-list-issues-x
        |=  jon=json
        %+  bind  ((ar:jo issue:gh-parse) jon)
        |=  issues=(list issue:gh)
        gh-list-issues+issues
      ::
      ++  sigh-list-issues-y
        |=  jon=json
        %+  bind  ((ar:jo issue:gh-parse) jon)
        |=  issues=(list issue:gh)
        :-  `(shax (jam issues))
        (malt (turn issues |=(issue:gh [(rsh 3 2 (scot %ui number)) ~])))
      --
  :~  ^-  place                       ::  /
      :*  guard=,%~
          read-x=read-null
          read-y=(read-static %issues ~)
          sigh-x=sigh-strange
          sigh-y=sigh-strange
      ==
      ^-  place                       ::  /issues
      :*  guard=,[%issues %~]
          read-x=read-null
          read-y=(read-static %mine %by-repo ~)
          sigh-x=sigh-strange
          sigh-y=sigh-strange
      ==
      ^-  place                       ::  /issues/mine
      :*  guard=,[%issues %mine %~]
          read-x=(read-get /issues)
          read-y=(read-get /issues)
          sigh-x=sigh-list-issues-x
          sigh-y=sigh-list-issues-y
      ==
      ^-  place                       ::  /issues/by-repo
      :*  guard=,[%issues %by-repo %~]
          read-x=read-null
          ^=  read-y
          |=  pax=path
          =+  /(scot %p our.hid)/home/(scot %da now.hid)/web/plan
          =+  .^([* acc=(map knot plan-acct)] %cx -)
        ::
          ((read-static usr:(~(got by acc) %github) ~) pax)
          sigh-x=sigh-strange
          sigh-y=sigh-strange
      ==
      ^-  place                       ::  /issues/by-repo/&lt;user&gt;
      :*  guard=,[%issues %by-repo @t %~]
          read-x=read-null
          read-y=|=(pax=path (get /users/[-.+&gt;.pax]/repos))
          sigh-x=sigh-strange
          ^=  sigh-y
          |=  jon=json
          %+  bind  ((ar:jo repository:gh-parse) jon)
          |=  repos=(list repository:gh)
          [~ (malt (turn repos |=(repository:gh [name ~])))]
      ==
      ^-  place                       ::  /issues/by-repo/&lt;user&gt;/&lt;repo&gt;
      :*  guard=,[%issues %by-repo @t @t %~]
          read-x=|=(pax=path (get /repos/[-.+&gt;.pax]/[-.+&gt;+.pax]/issues))
          read-y=|=(pax=path (get /repos/[-.+&gt;.pax]/[-.+&gt;+.pax]/issues))
          sigh-x=sigh-list-issues-x
          sigh-y=sigh-list-issues-y
      ==
      ^-  place                       ::  /issues/by-repo/&lt;user&gt;/&lt;repo&gt;
      :*  guard=,[%issues %by-repo @t @t @t %~]
          ^=  read-x
          |=(pax=path (get /repos/[-.+&gt;.pax]/[-.+&gt;+.pax]/issues/[-.+&gt;+&gt;.pax]))
        ::
          read-y=(read-static ~)
          ^=  sigh-x
          |=  jon=json
          %+  bind  (issue:gh-parse jon)
          |=  issue=issue:gh
          gh-issue+issue
        ::
          sigh-y=sigh-strange
      ==
  ==
::
::  When a peek on a path blocks, ford turns it into a peer on
::  /scry/{care}/{path}.  You can also just peer to this
::  directly.
::
::  We hand control to ++scry.
::
++  peer-scry
  |=  pax=path
  ^-  [(list move) _+&gt;.$]
  ?&gt;  ?=([care:clay *] pax)
  :_  +&gt;.$  :_  ~
  (read:connector ost.hid (places %read pax) i.pax t.pax)
::
::  HTTP response.  We make sure the response is good, then
::  produce the result (as JSON) to whoever sent the request.
::
++  sigh-httr
  |=  [way=wire res=httr:eyre]
  ^-  [(list move) _+&gt;.$]
  ?.  ?=([%read care:clay @ *] way)
    ~&amp;  res=res
    [~ +&gt;.$]
  =*  style  i.way
  =*  ren  i.t.way
  =*  pax  t.t.way
  :_  +&gt;.$  :_  ~
  :+  ost.hid  %diff
  (sigh:connector (places ren style pax) ren pax res)
::
::  HTTP error.  We just print it out, though maybe we should
::  also produce a result so that the request doesn&#39;t hang?
::
++  sigh-tang
  |=  [way=wire tan=tang]
  ^-  [(list move) _+&gt;.$]
  %-  (slog &gt;%gh-sigh-tang&lt; tan)
  [[ost.hid %diff null+~]~ +&gt;.$]
::
::  We can&#39;t actually give the response to pretty much anything
::  without blocking, so we just block unconditionally.
::
++  peek
  |=  [ren=@tas tyl=path]
  ^-  (unit (unit (pair mark *)))
  ~ ::``noun=[ren tyl]
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::         Webhook-powered event streams (/listen)            ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::  To listen to a webhook-powered stream of events, subscribe
::  to /listen/&lt;user&gt;/&lt;repo&gt;/&lt;events...&gt;
::
::  We hand control to ++listen.
::
++  peer-listen
  |=  pax=path
  ^-  [(list move) _+&gt;.$]
  ?.  ?=([@ @ *] pax)
    ~&amp;  [%bad-listen-path pax]
    [~ +&gt;.$]
  (listen pax)
::
::  This core handles event subscription requests by starting or
::  updating the webhook flow for each event.
::
++  listen
  |=  pax=path
  =|  mow=(list move)
  =&lt;  abet:listen
  |%
  ++  abet                                              ::  Resolve core.
    ^-  [(list move) _+&gt;.$]
    [(flop mow) +&gt;.$]
  ::
  ++  send-hiss                                         ::  Send a hiss
    |=  hiz=hiss:eyre
    ^+  +&gt;
    =+  wir=`wire`[%x %listen pax]
    +&gt;.$(mow [[ost.hid %hiss wir `~ %httr [%hiss hiz]] mow])
  ::
  ::  Create or update a webhook to listen for a set of events.
  ::
  ++  listen
    ^+  .
    =+  pax=pax  ::  TMI-proofing
    ?&gt;  ?=([@ @ *] pax)
    =+  events=t.t.pax
    |-  ^+  +&gt;+.$
    ?~  events
      +&gt;+.$
    ?:  (~(has by hook) i.events)
      $(+&gt;+ (update-hook i.events), events t.events)
    $(+&gt;+ (create-hook i.events), events t.events)
  ::
  ::  Set up a webhook.
  ::
  ++  create-hook
    |=  event=@t
    ^+  +&gt;
    ?&gt;  ?=([@ @ *] pax)
    =+  clean-event=`tape`(turn (trip event) |=(a=@tD ?:(=(&#39;_&#39; a) &#39;-&#39; a)))
    =.  hook
      %+  ~(put by hook)  (crip clean-event)
      =+  %+  fall
            (~(get by hook) (crip clean-event))
          *[id=@t listeners=(set bone)]
      [id (~(put in listeners) ost.hid)]
    %-  send-hiss
    :*  %+  scan
          =+  [(trip i.pax) (trip i.t.pax)]
          &quot;https://api.github.com/repos/{-&lt;}/{-&gt;}/hooks&quot;
        auri:de-purl:html
        %post  ~  ~
        %-  as-octs:mimes:html  %-  crip  %-  en-json:html  %-  pairs:enjs:format  :~
          name+s+%web
          active+b+&amp;
          events+a+~[s+event] ::(turn `(list ,@t)`t.t.pax |=(a=@t s=a))
          :-  %config
          %-  pairs:enjs:format  :~
            =+  =+  clean-event
                &quot;http://107.170.195.5:8443/~/to/gh/gh-{-}.json?anon&amp;wire=/&quot;
            [%url s+(crip -)]
            [%&#39;content_type&#39; s+%json]
          ==
        ==
    ==
  ::
  ::  Add current bone to the list of subscribers for this event.
  ::
  ++  update-hook
    |=  event=@t
    ^+  +&gt;
    =+  hok=(~(got by hook) event)
    %_    +&gt;.$
        hook
      %+  ~(put by hook)  event
      hok(listeners (~(put in listeners.hok) ost.hid))
    ==
  --
::
::  Pokes that aren&#39;t caught in more specific arms are handled
::  here.  These should be only from webhooks firing, so if we
::  get any mark that we shouldn&#39;t get from a webhook, we reject
::  it.  Otherwise, we spam out the event to everyone who&#39;s
::  listening for that event.
::
++  poke
  |=  response=hook-response
  ^-  [(list move) _+&gt;.$]
  =+  hook-data=(~(get by hook) (rsh 3 3 -.response))
  ?~  hook-data
    ~&amp;  [%strange-hook hook response]
    [~ +&gt;.$]
  ::  ~&amp;  response=response
  :_  +&gt;.$
  %+  turn  ~(tap in listeners.u.hook-data)
  |=  ost=bone
  [ost %diff response]
--
</pre><h2><div id="generators">Generators</div></h2><p>Up until now we&#39;ve poked apps directly. This requires the user to specify the mark, and it requires the app to accept the arguments in a way that&#39;s convenient for users to input. This is the “plumbing” way to interact with apps. Generators are the “porcelain” layer. This is why when you run a command like <code>+ls</code> or <code>|merge</code>, there are no marks in sight. </p><p>We&#39;ve used generators before, back in <a href="/docs/learn/arvo/arvo-internals/admin">Basic Operation</a>. At that point, we just used the generators to produce values -- we didn&#39;t pipe their results into apps. In the dojo cast, the role of a generator is to take a list of arguments and produce a value, which is often, though not always, piped into an app. Generators are pure, stateless functions, and they cannot send moves. </p><p><code>+ls</code> and <code>+cat</code> are commonly-used generators that produce a directory listing and print out a file, respectively. These are useful in themselves, so we generally don&#39;t pipe the results into an app. </p><p>Another generator is <code>+hood/merge</code>. Try running <code>+hood/merge</code> with the normal arguments for <code>|merge</code>: </p><pre>&gt; +hood/merge %home our %they
[syd=%home her=~zod sud=%they cas=[%da p=~2018.10.4..21.11.49..901c] gem=%auto]

&gt; +hood/merge %home our %they, =gem %this
[syd=%home her=~zod sud=%they cas=[%da p=~2018.10.4..21.12.11..ee32] gem=%this]
</pre><p>This didn&#39;t run any merge, it just constructed the command that, if sent to <code>:hood</code>, would run it. Note first that, even though it&#39;s not printed, this value has mark <code>kiln-merge</code>. Also, the merge strategy <code>gem=%auto</code> was added automatically. Optional arguments are straightforward with generators. </p><p>In general, generators are prepended by either <code>+</code> or <code>|</code>. The general form is <code>+generator</code>, but often generators are created specifically to work with a single app, they&#39;re usually placed in a subdirectory of gen and run with <code>|</code>. Thus, if <code>my-generator</code> generator is made for use with <code>:my-app</code>, then <code>my-generator</code> is put in <code>/gen/my-app/my-generator.hoon</code>, and can be run directly with <code>+my-app/my-generator &lt;args&gt;</code>. If you want to pipe the result into <code>:my-app</code>, then run <code>:my-app +my-app/my-generator &lt;args&gt;</code>. Because this pattern is so common, this can be abbreviated to <code>:my-app|my-generator &lt;args&gt;</code>. Because most built-in commands are generators for the <code>:hood</code> app, <code>:hood|generator &lt;args&gt;</code> can be shortened to <code>|generator &lt;args&gt;</code>. </p><p>Let&#39;s write a generator called <code>:pong</code> that takes an urbit address, which is of mark <code>urbit</code>, and sends that urbit the message <code>&#39;howdy&#39;</code>. First--without a generator--let&#39;s make <code>:ping</code> that does the same, except that it lets the user optionally specify the message as well. </p><p>We&#39;ll need a new mark for our arguments. Let&#39;s call it <code>ping-message</code>. </p><blockquote><p>For app-specific marks, it&#39;s good style to prefix the name of the mark with the name of the app. Since many apps have several such marks, subdirectories in <code>/mar</code> are rendered as <code>-</code>, so that <code>ping-message</code> is written in (/mar/ping/message.hoon). </p></blockquote><pre>::
::::  /mar/ping/message/hoon
  ::
/?    314
|_  [to=@p message=@t]
++  grab
  |%
  +$  noun  [@p @t]
  --
--
</pre><p>The app can easily be modified to use this (<code>/app/ping.hoon</code>): </p><pre>::  Allows one ship to ping another with a string of text
::
::::  /app/ping/hoon
  ::
/?    314
|%
  +$  move  [bone term wire *]
--
!:
|_  [bowl:gall state=%~]
::
++  poke-ping-message
  |=  [to=@p message=@t]
  ~&amp;  &#39;sent&#39;
  ^-  [(list move) _+&gt;.$]
  :-  ^-  (list move)
      :~  `move`[ost %poke /sending [to dap] %atom message]
      ==
  +&gt;.$
::
++  poke-atom
  |=  arg=@
  ~&amp;  &#39;received&#39;
  ^-  [(list move) _+&gt;.$]
  ::
  ~&amp;  [%receiving (@t arg)]
  [~ +&gt;.$]
::
++  coup  |=(* `+&gt;)
--
</pre><p>Now we can run this with: </p><pre>~fintud-macrep:dojo&gt; |start %ping
&gt;=

~fintud-macrep:dojo&gt; :ping &amp;ping-message [~sampel-sipnym &#39;heyya&#39;]
&gt;=
</pre><p>And on <code>~sampel-sipnym</code>, assuming it&#39;s running <code>:ping</code> as well, we see <code>[%receiving &#39;heyya&#39;]</code>. </p><p>This is an annoying way to invoke the app, though. The <code>[]</code> are mandatory, and optional arguments are hard. Let&#39;s make a generator, <code>+send</code> to make everything nicer. Since it&#39;s specific to <code>:ping</code>, let&#39;s put it in <code>/gen/ping/send.hoon</code>: </p><pre>:-  %say
|=  [^ [to=@p message=?(%~ [text=@t %~])] %~]
[%ping-message to ?~(message &#39;howdy&#39; text.message)]
</pre><p>A couple of new things here. Firstly, <code>message=?(%~ [text=@t %~])] %~]</code> should be read as “the message is either null or a pair of text and null”. Generator argument lists are always null-terminated, which makes it convenient to accept lists in tail position (which are particularly annoying without generators). <code>?(a b)</code> is the irregular form of <code>$?(a b)</code>, which is a union type. Thus, <code>?(a b)</code> means the type of anything that&#39;s in either <code>a</code> or <code>b</code>. Thus, in our case, <code>?(~ [text=@t ~])</code> is either null or a pair of text and null. </p><p>This is run as follows: </p><pre>~fintud-macrep:dojo&gt; :ping|send ~sampel-sipnym
&gt;=

~fintud-macrep:dojo&gt; :ping|send ~sampel-sipnym &#39;how do you do&#39;
&gt;=
</pre><p>Which causes <code>~sampel-sipnym</code> to print <code>[%receiving &#39;howdy&#39;]</code> and <code>[%receiving &#39;how do you do&#39;]</code>. </p><p>(Note: <code>:ping|send ~sampel-sipnym</code> is short for <code>:ping +ping/send ~sampel-sipnym</code>.) </p><p><b>Exercises</b>: </p><ul><li><p>Create a generator for <code>:sum</code> from <a href="#state">State</a> so that you can run <code>:sum|add 5</code> to add numbers to it. </p></li><li><p>Create a generator for <code>:click</code> from <a href="#backend">Web Apps</a> so that you can run <code>:click|poke</code> to poke it. </p></li></ul><h2><div id="http">Writing an HTTP Request</div></h2><p>There&#39;s a variety of arvo services we haven&#39;t touched on yet. Let&#39;s figure out how to make HTTP requests and set timers. </p><p>Let&#39;s build an uptime-monitoring system. It&#39;ll ping a web service periodically and print out an error when the response code isn&#39;t 2xx. Save the following as <code>app/up.hoon</code>: </p><pre>::  Up-ness monitor. Accepts atom url, &#39;on&#39;, or &#39;off&#39;
::
::::  /hoon/up/app
  ::
/?    314
|%
+$  move  [bone card]
+$  card
  $%  [%hiss wire unit-iden=$~ mark=%httr cage=[mark=%purl vase=purl:eyre]]
      [%wait wire @da]
  ==
+$  action
  $%  [%on $~]            ::  enable polling(&#39;on&#39;)
      [%off $~]           ::  disable polling(&#39;off)
      [%target p=cord]    ::  set poll target(&#39;http://...&#39;)
  ==
--
|_  [hid=bowl:gall on=_| in-progress=_| target=@t]
++  poke-atom
  |=  url-or-command=@t  ^-  (quip move _+&gt;)
  =+  ^-  act/action
      ?:  ?=($on url-or-command)  [%on ~]
      ?:  ?=($off url-or-command)  [%off ~]
      [%target url-or-command]
  ?-  -.act
    $target  [~ +&gt;.$(target p.act)]
    $off  [~ +&gt;.$(on |)]
    $on
      :-  ?:  |(on in-progress)  ~
          [ost.hid %hiss /request ~ %httr %purl (need (de-purl:html target))]~
      +&gt;.$(on &amp;, in-progress &amp;)
  ==
++  sigh-httr
  |=  [wir=wire code=@ud headers=mess:eyre body=(unit octs)]
  ~&amp;  &#39;arrive here&#39;
  ^-  [(list move) _+&gt;.$]
  ?:  &amp;((gte code 200) (lth code 300))
    ~&amp;  [%all-is-well code]
    :_  +&gt;.$
    [ost.hid %wait /timer (add ~s10 now.hid)]~
  ~&amp;  [%we-have-a-problem code]
  ~&amp;  [%headers headers]
  ~&amp;  [%body body]
  :_  +&gt;.$
  [ost.hid %wait /timer (add ~s10 now.hid)]~
++  wake-timer
  |=  [wir=wire $~]  ^-  (quip move _+&gt;)
  ?:  on
    :_  +&gt;.$
    [ost.hid %hiss /request ~ %httr %purl (need (de-purl:html target))]~
  [~ +&gt;.$(in-progress |)]
::
++  prep  ~&amp;  target  _`.  :: computed when the source file changes;
--                         :: here it prints target then resets our state
</pre><p>There&#39;s some fancy stuff going on here. We&#39;ll go through it line by line, though. </p><p>There&#39;s two kinds of cards we&#39;re sending to arvo. A <code>%hiss</code> move tells <code>%eyre</code> to make an HTTP request. It expects a <code>(unit iden)</code>, which will be null here because we aren&#39;t doing any authentication; a mark, in this case the http request mark <code>&amp;httr</code>; and some data in the form of a <code>cage</code>, which is a <code>[mark vase]</code>. This is confusing, so the mold in the code quoted above includes a bunch of otherwise unnecessary faces for the purpose of illustration. Compare: <code>[%hiss p=(unit user) q=mark r=cage]</code> from <code>zuse</code>. </p><blockquote><p>You can grep zuse.hoon and arvo.hoon for most of these definitions. However, beware the ambiguity surrounding “hiss”: there&#39;s <code>++hiss</code> in section 3bI of <code>zuse</code> (“Arvo structures”), and there&#39;s <code>%hiss</code> the move that is sent to <code>%eyre</code> to make our HTTP request happen. Here we&#39;re talking about the latter. See <code>++kiss-eyre</code> in <code>zuse</code>. </p></blockquote><blockquote><p>Recall that <code>++unit</code> means “maybe”. Formally, “<code>(unit a)</code> is either null or a pair of null and a value in <code>a</code>”. Also recall that to pull a value out of a unit (<code>u.unit</code>), you must first verify that the unit is not null (for example with <code>?~</code>). See <code>++need</code>. </p></blockquote><p>A <code>purl:eyre</code> is a parsed url structure, which can be created with <code>de-purl:html</code>, which is a function that takes a url as text and parses it into a <code>(unit purl:eyre)</code>. Thus, the result is null if and only if the url is malformed. &#39;Purl&#39; is also the mark which will be applied to this result. </p><p>When you send this request, you can expect a <code>%sigh</code> with the response, which we handle later on in <code>++sigh-httr</code>. </p><p>For <code>%wait</code>, you just pass a <code>@da</code> (absolute date), and arvo will produce a <code>%wake</code> when the time comes. </p><blockquote><p>A timer is guaranteed to not be triggered before the given time, but it&#39;s currently impossible to guarantee the timer will be triggered at exactly the requested time. </p></blockquote><p>Let&#39;s take a look at our state: </p><pre>|_  [hid=bowl:gall on=_| in-progress=_| target=@t]
</pre><p>We have three pieces of app-specific state. <code>target</code> is the url we&#39;re monitoring. <code>on</code> and <code>in-progress</code> are booleans representing, respectively, whether or not we&#39;re supposed to keep monitoring and whether or not we&#39;re in the middle of a request. </p><p>The type of booleans is usually written as <code>?</code>, which is a union of <code>&amp;</code> (true) and <code>|</code> false. This type defaults to <code>&amp;</code> (true). In our case, we want both of these to default to <code>|</code> (false). Because of that, we use <code>_|</code> as the type. <code>_value</code> means “take the type of <code>value</code>, but make the default value be <code>value</code>”. Thus, our type is still a boolean, just like <code>?</code>, but the default value is <code>|</code> (false). </p><blockquote><p>This is the same <code>_</code> used in <code>_+&gt;.$</code>, which means “the same type as the value ”+&gt;.$&quot;. In other words, the same type as our current context and state. </p></blockquote><p>Let&#39;s take a look at <code>++poke-atom</code>. When we&#39;re poked with an atom, we first check whether the atom is <code>&#39;off&#39;</code>. If so, we set our state variable <code>on</code> to false. </p><p>If not, we check whether the atom is <code>&#39;on&#39;</code>. If so, we set <code>on</code> and <code>in-progress</code> to true. If it was already either on or in progress, then we don&#39;t take any other immediate action. If it was both off and not in progress, then we send an HTTP request. </p><p>If the argument is neither &#39;off&#39; nor &#39;on&#39;, then we assume it&#39;s an actual url, so we save it in <code>target</code>. </p><p>Here&#39;s the move that sends the HTTP request: </p><pre>[ost.hid %hiss /request ~ %httr %purl (need (de-purl:html target))]
</pre><blockquote><p>Remember, we are expected to produce a <b>list</b> of moves. Note the <code>~</code> after the move in the full example. This is a convenient shortcut for creating a list of a single element. It&#39;s part of a small family of such shortcuts. <code>~[a b c]</code> is <code>[a b c ~]</code>, <code>[a b c]~</code> is <code>[[a b c] ~]</code> and <code>`[a b c]</code> is <code>[~ a b c]</code>. These may be mixed and matched to create various convoluted structures and emojis. </p></blockquote><p>The correspondence between this move and <code>[bone card]</code> can be hard to visualize on one line. Here it is more pedantically: </p><pre>:*  bone=ost.hid                                        :: the move
    term=%hiss
    wire=/request
    unit-iden=~
    mark=%httr
    cage=[%purl (need (de-purl:html target))]
==
</pre><p>When the HTTP response comes back, we handle it with <code>++sigh-httr</code>, which, along with the wire the request was sent on, takes the status code, the response headers, and the response body. </p><p>We check whether the status code is between 200 and 300. If so, all is well, and we print a message saying so. We start the timer for ten seconds after the present time. </p><p>If we got a bad status code, then we print out the entire response and start the timer again. </p><p>After ten seconds, arvo will give us a <code>%wake</code> event, which will be handled in <code>++wake-timer</code>. If we&#39;re still supposed to keep monitoring, we send the same HTTP request as before. Otherwise, we set <code>in-progress</code> to false. </p><p>Let&#39;s try it out: </p><pre>~fintud-macrep:dojo&gt; |start %up
&gt;=
~fintud-macrep:dojo&gt; :up &amp;atom &#39;http://www.google.com&#39;
&gt;=
[%all-is-well 200]
[%all-is-well 200]
~fintud-macrep:dojo&gt; :up &amp;atom &#39;http://example.com&#39;
&gt;=
[%all-is-well 200]
~fintud-macrep:dojo&gt; :up &amp;atom &#39;http://google.com&#39;
&gt;=
[%we-have-a-problem 301]
[ %headers
  ~[
    [p=&#39;X-Frame-Options&#39; q=&#39;SAMEORIGIN&#39;]
    [p=&#39;X-XSS-Protection&#39; q=&#39;1; mode=block&#39;]
    [p=&#39;Content-Length&#39; q=&#39;219&#39;]
    [p=&#39;Server&#39; q=&#39;gws&#39;]
    [p=&#39;Cache-Control&#39; q=&#39;public, max-age=2592000&#39;]
    [p=&#39;Expires&#39; q=&#39;Sun, 10 Jan 2016 23:45:05 GMT&#39;]
    [p=&#39;Date&#39; q=&#39;Fri, 11 Dec 2015 23:45:05 GMT&#39;]
    [p=&#39;Content-Type&#39; q=&#39;text/html; charset=UTF-8&#39;]
    [p=&#39;Location&#39; q=&#39;http://www.google.com/&#39;]
  ]
]
[ %body
  [ ~
    [ p=219
        q
      \/&#39;&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;\0a&lt;TITLE&gt;301 Moved&lt;/TI\/
        TLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;\0a&lt;H1&gt;301 Moved&lt;/H1&gt;\0aThe document has moved\0a&lt;A HREF=&quot;http://www.google.com/&quot;&gt;her
        e&lt;/A&gt;.\0d\0a&lt;/BODY&gt;&lt;/HTML&gt;\0d\0a&#39;
      \/                                                                                                      \/
    ]
  ]
]
~fintud-macrep:dojo&gt; :up &amp;atom &#39;off&#39;
</pre><h2><div id="marks">Marks</div></h2><p>We&#39;ve used predefined marks already, but we haven&#39;t yet created our own marks. Let&#39;s write a sample mark of our own, then chain it together with some preexisting ones to have fun with type conversions. </p><p>Let&#39;s make a small “cord” mark. “Cord” is a name we use for <code>@t</code> text, but there&#39;s no predefined mark for it. Let&#39;s put the following code in: <code>/mar/cord.hoon</code>: </p><pre>/?  314
|_  cod=@t
++  grab
  |%
  ++  atom  |=(arg=@ `@t`(scot %ud arg))
  --
++  grow
  |%
  ++  md  cod
  --
--
</pre><p><code>/? 314</code> is the required version number, just like in apps. After that everything&#39;s in a <code>|_</code>, which is a <code>|%</code> core, but with input arguments. In our case, the argument is the marked data. </p><p>There are three possible top-level arms in the <code>|_</code> core, <code>++grab</code>, <code>++grow</code>, and <code>++grad</code> (which is used for revision control, covered elsewhere). <code>++grab</code> specifies functions to convert from another mark to the current mark. <code>++grow</code> specifies how to convert from the current mark to another one. </p><p>In our case, we only define one arm in <code>++grab</code>, namely <code>++atom</code>. This allows us to convert any atom to a cord. <code>++scot</code> is a standard library function in <code>hoon.hoon</code> which pretty-prints atoms of various types. We want to treat the atom as an unsigned decimal number, so we give <code>%ud</code> and the given argument to <code>++scot</code>. Thus, the form of an arm in <code>++grab</code> is <code>|=(other-mark-type this-mark-value)</code>. </p><p>In <code>++grow</code>, we just convert to the <code>md</code> mark, which is just a <code>@t</code> internally, but it has fancy conversion functions to things like html. <code>++md</code> isn&#39;t a function because the “argument” is already a <code>@t</code>, so we can just produce the new value directly. </p><p>Let&#39;s play around a bit with this mark. First, let&#39;s take a marked atom and convert it to our new mark. </p><pre>~fintud-macrep:dojo&gt; &amp;atom 9
9

~fintud-macrep:dojo&gt; &amp;cord &amp;atom 9
&#39;9&#39;

~fintud-macrep:dojo&gt; &amp;cord &amp;atom &amp;cord &amp;atom 9
 &#39;57&#39;
</pre><p>ASCII 9 is 57. There&#39;s no requirement, implicit or otherwise, that conversions back and forth between marks be inverses of each other. These are semantic conversions, in that they refer to the same concept. They&#39;re not isomorphisms. </p><p>Let&#39;s play around a little more: </p><pre>~fintud-macrep:dojo&gt; &amp;md &amp;cord &amp;atom 17
&#39;17&#39;

~fintud-macrep:dojo&gt; &amp;hymn &amp;md &amp;cord &amp;atom 17
[ [%html ~]
  [[%head ~] ~]
  [[%body ~] [g=[n=%pre a=~] c=~[[g=[n=%$ a=~[[n=%$ v=&quot;17&quot;]]] c=~]]] ~]
  ~
]
</pre><p>That was exciting. If you squint at that, it looks an awful lot like html. Our value <code>17</code> is still in there, in the body. <code>urb</code> is the mark we render most web pages to. It makes sure you have a complete skeleton of a web page. Of course, by the time this gets to the web page, it&#39;s plain html. Let&#39;s do the final step in the conversion. </p><pre>~fintud-macrep:dojo&gt; &amp;mime &amp;hymn &amp;md &amp;cord &amp;atom 17
[[%text %html ~] p=52 q=&#39;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;17&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&#39;]
</pre><p>This is a mime-typed octet stream with type <code>/text/html</code>, length 121 bytes, and our lowly number <code>17</code> rendered to a web page. <code>cord</code> was just one step in the chain. </p><p>Of course, arvo can infer some parts of this chain: </p><pre>~fintud-macrep:dojo&gt; &amp;cord 17
&#39;17&#39;
</pre><p>Likewise, <code>md</code> is the only way to get from <code>cord</code> to <code>hymn</code>, so that can be omitted. If we omit the <code>hymn</code>, though, we get: </p><pre>~fintud-macrep:dojo&gt; &amp;mime &amp;cord 17
[[%text %x-markdown ~] p=2 q=&#39;17&#39;]
</pre><p>Here, we converted straight from <code>cord</code> to <code>md</code> to <code>mime</code>. Arvo decided that was the most straightforward conversion, but it gives a different result than passing it through the <code>hymn</code> mark. </p><p>The minimal correct input, then, is <code>&amp;mime &amp;hymn &amp;cord &amp;atom 17</code>. </p><h2><div id="network">Network Messages</div></h2><p>In the following we assume that you have some knowledge of Hoon. If you don&#39;t, check out chapters 1 and 2 of the Hoon tutorial and check back when you&#39;re ready. </p><p>Let&#39;s get our planets to talk to each other. To listen for and receive messages from other planets, we&#39;ll need an app. Let&#39;s look at a very simple one, <code>echo.hoon</code>: </p><pre>::  Accepts any noun from dojo and prints it out
::
::::  /===/app/echo/hoon
  ::
!:                          :: enables debug printfs
|%                          :: forms a core with subject as payload
+$  move  [bone card]       :: defines echo app&#39;s arvo move mold
+$  card  $%  $~            :: defines card (data) mold as null tagged union
          ==                :: end of mold definition; see $%
--                          :: end of card arm definition
::                          ::
|_  [bow=bowl:gall $~]      :: forms a core with bowl (app state) as sample
++  poke-noun               :: begin definition of poke-noun arm
  |=  non=*                 :: forms a gate which accepts any noun
  ^-  [(list move) _+&gt;.$]   :: casts product to mold of moves and context
  ~&amp;  echo+noun+non         :: debug printf, i.e. &#39;[%echo %noun *]&#39;
  [~ +&gt;.$]                  :: produce a cell of empty list and our state
--                          :: end of poke-noun arm definition
</pre><p>Save this as <code>echo.hoon</code> in the <code>/app</code> directory of your urbit&#39;s pier. </p><p>This is a very simple app that does only one thing. If you poke it with a value, it prints that value out. To try this out, you have to start the app, then you can poke it from the command line with the following commands: </p><pre>~fintud-macrep:dojo&gt; |start %echo
&gt;=

~fintud-macrep:dojo&gt; :echo 5
[%echo %noun 5]
&gt;=

~fintud-macrep:dojo&gt; :echo [1 2]
[%echo %noun [1 2]]
&gt;=
</pre><blockquote><p>There is currently a bug where the <code>[%echo %noun *]</code> lines are printed <b>above</b> the line you entered, so your output may not look exactly like this. <code>&gt;=</code> means that a command was successfully received and executed. </p></blockquote><p>Most of the app code should be simple enough to guess its function. The important part of this code is the definition of <code>++poke-noun</code>. </p><p>Once an app starts, it&#39;s always running in the background and you interact with it by sending it messages. The most straightforward way to do that is to poke it from the command line, which we we did with <code>:echo 5</code> (<code>:[app-name] [argument(s)]</code>). </p><p>In this case, <code>++poke-noun</code> takes an argument (<b>sample</b>) <code>arg</code> and prints it to dojo with <code>~&amp;</code> (<a href="/docs/reference/hoon-expressions/rune/sig#sigpad/">sigpad</a>). This is an unusual rune that formally “does nothing”, but the interpreter detects it and printfs the first child, before executing the second as if the first didn&#39;t exist. This is a slightly hacky way of printing to the console, but we&#39;ll get to the correct way later on. </p><p>But what does <code>++poke-noun</code> produce? Recall that <code>^-</code> casts to a type. In this case, it&#39;s declaring that the end result (<b>product</b>) of the function (<code>++poke-noun</code>&#39;s <b>gate</b>) will be of type <code>[(list) _+&gt;.$]</code>. But what does this mean? </p><p>The phrase to remember is “a list of moves and our state”. Urbit is a message passing system, so whenever we want to do something that interacts with the rest of the system, we send a message. Thus, a move is Arvo&#39;s equivalent of a syscall. The first thing that <code>++poke-noun</code> produces is a list of messages, called “moves”. In this case, we don&#39;t actually want the system to do anything, so we produce the empty list, <code>~</code> (in the <code>[~ +&gt;.$]</code> line). </p><p>The second thing <code>++poke-noun</code> produces is our state. <code>+&gt;.$</code> refers to a particular address in our subject where our formal app state is stored. It&#39;ll become clear why this is later on, but for now pretend that <code>+&gt;.$</code> is a magic invocation that means “app state”. </p><p>Let&#39;s look at another example. Say we want to only accept a number, and then print out the square of that number. </p><pre>::  Accepts an atom from the dojo and squares it.
::
::::  /===/app/square/hoon
  ::
!:
|%                                                  ::  no moves in :square
+$  move  [bone card]                               ::  no cards in :square
+$  card  $%  $~
          ==
--
::                                                  ::  stateless
|_  [bow=bowl:gall $~]
++  poke-atom
  |=  tom=@
  ^-  [(list move) _+&gt;.$]
  ~&amp;  square+(mul tom tom)
  [~ +&gt;.$]
--
</pre><p>Save this as <code>square.hoon</code> in the <code>/app</code> directory of your urbit&#39;s pier. </p><p>A few things have changed. Firstly, we no longer accept arbitrary nouns because we can only square atoms (integers, in this case an unsigned one). Thus, our argument is now <code>tom=@</code>. Secondly, it&#39;s <code>++poke-atom</code> rather than <code>++poke-noun</code>. </p><h3 id="intro-to-marks-">Intro to marks </h3><p>Are there other <code>++poke</code>s? Yes. In fact, <code>noun</code> and <code>atom</code> are just two of arbitrarily many “marks”. A mark is fundamentally a type definition, but accessible at the Arvo level. Each mark is defined in the <code>/mar</code> directory. Some marks have conversion routines to other marks, and some have diff, patch, and merge algorithms. None of these are required for a mark to exist, however. </p><p><code>noun</code> and <code>atom</code> are two predefined marks. In your <code>/mar</code> directory, there are already many more, and you may add more at will. The type associated with <code>noun</code> is <code>*</code>, and the type associated with <code>atom</code> is <code>@</code>. </p><p>When we poke an app from anywhere, we do so with a mark that searches for the corresponding (<code>++poke-[mark]</code>) arm. Data constructed on the command line is by default marked with <code>noun</code>. In this case, the app is expecting an atom, so we have to explicitly mark the data with <code>atom</code> using <code>&amp;[mark]</code>. Try the following commands: </p><pre>~fintud-macrep:dojo&gt; |start %square
&gt;=

~fintud-macrep:dojo&gt; :square 6
gall: %square: no poke arm for noun

~fintud-macrep:dojo&gt; :square &amp;atom 6
[%square 36]
&gt;=
</pre><blockquote><p>Recall the bug where <code>%square</code> may get printed above the input line. </p></blockquote><p>Marks are powerful, and they&#39;re the backbone of Urbit&#39;s data pipeline, so we&#39;ll be getting quite used to them. </p><p><b>Exercise</b>: </p><ul><li><p>Write an app that computes fizzbuzz on its input. </p></li></ul><h4 id="sending-a-message-to-another-urbit-">Sending a message to another urbit </h4><p>Let&#39;s write our first network message! Here&#39;s <code>examples/app/pong.hoon</code>: </p><pre>::  Allows one urbit to send the string &#39;Pong&#39; to
::  another urbit.
::
::::  /===/app/pong/hoon
  ::
!:
|%
+$  move  [bone card]
+$  card  $%  [$poke wire dock poke-contents]
          ==
+$  poke-contents  $%  [$atom @]
                   ==
--
|_  [bow=bowl:gall $~]                                    ::  stateless
::
++  poke-urbit
  |=  to=ship
  ^-  [(list move) _+&gt;.$]
  ~&amp;  pong+&#39;Outgoing pong!&#39;
  :_  +&gt;.$
  ~[[ost.bow %poke /sending [to dap.bow] %atom &#39;Pong&#39;]]
::
++  poke-atom
  |=  tom=@
  ^-  [(list move) _+&gt;.$]
  ~&amp;  pong+&#39;Incoming pong!&#39;
  ~&amp;  pong+received+`@t`tom
  [~ +&gt;.$]
::
++  coup  |=(* [~ +&gt;.$])
::
--
</pre><p>Run it with these commands: </p><pre>~fintud-macrep:dojo&gt; |start %pong
&gt;=

~fintud-macrep:dojo&gt; :pong &amp;urbit ~sampel-sipnym
&gt;=
</pre><p>Replace <code>~sampel-sipnym</code> with another urbit. The easiest thing to do is to start a comet, a free and disposable Urbit identity. If you don&#39;t know how to start a comet, see <a href="/docs/getting-started/">the user setup section</a>. Don&#39;t forget to start the <code>%pong</code> app on that urbit, too. You should see, on the foreign urbit, this output: </p><pre>[%pong &#39;Incoming pong!&#39;]
[%pong %received &#39;Pong&#39;]
</pre><p>Most of the code should be straightforward. In <code>++poke-atom</code>, the only new thing is the expression <code></code> <code>@t</code>tom <code></code>, which is <b>casting</b> the argument <code>tom</code> to type <code>@t</code>. As we already know, <code>@t</code> is the type of “cord” (text string). </p><p>The more interesting part is in <code>++poke-urbit</code>. The <code>urbit</code> mark is an urbit identity, and the Hoon type associated with it is <code>ship</code> or <code>@p</code> (the “p” stands for “phonetic base”). </p><p>Recall that in a <code>++poke</code> arm we produce “a list of moves and our state”. Until now, we&#39;ve left the list of moves empty, since we haven&#39;t wanted to tell Arvo to do anything in particular. Now we want to send a message to another urbit. Thus, we produce a list with one element: </p><pre>~[[ost.bow %poke /sending [to dap.bow] %atom &#39;Pong]]
</pre><h4 id="moves-">Moves </h4><p>The general form of a move is <code>[bone term wire *]</code>. </p><p>Or, in pseudo-code: </p><p><code>[&quot;cause&quot; sys-call/action tack-new-layer-on-cause action-specific information]</code> </p><p>Let&#39;s walk through each of these elements step by step. </p><h6 id="bones-----cause-----">Bones (“cause”) </h6><p>If you look up <code>++bone</code> in <code>hoon.hoon</code>, you&#39;ll see that it&#39;s a number (<code>@ud</code>), and that it&#39;s an opaque reference to a duct. <code>++duct</code> in <code>hoon.hoon</code> is a list of <code>wire</code>s, where <code>++wire</code> is an alias for <code>++path</code>. <code>++path</code> is a list of <code>++knot</code>s, which are ASCII text. Thus, a duct is a list of paths, and a bone is an opaque reference to it (in the same way that a Unix file descriptor is an opaque reference to a file structure). Thus, to truly understand bones, we must understand ducts. </p><p>A duct is a stack of causes, again, represented as paths, which are called wires. At the bottom of every duct is a unix event, such as a keystroke, network packet, file change, or timer event. When Arvo is given this event, it routes the event to appropriate kernel module for handling. </p><p>Sometimes, the module can immediately handle the event and produce any necessary results. For example, when we poked the <code>++poke-atom</code> arm above, we poked %gall, our application server, which was able to respond to our poke directly. When the module cannot service the request itself, it sends instructions to another kernel module or application (through the <code>%gall</code> module) to do a specified action, and produces the result from that. </p><p>Furthermore, when one module sends a message to another kernel module or application, it also sends along the duct it was given with its new wire tacked onto the top. Now the duct has two entries, with the unix event on the bottom and the kernel module that handled it on top. This process can continue indefinitely, pushing more and more wires onto the top of the duct. When an entity finally produces a result, a wire is popped off the duct, and the result is passed all the way back down, repeating the process of wire popping sequentially until the bottom of the duct is reached. </p><p>In effect, a duct is an Arvo-level call stack. It&#39;s worth noting that while in traditional call stacks a function call happens synchronously and returns exactly once. In Arvo, multiple moves can be sent at once, are evaluated asynchronously, and each one may be responded to zero or more times. </p><p>The point to take home is that whatever caused <code>++poke-urbit</code> to be called is also the root cause for the network message we&#39;re trying to send. Thus, we say to send the network message along the given bone <code>ost</code>. </p><h5 id="wire--path--">Wire (path) </h5><p>Of course, we have to push a new wire onto our duct before passing it along (or responding to it directly) anywhere. This wire can have any data we want in it, but we don&#39;t need anything specific here, so we just use the wire <code>/sending</code> (<code>/elem1/elem2/elemN</code> is one syntax used to create <code>++path</code>s and <code>++wire</code>s of N elements). If we were expecting a response (which we&#39;re not), it would come back along the <code>/sending</code> wire, meaning that the path <code>/sending</code> will be passed back to the response handler as an argument. Although it&#39;s not required, it&#39;s generally a good idea to make the wire human-readable for bug-handling purposes. </p><h5 id="term--sys-call--">Term (sys-call) </h5><p>Each move also has a <code>term</code>, composed of lowercase ASCII and/or <code>-</code>. This <code>term</code> has the sign <code>@tas</code>. In this case, our <code>term</code> is <code>%poke</code>, which is the name of the particular kind of move we&#39;re sending. You can always use <code>%poke</code> to message an app. Other common names include <code>%warp</code>, to read from the filesystem; <code>%wait</code>, to set a timer; and <code>%them</code>, to send an http request. </p><p>The move ends with <code>*</code> (that is, any noun) since each type of move takes different data. In our case, a <code>%poke</code> move takes a target (urbit and app) and marked data, then pokes the arm of the corresponding mark on that app on that urbit with that data. <code>[to-urbit-address %pong]</code> is the target urbit and app, <code>%atom</code> is the <code>mark</code>, and<code>&#39;Pong&#39;</code> is the data. </p><p>When Arvo receives a <code>%poke</code> move, it calls the appropriate <code>++poke</code>. The same mechanism is used for sending messages between apps on the same urbit as for sending messages between apps on different urbits. </p><blockquote><p>We said earlier that we&#39;re not expecting a response. This is not entirely true: the <code>++coup</code> is called when we receive acknowledgment that the <code>++poke</code> was called. We don&#39;t do anything with this information right now, but we could. </p></blockquote><p><b>Exercises</b>: </p><ul><li><p>Extend either of the apps in the first two exercises to accept input over the network in the same way as <code>pong</code>. </p></li><li><p>Modify <code>pong.hoon</code> to print out a message when it receives acknowledgement. </p></li><li><p>Write two apps, <code>even</code> and <code>odd</code>. When you pass an atom to <code>even</code>, check whether it&#39;s even. If so, divide it by two and recurse; otherwise, poke <code>odd</code> with it. When <code>odd</code> receives an atom, check whether it&#39;s equal to one. If so, terminate, printing “%success”. Otherwise, check whether it&#39;s odd. If so, multiply it by three, add one, and recurse; otherwise, poke <code>even</code> with it. When either app receives a number, print it out along with the name of the app. In the end, you should be able to watch Collatz&#39;s conjecture play out between the two apps. Sample output: </p></li></ul><pre>~fintud-macrep:dojo&gt; :even &amp;atom 18
[%even 18]
[%odd 9]
[%even 28]
[%even 14]
[%odd 7]
[%even 22]
[%odd 11]
[%even 34]
[%odd 17]
[%even 52]
[%even 26]
[%odd 13]
[%even 40]
[%even 20]
[%even 10]
[%odd 5]
[%even 16]
[%even 8]
[%even 4]
[%even 2]
%success
</pre><ul><li><p>Put <code>even</code> and <code>odd</code> on two separate urbits and pass the messages over the network. Post a link to a working solution in :talk to receive a cookie. </p></li></ul><h2><div id="security">Security Drivers</div></h2><p>A security driver is a file in <code>/=home=/sec/&lt;tld&gt;/&lt;domain&gt;/hoon</code> that handles the authentication for all HTTP requests to <code>https://&lt;domain&gt;.&lt;tld&gt;</code>. When anything in Urbit makes an HTTP request through <code>%eyre</code> (our web server), it checks to see if we have a security driver for the requested domain, and if so filters the request through the driver. The security driver will usually either decorate the request with the needed credentials if it has them, or else it will guide the user through the process of authenticating Urbit with the service. </p><p>Each web service needs its own security driver, but most of them are pretty standard. We recommend starting with an existing security driver based on your needed authentication method (e.g. basic auth, OAuth1, OAuth2), and changing whatever is specific to your service. </p><p>The best strategy for building security drivers is to copy a similar one and tweak it until it works for you. The best representatives are Github for Basic Authentication, Twitter for OAuth1, Slack for OAuth2 when access tokens don&#39;t expire, and Google APIs for OAuth2 when access tokens do expire. In most cases you&#39;ll need to make very few changes to one of these models. </p><p>Still, it&#39;s worth seeing one or two built from the ground up. Here, we&#39;ll build a connector for the Github API v3. (It&#39;s already in <code>/sec/com/github.hoon</code> if you want to see it.) </p><p>The simplest way to interact with the Github API is to just fetch https://api.github.com from the dojo. First, run this: </p><pre>&gt; |init-auth-basic /com/github
</pre><p>Input your Github username and password as directed. Next: </p><pre>~your-urbit:dojo&gt; +https://api.github.com
</pre><blockquote><p>Note: the current version of this API is outdated, so you&#39;ll get a 403 message at this point. We need to update this so you can follow along with the examples. We&#39;re sorry! </p></blockquote><p>Github exposes a few endpoints to the general web, and the root endpoint is one of them. This gives you a textual representation of a JSON object that contains a bunch of urls to other parts of Github&#39;s API. This is exactly the same response you would get from just running <code>curl https://api.github.com</code> on UNIX. </p><p>If we don&#39;t have a security driver for Github yet, many of the endpoints won&#39;t be accessible, or they will only have publicly accessible information. Most of what we care about requires us to be authenticated. </p><h4 id="basic-auth-">Basic auth </h4><p>Here&#39;s a simple security driver: </p><pre>::  Test url +https://api.github.com/user
::
::::  /hoon/github/com/sec
  ::
/+    basic-auth
!:
|_  [bal=(bale keys:basic-auth) $~]
++  aut  ~(standard basic-auth bal ~)
++  filter-request  out-adding-header:aut
--
</pre><p>Github supports authentication through either Basic Authentication or OAuth2. We&#39;ll show the basic auth example first, but in general we&#39;d prefer OAuth2. </p><p>Since this driver is for Github, put it in <code>/=home=/sec/com/github/hoon</code>. </p><p>To try this out, we first have to initialize our credentials with <code>|init-auth-basic</code>, which prompts for the url of the service (api.github.com), username, and password. It stores this information in a manner that <code>%eyre</code> knows how to decode and send put into your <code>bale</code>. Note that <code>|init-auth-basic</code> is standard for basic auth, but other auth schemes (like OAuth) are initialized in other ways. </p><p>After you&#39;ve run <code>|init-auth-basic</code>, you should be able to run <code>+https://api.github.com/user</code> and get a response indicating who you&#39;re logged in as. </p><p>You can similarly POST: </p><pre>~your-urbit:dojo&gt; +https://api.github.com/gists &amp;json _(cork de-json:html need) &#39;{&quot;files&quot;:{&quot;file1.txt&quot;:{&quot;content&quot;:&quot;can\&#39;t stop the signal&quot;}}}&#39;
</pre><p>This creates a gist, go to <code>https://gist.github.com/&lt;username&gt;</code> to see it. </p><p>The <code>+url</code> syntax used in “source” position makes a GET request, but if you pass it data it will make a POST request with that data as the body. This request is authenticated seamlessly. You can send data of any mark as long as it has a conversion path to <code>%mime</code>. </p><p>Let&#39;s take a look at the code and see if we can figure out what&#39;s happening here: </p><pre>/+    basic-auth
</pre><p>First, we load a library called <code>basic-auth</code>. This library exposes two items. <code>keys</code> is the type of the basic auth key, which is essentially a base64&#39;d username and password. <code>standard</code> accepts a <code>bale</code> and produces a core with everything we&#39;ll need to implement basic auth. </p><p>Every security driver needs some amount of state, which is stored in <code>bale</code>. <code>bale</code> contains: </p><ul><li><p><code>our</code>, our urbit name </p></li><li><p><code>now</code>, the current time </p></li><li><p><code>eny</code>, 256 bits of entropy </p></li><li><p><code>byk</code>, the urbit, desk and case which the security driver is running from </p></li><li><p><code>usr</code>, the particular identity we&#39;re logging in with </p></li><li><p><code>dom</code>, the site we&#39;re accessing </p></li><li><p><code>key</code>, the secrets required to authenticate requests. The type for this entry is supplied by the programmer as the argument to <code>++bale</code>. Thus, in our case, <code>key</code> in our bale is of type <code>keys:basic-auth</code>. </p></li></ul><p>Additionally, a security driver contains at least one out of the five “special” arms: </p><ul><li><p><code>++filter-request</code> is a function which takes a hiss (http request) and produces a <code>sec-move</code> (defined in zuse), which is one of: </p><ul><li><p><code>[%send hiss]</code>, which sends the new hiss. This is the case in, for example, basic auth, where all we need to do is add an extra header to the request. </p></li><li><p><code>[%give httr]</code>, where httr is an http response. This immediately returns an http response to the sender. </p></li><li><p><code>[%show purl]</code>, where a purl is a parsed url. This displays a message asking the user to visit the given url to continue the authentication process. </p></li><li><p><code>[%redo ~]</code>, which redoes the request. </p></li><li><p><code>%eyre</code> calls <code>++filter-request</code> just before sending an HTTP request to the specified domain. This allows the security driver to filter the requests, decorating them with authentication data. </p></li></ul></li><li><p><code>++filter-response</code> is a function which takes an httr and produces a <code>sec-move</code>. <code>%eyre</code> calls it after receiving an HTTP response from the specified domain. This allows the security driver to handle authentication errors, commonly caused by expired tokens, and retry the request. </p></li><li><p><code>++receive-auth-query-string</code> is a function that takes a <code>quay</code> (list of query parameters) and produces a <code>sec-move</code>. <code>%eyre</code> calls it when it receives a request on the callback url. Generally, this happens in OAuth after the user has granted access to the urbit app, and the service makes a request to the callback url with the code. The security driver should then make a request to convert the code into an access token. </p></li><li><p><code>++receive-auth-response</code> is a function that takes an httr and produces a <code>sec-move</code>. <code>%eyre</code> calls it when it gets a response to the request made in <code>++receive-auth-query-string</code>. </p></li><li><p><code>++update</code> is a function which converts old state to a new format when the security driver gets updated. If you want to just get rid of the old state, define <code>++discard-state</code> as <code>~</code>. </p></li></ul><p>For basic auth, we only have to worry about <code>++filter-request</code>, since all we need to do is add the correct header to each request. Our <code>++aut</code> core contains a function <code>++out-addding-header</code>, which does exactly what we want. </p><p>Where do the keys come from, though? Remember we ran <code>|init-auth-basic</code> to input them. This just prompts you for the service url, username, and password, and it stores them next to the driver. In our case, that&#39;s <code>/=home=/sec/com/gitub/api/atom</code>. These keys are stored encrypted, and you don&#39;t want to edit them directly. <code>%eyre</code> loads them directly into your <code>bale</code>. </p><h4 id="oauth2-">OAuth2 </h4><p>Most services are better accessed through some form of OAuth. Github can be accessed with OAuth2, which is a little more complicated than basic auth, but not hugely so. </p><p>The basic steps for OAuth2 are these: </p><ul><li><p>create an app and get its client id and client secret (on Github) </p></li><li><p>store these in Urbit (with <code>|init-oauth2</code>) </p></li><li><p>try to make a request that requires authentication. The security driver should prompt you to visit a particular url. </p></li><li><p>visit the url and click “authorize”, which gives the app access to your account </p></li><li><p>the security driver will turn the code it receives into an access token </p></li><li><p>on every request, include that access token </p></li></ul><p>Creating an app is easy and <a href="https://github.com/settings/applications/new">well-documented</a>. If necessary, set the callback url to <code>/~/ac/github.com/_state/in</code>, and note its client id and client secret. </p><p>Run <code>|init-oauth2</code>, which will prompt for the hostname (api.github.com), client id, and client secret. This will store the information, encrypted, in <code>/=home=/sec/com/github.atom</code>, just as with Basic Authentication. </p><p>Now we need a security driver. Use this: </p><pre>::  Test url +https://api.github.com/user
::
::::  /hoon/github/com/sec
  ::
/+    oauth2
!:
::::
  ::
|_  [bal=(bale keys:oauth2) tok=token:oauth2]
++  scopes                          ::  comment out scopes to taste
  :~  &#39;user&#39;  &#39;user:email&#39;  &#39;user:follow&#39;  &#39;public_repo&#39;  &#39;repo&#39;
      &#39;repo_deployment&#39;  &#39;repo:status&#39;  &#39;delete_repo&#39;  &#39;notifications&#39;
      &#39;gist&#39;  &#39;read:repo_hook&#39;  &#39;write:repo_hook&#39;  &#39;admin:repo_hook&#39;
      &#39;admin:org_hook&#39;  &#39;read:org&#39;  &#39;write:org&#39;  &#39;admin:org&#39;
      &#39;read:public_key&#39;  &#39;write:public_key&#39;  &#39;admin:public_key&#39;
  ==
::  ++aut is a &quot;standard oauth2&quot; core, which implements the
::  most common handling of oauth2 semantics. see lib/oauth2 for more details,
::  and examples at the bottom of the file.
++  aut  (~(standard oauth2 bal tok) . |=(tok/token:oauth2 +&gt;(tok tok)))
++  filter-request
  %^  out-add-query-param:aut  &#39;access_token&#39;
    scope=~[%client %admin]
  oauth-dialog=&#39;https://github.com/login/oauth/authorize&#39;
::
++  receive-auth-query-string
  %-  in-code-to-token:aut
  url=&#39;https://github.com/login/oauth/api/access_token&#39;
++  receive-auth-response  bak-save-token:aut
--
</pre><p>The oauth2 library provides the main “engine” in <code>standard</code>, just like in basic auth, except that we also have to specify a function to save the access token when we get it. It&#39;s worth noting that this library is well documented in the source, including examples: <code>/=home=/lib/oauth2/hoon</code>. </p><p>Running <code>+http://api.github.com/user</code> tries to make a request to Github with authentication. This loads into the bale the keys, which are of type <code>keys:oauth2</code>, defined in the oauth2 library. We don&#39;t have to worry about the specifics of these keys -- the library handles them -- but they include the client id and the client secret. </p><p>Before the request is sent, <code>%eyre</code> calls <code>++filter-request</code> to decorate it with authentication headers. Since we don&#39;t yet have an access token, we need to prompt the user to visit the “dialog” url. <code>++out-add-query-param</code> checks whether we have a token, and if we don&#39;t it produces <code>%show</code> and a message telling the user to visit the <code>oauth-dialog</code> url we provide, with the extra query parameters added (client id, scopes, and state). </p><p>When the user visits that url, Github will ask them to log in and authorize the application. When they do so, Github will post a request to <code>/~/ac/github.com/_state/in</code> with a code in the query string. <code>%eyre</code> sends the query string to <code>++receive-auth-query-string</code>, which is a function that takes a quay and produces a <code>sec-move</code>. <code>++in-code-to-token</code> from our <code>aut</code> takes the <code>code</code> parameter from the quay and uses it to create a request to the given url. This request includes the client id, the client secret, and the code we just got. </p><p>Github&#39;s response to that request includes an access token in its body. This is handled in <code>++receive-auth-response</code>. <code>++bak-save-token</code> extracts that token and gives it to the function that we passed in the definition of <code>++aut</code>. In our case, we just save that token into our state for later usage. </p><p>Now we have the credentials we need, so <code>++filter-request</code> is called with the original request, and <code>++out-add-query-param</code> passes the request through with the addition of the query parameter <code>access_token</code>. </p><p>Just like with Basic Authentication, you should be able to run <code>+https://api.github.com/user</code> and get a response indicating who you&#39;re logged in as. </p><p>Some drivers a slightly more complicated. For example, Github&#39;s access token&#39;s don&#39;t expire, but that&#39;s not the case for all service. The googleapis driver shows the flow when the access token can expire. Twitter uses OAuth1, for which we have another library. </p><p>Remember, of course, that the best strategy for building security drivers is to copy a similar one and tweak it to taste. </p><h2><div id="state">State</div></h2><p>In the last section we built a few small apps that sent moves. These apps were entirely stateless, however. Most useful apps require some amount of state. Let&#39;s build a trivial stateful app. It&#39;ll keep a running the sum of all the atoms we poke it with. Here&#39;s <code>examples/app/sum.hoon</code>: </p><pre>::  Keeps track of the sum of all the atoms it has been
::  poked with and prints the sum out
::
::::  /===/app/sum/hoon
  ::
!:
|%
+$  move  [bone card]
+$  card  $%  $~
          ==
--
|_  [bow=bowl:gall sum=@]
::
++  poke-atom
  |=  tom=@
  ^-  [(list move) _+&gt;.$]
  ~&amp;  sum+(add sum tom)
  [~ +&gt;.$(sum (add sum tom))]
::
++  coup
  |=  [wir=wire err=(unit tang)]
  ^-  [(list move) _+&gt;.$]
  ?~  err
    ~&amp;  sum+success+&#39;Poke succeeded!&#39;
    [~ +&gt;.$]
  ~&amp;  sum+error+&#39;Poke failed. Error:&#39;
  ~&amp;  sum+error+err
  [~ +&gt;.$]
::
--
</pre><p>We can start it with <code>|start %sum</code>, and then run it: </p><pre>~fintud-macrep:dojo&gt; :sum &amp;atom 5
[%sum 5]
&gt;=

~fintud-macrep:dojo&gt; :sum &amp;atom 2
[%sum 7]
&gt;=

~fintud-macrep:dojo&gt; :sum &amp;atom 15
[%sum 22]
&gt;=
</pre><p>We can see that app state is being saved, but when, where, and how? </p><p>The state is stored as the second thing in the <code>|_</code> line. In our case, it&#39;s simply an atom named <code>sum</code>. We change it by producing our state not with <code>+&gt;.$</code> (as before), but with <code>+&gt;.$(sum (add sum tom))</code>. We&#39;ve seen all these parts before, but you might not recognize them. </p><p>Recall in the first chapter that we recursed with the expression <code>$(b (add 3 b))</code>. This meant “produce <code>$</code> with <code>b</code> changed to <code>(add 3 b)</code>. Similarly, <code>+&gt;.$(sum (add sum tom))</code> means ”produce <code>+&gt;.$</code> (i.e. our context, which contains our state) with <code>sum</code> changed to <code>(add sum tom)</code>. </p><p>At a high level, then, when we handle state, we do it explicitly. It&#39;s passed in and produced explicitly. In Unix systems, application state is just a block of memory, which you need to serialize to disk if you want to keep it around for very long. </p><p>In Urbit, app state is a single (usually complex) value. In our example, we have very simple state, so we defined <code>sum=@</code>, meaning that our state is an atom. Of course, <code>sum</code> is just a name, and you&#39;re free to name your state whatever you like. But let&#39;s clarify a couple other things before we continue. </p><p>First, <code>bowl</code> is a set of general global states. This set is managed by the system. It includes things like <code>now</code> (the current time), <code>our</code> (our urbit identity), and <code>eny</code> (512 bits of guaranteed-fresh entropy). For the full list of things in <code>++bowl</code>, search for <code>++ bowl</code> (note: two spaces) in <code>/arvo/zuse.hoon</code>. </p><blockquote><p>This is, perhaps, the most common way to learn Hoon. The easiest way to learn about an identifier you see in code is to search in <code>/arvo/zuse.hoon</code> and <code>/arvo/hoon.hoon</code> for it.\ Urbit&#39;s codebase is less than 30000 lines of code combined, including the hoon parser, the compiler, and the <code>/arvo</code> microkernel, so you can usually use the code and its comments as a reference doc. You can also read <a href="https://github.com/urbit/arvo/blob/master/arvo/zuse.hoon">zuse.hoon</a> and <a href="https://github.com/urbit/arvo/blob/master/arvo/hoon.hoon">hoon.hoon</a> in your browser. </p></blockquote><p>The second thing we should clear up is this: Urbit needs no “serialize to disk” step. Everything you produce in the app state is persistent across calls to the app, restarts of the urbit, and even power failure. If you want to write to the Unix filesystem, you can, but it&#39;s not needed for persistence. Urbit has transactional events, which makes it an <a href="https://en.wikipedia.org/wiki/ACID">ACID operating system</a>. Thus, you don&#39;t have to worry about persistence when programming in Urbit, or ever go through the hassle of having to set up and write to a database. </p><p><b>Exercises</b>: </p><ul><li><p>Modify <code>:sum</code> to reset the counter when you poke it with 0. </p></li><li><p>Write an app called <code>last</code> that prints out the previous value you poked it with. </p></li></ul><p>Sample output: </p><pre>~fintud-macrep:dojo&gt; :last 7
[%last 0]
&gt;=

~fintud-macrep:dojo&gt; :last [1 2 3]
[%last 7]
&gt;=

~fintud-macrep:dojo&gt; :last &#39;howdy&#39;
[%last [1 2 3]]
</pre><h2><div id="subscriptions">Subscriptions</div></h2><p>We&#39;ve dealt fairly extensively with “poke” messages to an app, but these are somewhat limited. A poke is a one-way message, but more often we want to subscribe to updates from another app. You could build a subscription model out of one-way pokes, but it&#39;s such a common pattern that it&#39;s built into Arvo. </p><p>Let&#39;s take a look at two apps, <code>:source</code> and <code>:sink</code>. First, <code>:source</code>: </p><pre>::  Sends subscription updates to sink.hoon
::
::::  /===/app/source/hoon
  ::
!:
::
|%
  +$  move  [bone card]
  +$  card  $%  [%diff diff-contents]
            ==
+$  diff-contents  $%  [%noun *]
                   ==
--
::
|_  [bow=bowl:gall $~]
::
++  poke-noun
  |=  non=*
  ^-  [(list move) _+&gt;.$]
  :_  +&gt;.$
  %+  turn  (prey:pubsub:userlib /example-path bow)
  |=([o=bone *] [o %diff %noun non])
::
++  peer-example-path
  |=  pax=path
  ^-  [(list move) _+&gt;.$]
  ~&amp;  source+peer-notify+&#39;Someone subscribed to you!&#39;
  ~&amp;  source+[ship+src.bow path+pax]
  [~ +&gt;.$]
::
++  coup
  |=  [wir=wire err=(unit tang)]
  ^-  [(list move) _+&gt;.$]
  ?~  err
    ~&amp;  source+success+&#39;Poke succeeded!&#39;
    [~ +&gt;.$]
  ~&amp;  source+error+&#39;Poke failed. Error:&#39;
  ~&amp;  source+error+err
  [~ +&gt;.$]
::
++  reap
  |=  [wir=wire err=(unit tang)]
  ^-  [(list move) _+&gt;.$]
  ?~  err
    ~&amp;  source+success+&#39;Peer succeeded!&#39;
    [~ +&gt;.$]
  ~&amp;  source+error+&#39;Peer failed. Error:&#39;
  ~&amp;  source+error+err
  [~ +&gt;.$]
::
--
</pre><p>Save this as <code>source.hoon</code> in the <code>/app</code> directory of your urbit&#39;s pier. </p><p>And secondly, <code>:sink</code>: </p><pre>::  Sets up a simple subscription to source.hoon
::
::::  /===/app/sink/hoon
  ::
!:
|%
+$  move  [bone card]
+$  card  $%  [%peer wire dock path]
              [%pull wire dock $~]
          ==
--
::
|_  [bow=bowl:gall val=?]
::
++  poke-noun
  |=  non=*
  ^-  [(list move) _+&gt;.$]
  ?:  &amp;(=(%on non) val)
    :_  +&gt;.$(val |)
      :~  :*  ost.bow
          %peer
          /subscribe
          [our.bow %source]
          /example-path
      ==
    ==
  ?:  &amp;(=(%off non) !val)
    :_  +&gt;.$(val &amp;)
    ~[[ost.bow %pull /subscribe [our.bow %source] ~]]
  ~&amp;  ?:  val
        sink+unsubscribed+&#39;You are now unsubscribed!&#39;
      sink+subscribed+&#39;You are now subscribed!&#39;
  [~ +&gt;.$]
::
++  diff-noun
  |=  [wir=wire non=*]
  ^-  [(list move) _+&gt;.$]
  ~&amp;  sink+received-data+&#39;You got something!&#39;
  ~&amp;  sink+data+non
  [~ +&gt;.$]
::
++  coup
  |=  [wir=wire err=(unit tang)]
  ^-  [(list move) _+&gt;.$]
  ?~  err
    ~&amp;  sink+success+&#39;Poke succeeded!&#39;
    [~ +&gt;.$]
  ~&amp;  sink+error+&#39;Poke failed. Error:&#39;
  ~&amp;  sink+error+err
  [~ +&gt;.$]
::
++  reap
  |=  [wir=wire err=(unit tang)]
  ^-  [(list move) _+&gt;.$]
  ?~  err
    ~&amp;  sink+success+&#39;Peer succeeded!&#39;
    [~ +&gt;.$]
  ~&amp;  sink+error+&#39;Peer failed. Error:&#39;
  ~&amp;  sink+error+err
  [~ +&gt;.$]
::
--
</pre><p>Save this as <code>sink.hoon</code> in the <code>/app</code> directory of your urbit&#39;s pier (make sure both <code>source</code> and <code>sink</code> are on the same ship). </p><p>Two notes: </p><ul><li><p><code>bowl</code> is the type of the system state within our app. For example, it includes things like <code>our</code>, the name of the host urbit, and <code>now</code>, the current time. </p></li><li><p>You may have noticed the separate <code>|%</code> above the application core <code>|_</code>. We usually put our types in another core on top of the application core. We can access these type from our <code>|_</code> because in <code>hoon.hoon</code> files, all cores are called against each other. (The shorthand for &#39;called&#39; is <code>=&gt;</code>.) Thus, the <code>|%</code> with the types is in the context of the <code>|_</code>, as it lies above it: <code>hoon.hoon</code> <code>=&gt; |% w types =&gt; |_</code> </p></li></ul><p>Here&#39;s some sample output of the two working together: </p><pre>~fintud-macrep:dojo&gt; |start %source
&gt;=

~fintud-macrep:dojo&gt; |start %sink
&gt;=

~fintud-macrep:dojo&gt; :sink %on
[%source %peer-notify &#39;Someone subscribed to you!&#39;]
[%source [%ship ~fintud-macrep] %path /]
[%sink %success &#39;Peer succeeded!&#39;]
&gt;=

~fintud-macrep:dojo&gt; :source 5
[%sink %received-data &#39;You got something!&#39;]
[%sink %data 5]
&gt;=

~fintud-macrep:dojo&gt; :sink %off
&gt;=

~fintud-macrep:dojo&gt; :source 6
&gt;=

~fintud-macrep:dojo&gt; :sink %on
[%source %peer-notify &#39;Someone subscribed to you!&#39;]
[%source [%ship ~fintud-macrep] %path /]
[%sink %success &#39;Peer succeeded!&#39;]
&gt;=

~fintud-macrep:dojo&gt; :source 7
[%sink %received-data &#39;You got something!&#39;]
[%sink %data 7]
&gt;=
</pre><h6 id="-source-">:source </h6><p>Hopefully you can get a sense for what&#39;s happening here. When we poke <code>:sink</code> with <code>%on</code>, <code>:sink</code> subscribes to <code>:source</code>, and so whenever we poke <code>:source</code>, <code>:sink</code> gets the update and prints it out. Then we unsubscribe by poking <code>:sink</code> with <code>%off</code>, and <code>:sink</code> stops getting updates. We then resubscribe. </p><p>There&#39;s a fair bit going on in this code. Let&#39;s look at <code>:source</code> first. </p><p>Our definition of <code>move</code> is fairly specific, since we&#39;re only going to sending one kind of move. The <code>%diff</code> move is a subscription update, and its content is marked data which gall routes to our subscribers. </p><p>This is a slightly different kind of move than we&#39;ve dealt with so far. It&#39;s producing a result rather than calling other code (i.e. it&#39;s a return rather than a function call), so if you recall the discussion of ducts, a layer gets popped off the duct rather than added to it. This is why no wire is needed for the move -- we won&#39;t receive anything in response to it. </p><p>Anyways, there are four functions (arms) inside the <code>|_</code>. We already know when <code>++poke-noun</code> is called. <code>++peer-example-path</code> is called when someone tries to subscribe to our app. Of course, you don&#39;t just subscribe to an app; you subscribe to a path on that app. This path comes in as the argument to <code>++peer</code>. </p><p>In our case, we don&#39;t care what path you subscribed on, and all we do is print out that you subscribed. Arvo keeps track of your subscriptions, so you don&#39;t have to. You can access your subscribers by looking at <code>sup</code> in the bowl that&#39;s passed in. <code>sup</code> is of type <code>(map bone {@p path})</code>, which associates bones with the urbit who subscribed, and which path they subscribed on. If you want to communicate with your subscribers, send them messages along their bone. </p><p><code>++poke-noun</code> “spams” the given argument to all our subscribers. There&#39;s a few things we haven&#39;t seen before. Firstly, <code>:_(a b)</code> is the same as <code>[b a]</code>. It&#39;s just a convenient way of formatting things when the first thing in a cell is much more complicated than the second. Thus, we&#39;re producing our state unchanged. </p><p>Our list of moves is the result of a call to <code>++turn</code>. <code>++turn</code> is what many languages call “map” -- it runs a function on every item in a list and collects the results in a list. The list is <code>(prey:pubsub:userlib /example-path bow)</code> and the function is the <code>|=</code> line right after it. </p><p><code>prey:pubsub:userlib</code> is a standard library function defined in <code>zuse.hoon</code>. It takes a path and a bowl and gives you a list of the subscribers who are subscribed on a path that begins with the given path. “Prey” is short for “prefix”. </p><p>Now we have the list of relevant subscribers. This a list of triples, <code>[bone @p path]</code>, where the only thing we really need is the bone, because we don&#39;t need to know their urbit or what exact path they subscribed on. Thus, our transformer function takes <code>[o=bone *]</code> and produces <code>[o %diff %noun non]</code>, which is a move that provides bone <code>o</code> with this subscription update: <code>[%noun non]</code>&quot;. This is fairly dense code, but what it&#39;s doing is straightforward! </p><h6 id="-sink-">:sink </h6><p><code>:source</code> should now make sense. <code>:sink</code> is a little longer, but not much more complicated. </p><p>In <code>:sink</code>, our definition of of <code>++move</code> is different. All moves start with a <code>bone</code>, and we conventionally refer to the second half as the “card”, so that we can say a move is an action that sends a card along a bone. </p><p>We have two kinds of cards here: we <code>%peer</code> to start a subscription, and we <code>%pull</code> to stop it. Both of these are “forward” moves that may receive a response, so they need a wire to tack onto the duct before they pass it on. They also need a target, which is a pair of an urbit and an app name. Additionally, <code>%peer</code> needs a path on that app to subscribe too. <code>%pull</code> doesn&#39;t need this, because its semantics are to cancel any subscriptions coming over this duct. If your bone and wire are the same as when you subscribed, then the cancellation will happen correctly. </p><p>The only state we need for <code>:sink</code> is a boolean to indicate whether we&#39;re already subscribed to <code>:source</code>. We use <code>val=?</code>, where <code>?</code> is the sign of type boolean (similar to <code>*</code>, <code>@</code>), which defaults to true (that is, <code>0</code>). </p><p>In <code>++poke-noun</code> we check our input to see both if it&#39;s <code>%on</code> and we&#39;re available (<code>val</code> is true). If so, we produce the move to subscribe to <code>:source</code>: </p><pre>:~  :*  ost.bow
    %peer
    /subscribe
    [our.bow %source]
    /example-path
    ==
==
</pre><p>Also, in the preceding lines, we set <code>val</code> to false (<code>|</code>) with <code>+&gt;.$(val |)</code>. Remember that the <code>:_</code> constructs an inverted cell, with the first child (<code>+&gt;.$(val |</code> in our case) as the tail and the second child as the head. Here, the cell we produce when our subscription is <code>%on</code> and <code>val</code> is true has a head with our new state where <code>val</code> is set to false and a tail of our list of moves, which is shown in the code block above. </p><p>Otherwise, if our input is <code>%off</code> and we&#39;re already subscribed (i.e. <code>val</code> is false), then we unsubscribe from <code>:source</code> and set <code>val</code> back to true (<code>&amp;</code>), again using our handy inverted cell constructor mold <code>:_</code>: </p><pre>:_  +&gt;.$(val &amp;)
~[[ost.bow %pull /subscribe [our.bow %source] ~]]
</pre><p>It&#39;s important to send over the same bone and wire (<code>/subscribe</code>) as the one we originally subscribed on. </p><p>If neither of these cases are true, then we print our current subscription state, based on whether <code>val</code> is true or false, and return a cell containing a null list of moves and our unchanged app state: </p><pre>~&amp;  ?:  val
      sink+unsubscribed+&#39;You are now unsubscribed!&#39;
    sink+subscribed+&#39;You are now subscribed!&#39;
[~ +&gt;.$]
</pre><p><code>++diff-noun</code> is called when we get a <code>%diff</code> update along a subscription with a mark of <code>noun</code>. <code>++diff-noun</code> is given the wire that we originally passed with the <code>%peer</code> subscription request along and the data we got back. In our case we just print out the data: </p><pre>~&amp;  sink+received-data+&#39;You got something!&#39;
~&amp;  sink+data+non
</pre><p><code>++reap</code> is called when we receive an acknowledgment as to whether the subscription was handled successfully. You can remember that <code>++reap</code> is the counterpart to <code>++peer</code> as it&#39;s pronounced like &#39;peer&#39; backwards. Similarly, <code>coup</code> is similar to &#39;poke&#39; backwards. </p><p>Moving forward, <code>++reap</code> is given the wire we attempted to subscribe over, possibly along with an error message in cases of failure. <code>(unit type)</code> means “either <code>~</code> or <code>[~ type]</code>, which means it&#39;s used like Haskell&#39;s ”maybe&quot; or C&#39;s nullability. If <code>err</code> is <code>~</code>, then the subscription was successful and we tell that to the user. Otherwise, we print out the error message. </p><h2><div id="backend">Backend</div></h2><p>We&#39;ve done purely functional web pages as hook files, and we&#39;ve done command line apps, so now let&#39;s interact with an app over the web. The fundamental concepts are no different than from the command line -- you send “poke” messages to apps and subscribe to data streams. The only difference is that you do it with javascript. </p><p>Let&#39;s create a small web app that counts the number of times you poke it. There&#39;ll be a button to poke the app, and line of text below it saying how many times the app has been poked. We can update this by subscribing our page to the relevant path on its app. </p><p>Save the following as <code>click.hoon</code> in the <code>/app</code> directory of your urbit&#39;s pier. </p><pre>/?    314
!:
|%
++  move  [bone %diff %mark *]
--
!:
|_  [hid=bowl:gall clicks=@]
++  poke-click
  |=  click=%click
  ~&amp;  [%poked +(clicks)]
  :_  +&gt;.$(clicks +(clicks))
  %+  turn  (prey:pubsub:userlib /the-path hid)
  |=([o=bone *] [o %diff %clicks +(clicks)])
++  peer-the-path
  |=  pax=path
  [[[ost.hid %diff %clicks clicks] ~] +&gt;.$]
--
</pre><p>There&#39;s nothing really new here, except that we use a couple of new marks, <code>click</code> and <code>clicks</code>. When we get poked with a <code>click</code>, we increment the variable <code>clicks</code> in our state and tell all our subscribers the new value. When someone subscribes to us on the path <code>/the-path</code>, we immediately give them the current number of clicks. </p><p>Let&#39;s take a look at the new marks. Save this as <code>/mar/click.hoon</code>: </p><pre>|_  click=%click
++  grab
  |%
  ++  noun  |=(* %click)
  ++  json
    |=  jon=^json
    ?&gt;  =(&#39;click&#39; (need (so:dejs-soft:format jon)))
    %click
  --
--
</pre><p>The mark <code>click</code> has type <code>%click</code>, which means the only valid value is <code>%click</code>. We can convert from <code>noun</code> by just producing <code>%click</code>. </p><p>We also convert from json by parsing a json string with <code>so:dejs-soft:format</code>, asserting the parsing succeeded with <code>need</code>, and asserting the result was &#39;click&#39; with <code>?&gt;</code>, which asserts that its first child is true. </p><blockquote><p>Note the argument to <code>++json</code>is <code>jon=^json</code>. Why <code>^json</code>? <code>++json</code> shadows the type definition, so if we want to refer to the type, we have to prepend a <code>^</code>. This extends to multiple levels: <code>^^^foo</code> means the fourth most innermost instance of <code>foo</code>. </p></blockquote><blockquote><p><code>dejs-soft:format</code> in <code>zuse</code> is a useful library for parsing complex json into hoon structures. In this case, the <code>:</code> between <code>dejs-soft</code> and <code>format</code> means &#39;inside of&#39;, because <code>dejs-soft</code> is an arm contained within the core <code>format</code>. Our case is actually simple enough that the <code>?&gt;</code> line could have been <code>?&gt; =([%s &#39;click&#39;] jon)</code>. </p></blockquote><p>We can test this mark from the command line (don&#39;t forget to start your app with <code>|start %click</code>) </p><pre>~fintud-macrep:dojo&gt; &amp;click %click
%click

~fintud-macrep:dojo&gt; &amp;click &amp;json [%s &#39;click&#39;]
%click

~fintud-macrep:dojo&gt; &amp;click &amp;json &amp;mime [/text/json (as-octs:mimes:html &#39;&quot;click&quot;&#39;)]
%click

~fintud-macrep:dojo&gt; &amp;click &amp;json &amp;mime [/text/json (as-octs:mimes:html &#39;&quot;clickety&quot;&#39;)]
/~fintud-macrep/home/0/mar/click:&lt;[7 5].[8 11]&gt;
ford: casting %json to %click
ford: cast %click
</pre><p>And save the following as <code>/mar/clicks.hoon</code>: </p><pre>|_  clicks=@
++  grab
  |%
  ++  noun  @
  --
++  grow
  |%
  ++  json
    (frond:enjs:format %clicks (numb:enjs:format clicks))
  --
--
</pre><p><code>clicks</code> is just an atom. We convert to json by creating an object with a single field “clicks” with our value. </p><blockquote><p>Be sure to check out section 3bD, JSON and XML, in zuse.hoon <code>frond:enjs:format</code> is just a function that takes a key-value pair and produces a JSON object with one element. </p></blockquote><pre>~fintud-macrep:dojo&gt; &amp;json &amp;clicks 6
[%o p={[p=&#39;clicks&#39; q=[%n p=~.6]]}]
</pre><p>Now that we know the marks involved, take another look at the app above. Everything should be pretty straightforward. Let&#39;s poke the app from the command line. </p><pre>~fintud-macrep:dojo&gt; |start %click
&gt;=
~fintud-macrep:dojo&gt; :click &amp;click %click
[%poked 1]
&gt;=
~fintud-macrep:dojo&gt; :click &amp;click %click
[%poked 2]
&gt;=
</pre><p><b>Exercise</b>: </p><ul><li><p>Modify <code>:sink</code> from the subscriptions chapter to listen to <code>:click</code> and print out the subscription updates on the command line. </p></li></ul><h2 id="frontend-">Frontend </h2><blockquote><p>Note: the instructions below are outdated and do not work in the current version of Urbit. Feel free to experiment though. </p></blockquote><p>That&#39;s all that&#39;s needed for the back end. The front end is just some “sail” html (Hoon markup for XML) and javascript. Here&#39;s <code>/web/pages/click.hoon</code>: </p><pre>;html
  ;head
    ;script(type &quot;text/javascript&quot;, src &quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js&quot;);
    ;script(type &quot;text/javascript&quot;, src &quot;/~/at/lib/js/urb.js&quot;);
    ;title: Clickety!
  ==
  ;body
    ;div##cont
      ;input##go(type &quot;button&quot;, value &quot;Poke!&quot;);
      ;div##err(class &quot;disabled&quot;);
      ;div##clicks;
    ==
    ;script(type &quot;text/javascript&quot;, src &quot;/pages/click/click.js&quot;);
  ==
==
</pre><p>You should recognize the sail syntax from an earlier chapter. Aside from jquery, we also include <code>urb.js</code>, which is a framework for interacting with urbit. </p><p>To view the frontend, point your browser at <code>ship-name.urbit.org/~~/pages/click</code> if you&#39;re on the live network. If you&#39;re running a fake galaxy, navigate to whatever port it&#39;s running on, which is usually: <code>https://localhost:80/~~/pages/click</code>. </p><p>We have a button labeled “Poke!” and a div with id <code>clicks</code> where we&#39;ll put the number of clicks. We also include a small javascript file where the client-side application logic can be found. It&#39;s in <code>/web/pages/click.js</code>: </p><pre>$(function() {
  var clicks, $go, $clicks, $err

  $go     = $(&#39;##go&#39;)
  $clicks = $(&#39;##clicks&#39;)
  $err    = $(&#39;##err&#39;)

  $go.on(&quot;click&quot;,
    function() {
      window.urb.send(
        &quot;click&quot;, {mark: &quot;click-click&quot;}
      ,function(err,res) {
        if(err)
          return $err.text(&quot;There was an error. Sorry!&quot;)
        if(res.data !== undefined &amp;&amp;
           res.data.ok !== undefined &amp;&amp;
           res.data.ok !== true)
          $err.text(res.data.res)
        else
          console.log(&quot;poke succeeded&quot;);
      })
  })

  window.urb.appl = &quot;click&quot;
  window.urb.bind(&#39;/the-path&#39;,
    function(err,dat) {
      clicks = dat.data.clicks
      $clicks.text(clicks)
    }
  )
})
</pre><p>We set up two event handlers. When we click the button, we run <code>window.urb.send</code>, which sends a poke to the app specified as the first argument, in this case our :click app. The arguments are data, parameters, and the callback. The data is the specific data we want to send. The parameters are all optional, but here&#39;s a list of the available ones: </p><ul><li><p><code>ship</code>: target urbit. Defaults to <code>window.urb.ship</code>, which defaults to the urbit which served the page. </p></li><li><p><code>appl</code>: target app. Defaults to <code>window.urb.appl</code>, which defaults to null. </p></li><li><p><code>mark</code>: mark of the data. Defaults to <code>window.urb.send.mark</code>, which defaults to “json”. </p></li><li><p><code>wire</code>: wire of the poke. Defaults to <code>/</code>. </p></li></ul><p>In our case, we specify only that the mark is “click”. </p><p>The callback function is called when we receive an acknowledgment. If there was an error, we put it in the <code>err</code> div that we defined above. Otherwise, we printf to the console a message saying the poke succeeded. As is common, we gray out the button when it is clicked. It is only reenabled when positive acknowledgement is received. </p><p>Our second event handler is <code>window.urb.bind</code>, which is called immediately when the page is loaded, subscribing the page to the specified data stream on the app set with <code>urb.appl</code> (which is, in this case, :click). It also takes three arguments: path, parameters, and callback. The path is the path on the app to subscribe to. The parameters are all optional (indeed, we omit them entirely here), but are similar to those for <code>send</code>: </p><ul><li><p><code>ship</code>: target urbit. Defaults to <code>window.urb.ship</code>, which defaults to the urbit which served the page. </p></li><li><p><code>appl</code>: target app. Defaults to <code>window.urb.appl</code>, which defaults to null. </p></li><li><p><code>mark</code>: mark of expected data. Data of other marks is converted to this mark on the server before coming to the web front end. Defaults to <code>window.urb.bind.mark</code>, which defaults to “json”. </p></li><li><p><code>wire</code>: wire of the subscription. Defaults to the given path. </p></li></ul><p>The callback function here just updates the data in the <code>clicks</code> div. A truly robust app would intelligently handle errors, of course. </p><p>Note that the app doesn&#39;t have anything web-specific in itself. As far as it knows, it&#39;s just receiving pokes and subscriptions. The javascript is fairly pure as well, sending and receiving json everywhere. The marks are the translation layer, and they&#39;re the only things that need to know how the hoon types map to json. </p><p><b>Exercise</b>: </p><ul><li><p>Open the app in multiple tabs, click the button, and verify that all the tabs stay in sink. Poke it manually from the command line and verify the tabs are updated as well. </p></li></ul></div></div></div></div></div><footer class="mb-36"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>