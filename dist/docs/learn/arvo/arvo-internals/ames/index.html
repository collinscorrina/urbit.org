<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Docs</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div id="sidebar-mobile" class="bg-gray-light sidebar-hide overflow-y"><div class="container"><div class="col-sm-10"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div><div class="col-sm-1 sidebar-toggle fixed" style="top: 20px; right: 1em"><img class="w-8 h-8 dropdown-right" src="/assets/dropdown.svg" /></div></div></div><div class="container mt-10"><div class="sidebar-container row col-sm-3 fixed pb-30 h-100-md"><div class="col-sm-3 col-lg-6 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-12 mt-7 sidebar-toggle md-hide"><img class="w-8 h-8 dropdown-left" src="/assets/dropdown.svg" /></div><div class="h-100 col-sm-8 col-md-11 overflow-y sm-hide"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-2 col-md-offset-3 docs"><div><div><h1 id="ames-">Ames </h1><p>Our networking protocol. </p><p><code>%ames</code> is the name of both our network and the vane that communicates over it. When Unix receives a packet over the correct UDP port, it pipes it straight into <code>%ames</code> for handling. Also, all packets sent over the <code>%ames</code> network are sent by the <code>%ames</code> vane. Apps and vanes may use <code>%ames</code> to directly send messages to other ships. In general, apps use gall and clay to communicate with other ships rather than using <code>%ames</code> directly, but this isn&#39;t a requirement. Of course, gall and clay use <code>%ames</code> behind the scenes to communicate across the network. These are the only two vanes that use <code>%ames</code>. </p><p><code>%ames</code> includes several significant components. Although the actual crypto algorithms are defined in zuse, they&#39;re used extensively in <code>%ames</code> for encrypting and decrypting packets. Congestion control and routing is handled entirely in <code>%ames</code>. Finally, the actual <code>%ames</code> protocol itself, including how to route incoming packets to the correct vane or app, is defined in <code>%ames</code>. </p><h2><div id="commentary">Commentary</div></h2><p><code>%ames</code> is our networking protocol. </p><p>First we give commentary on the code, the algorithms involved, and the protocol. We trace through the code touched when a packet is sent, received, acknowledged, and that acknowledgment applied. This is fairly comprehensive, and contains many implementation details, but if you understand this, then you understand <code>%ames</code>. </p><p>If you&#39;ve scrolled down this page, you may be intimidated by the amount of Hoon code, especially if you are new to the language. Don&#39;t be afraid of it, you don&#39;t have to read any of it if you don&#39;t want to -- every interesting action the code takes is explained in plain English. In fact, if you are new to the language, this may be a good learning opportunity. Even if you don&#39;t understand every line of Hoon code, you&#39;ll hopefully be able to follow most lines. By the time you&#39;ve worked through this, you&#39;ll have seen many common patterns and best practices. Hoon, much more than other languages, is best learned by reading and understanding large quantities of existing code. In this way, it is similar to learning a natural language. All of this code is in <code>arvo/ames.hoon</code>. </p><p>After the commentary, we have reference documentation for all the data structures that are specific to <code>%ames</code>. If you see a data structure or a variable used that you don&#39;t recognize, search for it in the code, and it&#39;s very likely defined in one of these data structures. We recommend that another tab is kept open for easy access to the data structure reference documentation. The code for these is split between <code>arvo/ames.hoon</code> and <code>arvo/zuse.hoon</code>. </p><p>The Lifecycle of a Packet (or, How a Packet Becomes Law) </p><hr /><p>Here, we will trace a packet as it makes its way through ames. There are actually two pathways through ames: the legacy path through <code>%want</code>, and the modern way, entered through <code>%wont</code>, with full end-to-end acknowledgments. Here we will only trace the modern way, though much of the path is the same for both. </p><p>When an app (or a vane) wishes to send a packet to another ship, it must send a <code>%wont</code> card: </p><pre>                  [%wont p=sock q=path r=*]                 ::  e2e send message
</pre><p>This card takes three arguments. The <code>p</code> is a <code>sock</code>, that is, a pair of two ships, the first of which is the sender and the second is the receiver. But wait, you ask, why do I get to decide who is the sender? Can I fake like I&#39;m someone else? The reason is that there are potentially multiple ships on the same pier, and the kernel can send a message from any of them. If you attempt to send a message from a ship not on your pier, then ames will refuse to send it. If you hack around in your own copy of ames to go ahead and send it anyway, then the other ship will reject it because your key is bad. Only send messages from yourself. </p><p>The <code>q</code> is a path, representing the place on the other side that you want to receive your message. It is approximately equivalent to a port number. Messages on the same path are guaranteed to arrive in the same order as they were sent. No such guarantees are made across paths. </p><p>The <code>r</code> is the actual data that you are sending. As the type implies, this can be an arbitrary noun, and it will be transferred to the receiver exactly as-is, in a well-typed way. Of course, this is data that is sent over the wire, so be careful not to send anything too massive unless you&#39;re willing to wait. </p><p>But enough about the interface. Grepping in ames.hoon for <code>%wont</code>, we find that it appears in <code>++knob</code>. We see that we go directly into <code>++wise:am</code>. </p><pre>        ++  wise                                            ::    wise:am
          |=  [soq=sock hen=duct cha=path val=* ete=?]      ::  send a statement
          ^-  [p=(list boon) q=fort]
          zork:zank:(wool:(ho:(um p.soq) q.soq) hen cha val ete)
</pre><p>The inputs to this gate are exactly the sort of thing you&#39;d expect. In particular, everything in the <code>%wont</code> gate is here plus the calling duct so that we know where to send the acknowledgment and <code>ete</code> to determine if we&#39;re going to do the modern end-to-end acknowledgments. </p><p>The actual line of code looks intimidating, but it&#39;s really not all that bad. Working from the inside out, the call to <code>++um</code> sets up our domestic server, and the call to <code>++ho</code> sets up our knowledge about the neighbor we&#39;re sending to. From the outside, <code>++zork</code> and <code>++zank</code> just apply the changes made to our <code>++um</code> and <code>++am</code> cores, respectively. If you&#39;re familiar with the common idiom of <code>++abet</code>, that&#39;s all this is. The code predates the widespread usage of that name. </p><p>The interesting part, then, is in <code>++wool:ho:um:am</code>. Let&#39;s look at the code. </p><pre>            ++  wool                                        ::    wool:ho:um:am
              |=  [hen=duct cha=path val=* ete=?]           ::  send a statement
              ^+  +&gt;
              =+  ^=  rol  ^-  rill
                  =+  rol=(~(get by ryl.bah) cha)
                  ?~(rol *rill u.rol)
              =+  sex=sed.rol
              ::  ~&amp;  [%tx [our her] cha sex]
              =.  ryl.bah
                  %+  ~(put by ryl.bah)  cha
                  rol(sed +(sed.rol), san (~(put by san.rol) sex hen))
              =+  cov=[p=p:sen:gus q=clon:diz]
              %+  wind  [cha sex]
              ?:  ete
                [%bund q.cov cha sex val]
              [%bond q.cov cha sex val]
</pre><p>This is slightly more complicated, but it&#39;s still not all that bad. Our inputs, at least, are fairly obvious. </p><p>If you glance at the code for a second, you&#39;ll see that <code>++wind:ho:um:am</code> seems to be able to send a message, or <code>++meal:ames</code>, given a <code>++soup</code>. This gate, then, just sets up the things we need to for <code>++wind</code> to do its job. </p><p>We first get <code>rol</code>, which is a <code>++rill:ames</code>, that is, a particular outbound stream. This stream is specific to the path on which we&#39;re sending. If the path hasn&#39;t been used before, then we create it. We let <code>sex</code> be the number of messages we&#39;ve already sent on this path. </p><p>Then, we update the outbound stream by incrementing the number of messages sent and placing an entry in <code>san.rol</code> that associates the message number with the <code>duct</code> that sent the message. This allows us to give the acknowledgment to the one who sent the message. </p><p>We let <code>cov</code> be the current life of our crypto and our neighbor&#39;s crypto. At the moment, we only need our neighbor&#39;s life, which we put into the meal. </p><p>Finally, we call <code>++wind:ho:um:am</code> with the <code>++soup</code> of the path and message number and the <code>++meal:ames</code> of the payload itself. For end-to-end acknowledged messages, we use <code>%bund</code>. </p><pre>                  [%bund p=life q=path r=@ud s=*]           ::  e2e message
</pre><p>Looking at how we create the <code>%bund</code>, we can easily see what each field is for. </p><p>Following the trail a little further, we go to <code>++wind:ho:um:am</code>. </p><pre>            ++  wind                                        ::    wind:ho:um:am
              |=  [gom=soup ham=meal]
              ::  ~&amp;  [%wind her gom]
              ^+  +&gt;
              =^  wyv  diz  (zuul:diz now ham)
              =^  feh  puz  (whap:puz now gom wyv)
              (busk xong:diz feh)
</pre><p><code>++wind</code> does three things: it (1) encodes the message into a list of possibly-encrypted packets, (2) puts the message into the packet pump, and (3) sends any packets that are ready to be sent. Yes, our nice little linear run of each gate calling exactly one other interesting gate is over. We&#39;ll go in order here. </p><p><code>++zuul:lax:as:go</code> is the what converts a <code>++meal:ames</code> into a list of actual, 1KB packets. </p><pre>            ++  zuul                                        ::    zuul:lax:as:go
              |=  [now=@da ham=meal]                        ::  encode message
              ^-  [p=(list rock) q=_+&gt;]
              =&lt;  weft
              ++  wasp                                      ::  null security
              ++  weft                                      ::  fragment message
              ++  wisp                                      ::  generate message
</pre><p>For organizational purposes, <code>++zuul</code> constructs an internal core with three arms. <code>++wasp</code> encodes the meal into an atom with no encryption. <code>++wisp</code> encodes a meal with possible encryption (else it simply calls <code>++wasp</code>). <code>++weft</code> takes the result of <code>++wisp</code> and splits it into actual packets. </p><pre>              ++  wasp                                      ::  null security
                ^-([p=skin q=@] [%none (jam ham)])
</pre><p>This simply jams the meal, wrapping it with the <code>skin</code> of <code>%none</code>, meaning no encryption. </p><p>Since <code>++wisp</code> is a little long, we&#39;ll go through it line-by-line. </p><pre>              ++  wisp                                      ::  generate message
                ^-  [[p=skin q=@] q=_..wisp]
</pre><p><code>++wisp</code> produces a pair of a <code>skin</code> and an atom, which is the meal encoded as a single atom and possibly encrypted. </p><pre>                ?:  =(%carp -.ham)
                  [wasp ..wisp]
</pre><p>If the meal that we&#39;re encoding is a <code>%carp</code>, then we don&#39;t encrypt it. A <code>%carp</code> meal is a partial meal, used when a message is more than 1KB. Since the entire message is already encrypted, we don&#39;t need to encrypt each packet individually again. </p><pre>                ?:  !=(~ yed.caq.dur)
                  ?&gt;  ?=(^ yed.caq.dur)
                  :_  ..wisp
                  :-  %fast
                  %^  cat  7
                    p.u.yed.caq.dur
                  (en:r:cluy q.u.yed.caq.dur (jam ham))
</pre><p>If we have a symmetric key set up with this neighbor, then we simply use it. The skin <code>%fast</code> is used to indicate a symmetric key. </p><pre>                ?:  &amp;(=(~ lew.wod.dur) |(=(%back -.ham) =(%buck -.ham)))
                  [wasp ..wisp]
</pre><p>If we do not yet have our neighbor&#39;s will, then there is no way that we can seal the message so that only they may read it. If what we&#39;re sending is an acknowledgment, then we go ahead and just send it in the clear. </p><pre>                =^  tuy  +&gt;.$
                  ?:(=(~ lew.wod.dur) [*code +&gt;.$] (griz now))
</pre><p>If we don&#39;t have our neighbor&#39;s will, then we “encrypt” with a key of 0. If we do have their will, then we generate a new symmetric key that we will propose. </p><pre>                :_  ..wisp
                =+  yig=sen
                =+  bil=law.saf                             ::  XX send whole will
                =+  hom=(jam ham)
</pre><p><code>yig</code> will be the life and engine for our current crypto. <code>bil</code> is our will. <code>hom</code> is the meal encoded as a single atom. </p><pre>                ?:  =(~ lew.wod.dur)
                  :-  %open
                  %^    jam
                      [~ `life`p.yig]
                    bil
                  (sign:as:q.yig tuy hom)
</pre><p>If we do not have our neighbor&#39;s will, then we send our current life along with our will and the message. The message itself is “signed” with a key of 0. </p><pre>                :-  %full
                  =+  cay=cluy
                  %^    jam
                      [`life`p.cay `life`p.yig]
                    bil
                  (seal:as:q.yig pub:ex:r.cay tuy hom)
              --                                            ::  --zuul:lax:as:go
</pre><p>If we do have our neighbor&#39;s will, then we send our perception of their current life, our current life, our will, and the message. The message is sealed with their public key so that only they can read our message. </p><p>Once we have the message encoded as an atom, <code>++weft</code> goes to work. </p><pre>              ++  weft                                      ::  fragment message
                ^-  [p=(list rock) q=_+&gt;.$]
                =^  gim  ..weft  wisp
                :_  +&gt;.$
                ^-  (list rock)
</pre><p>We&#39;re going to produce a list of the packets to send. First, we use the aforementioned <code>++wisp</code> to get the message as an atom. </p><pre>                =+  wit=(met 13 q.gim)
                ?&lt;  =(0 wit)
</pre><p><code>wit</code> is the number of 1KB (2^13 bit) blocks in the message. We assert that there is at least one block. </p><pre>                ?:  =(1 wit)
                  =+  yup=(spit [our her] p.gim q.gim)
                  [yup ~]
</pre><p>If there is exactly one block, then we just call <code>++spit</code> to turn the message into a packet. We&#39;ll explain what <code>++spit</code> does momentarily. </p><pre>                =+  ruv=(rip 13 q.gim)
                =+  gom=(shaf %thug q.gim)
                =+  inx=0
</pre><p>If there is more than one block, then we rip it into blocks in <code>ruv</code>. <code>gom</code> is a hash of the message, used as an id. <code>inx</code> is the number of packets we&#39;ve already made. </p><pre>                |-  ^-  (list rock)
                ?~  ruv  ~
                =+  ^=  vie
                    %+  spit
                      [our her]
                    wasp(ham [%carp (ksin p.gim) inx wit gom i.ruv])
                :-  vie
                $(ruv t.ruv, inx +(inx))
</pre><p>Here we package each block into a packet with <code>++spit</code> and produce the list of packets. </p><pre>      ++  spit                                              ::  cake to packet
        |=  kec=cake  ^-  @
        =+  wim=(met 3 p.p.kec)
        =+  dum=(met 3 q.p.kec)
        =+  yax=?:((lte wim 2) 0 ?:((lte wim 4) 1 ?:((lte wim 8) 2 3)))
        =+  qax=?:((lte dum 2) 0 ?:((lte dum 4) 1 ?:((lte dum 8) 2 3)))
        =+  wix=(bex +(yax))
        =+  vix=(bex +(qax))
        =+  bod=:(mix p.p.kec (lsh 3 wix q.p.kec) (lsh 3 (add wix vix) r.kec))
        =+  tay=(ksin q.kec)
        %+  mix
          %+  can  0
          :~  [3 1]
              [20 (mug bod)]
              [2 yax]
              [2 qax]
              [5 tay]
          ==
        (lsh 5 1 bod)
</pre><p>This is how we turn a message into a real packet. This has the definition of the packet format. </p><p><code>wim</code> is the length of the sending ship, and <code>dum</code> is the length of the receiving ship. There are only five possibilities for each of those, corresponding to carriers, cruisers, destroyers, yachts, and submarines. These are encoded in <code>yax</code> and <code>qax</code> as 0, 0, 1, 2, and 3, respectively. Thus, <code>wix</code> and <code>vix</code> are the number of bytes that must be reserved for the ship names in a packet. </p><p>Next, we construct <code>bod</code> by simply concatenating the sending ship, the receiving ship, and the body of the message. Then, we get the encryption mechanism from <code>++skin:ames</code>, which may be a 0, 1, 2, or 3, and put it in <code>tay</code>. </p><p>Next, we concatenate together, bit by bit, some final metadata. We use three bits for our protocol number, which is incremented modulo eight when there is a continuity breach or the protocol changes. We use the final twenty bits of a hash of the body (which, we suppose, makes it a twenty bit hash) for error-checking. We use two bits to tell how much room is used in the body for the sending ship, and another two bits for the receiving ship. Finally, we use five bits to store the encryption type. Note that since there are only two bits worth of encryption types, there are three unused bits here. This adds up to 32 bits of header data. Finally, we concatenate this onto the front of the packet. Thus, we can summarize the packet header format as follows. </p><pre>     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |Proto|             Hash of Body              |yax|qax| Crypto  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><p>After this, there are <code>yax</code> bits of the sender name, <code>qax</code> bits of the receiver name, and up to 8192 bits of data. Thus, the maximum size of a packet is achieved in a message between two submarines with 8192 bits of data. This will require 32+128+128+8192 = 8480 bits, or 1060 bytes. </p><p>This concludes our discussion of <code>++zuul:lax:as:go</code>. If you recall from <code>++wind:ho:um:am</code>, the list of packets from <code>++zuul</code> is passed into <code>++whap:pu</code> to update the packet pump and get any packets that can be sent immediately. </p><pre>        ++  whap                                            ::    whap:pu
          |=  [now=@da gom=soup wyv=(list rock)]            ::  send a message
          ^-  [(list rock) _+&gt;]
          =.  pyz  (~(put by pyz) gom (lent wyv))
          =.  +&gt;
            |-  ^+  +&gt;.^$
            ?~  wyv  +&gt;.^$
            %=  $
              wyv  t.wyv
              nus  +(nus)
              diq  (~(put by diq) (shaf %flap i.wyv) nus)
              puq  (~(put to puq) [nus `soul`[gom 0 | ~2000.1.1 i.wyv]])
            ==
          (harv now)
</pre><p>First, we put into <code>pyz</code> the id for this message and the number of its packets that have not yet been acknowledged, which is of course the total number of packets since we haven&#39;t even sent the packets. </p><p>For every packet, we change three things in the state (<code>++shed:ames</code>) of our packet pump: (1) we increment <code>nus</code>, the number of packets sent; (2) we put the packet number into <code>diq</code> keyed by a hash of the packet; and (3) we put the packet into the packet queue, with the basic metadata of its id <code>gom</code>, 0 transmissions, not live yet, last sent in the year 2000, and the packet itself. </p><p>Finally, we harvest the packet pump. </p><pre>        ++  harv                                            ::    harv:pu
          |=  now=@da                                       ::  harvest queue
          ^-  [(list rock) _+&gt;]
          ?:  =(~ puq)  [~ +&gt;(rtn ~)]
          ?.  (gth caw nif)  [~ +&gt;]
          =+  wid=(sub caw nif)
          =|  rub=(list rock)
          =&lt;  abet  =&lt;  apse
          |%
</pre><p><code>++harv</code> contains a core for most of its work. The meat is in <code>++apse</code>. First, though, it sets itself up. If there aren&#39;t any packets in the queue, then we simply do nothing except set <code>rtn</code>, our next timeout, to nil because we don&#39;t have any packets that may need to be retransmitted. If we have more live (that is, sent and unacknowledged) packets than our window size, then we don&#39;t do anything. </p><p>Otherwise, we let <code>wid</code> be the width of our remaining packet window, and we initialize <code>rub</code> to nil. <code>rub</code> will be the list of packets that are ready to be sent. We then call <code>++apse</code> and pass the result to <code>++abet</code>. <code>++apse</code> decides which packets are ready to be sent. </p><pre>          ++  apse
            ^+  .
            ?~  puq  .
            ?:  =(0 wid)  .
            =&gt;  rigt  =&lt;  left
            ?&gt;  ?=(^ puq)
            ?:  =(0 wid)  .
            ?.  =(| liv.q.n.puq)  .
            ::  ~&amp;  [%harv nux.q.n.puq p.n.puq]
            %_    .
              wid          (dec wid)
              rub          [pac.q.n.puq rub]
              nif          +(nif)
              liv.q.n.puq  &amp;
              nux.q.n.puq  +(nux.q.n.puq)
              lys.q.n.puq  now
            ==
</pre><p>If there are no remaining packets to send, or if we&#39;ve filled the packet window, do nothing. We call <code>++rigt</code> and <code>++left</code> to process the left and right branches of the packet queue. </p><p>Now we assert that the queue is not empty, and we again check that we haven&#39;t filled the packet window. We will operate on the head of the queue. If the packet is live, then do nothing. Otherwise, we go ahead and send it. </p><p>To send, we (1) decrement <code>wid</code>, our packet window width; (2) cons the packet onto the <code>rub</code>, which will be returned as the list of packets to send; (3) increment <code>nif</code>, the number of live packets; (4) set the packet to be live; (5) increment the number of transmissions of the packet; and (6) set the last sent time of the packet to now. </p><pre>          ++  left
            ?&gt;  ?=(^ puq)
            ^+(. =+(lef=apse(puq l.puq) lef(puq [n.puq puq.lef r.puq])))
          ++  rigt
            ?&gt;  ?=(^ puq)
            ^+(. =+(rig=apse(puq r.puq) rig(puq [n.puq l.puq puq.rig])))
</pre><p>These do exactly what you would expect: they traverse the packet queue so that <code>++apse</code> gets called recursively through it. </p><p>Finally, <code>++abet</code> gets called, which resolves the changes. </p><pre>          ++  abet
            ?~  rub  [~ +&gt;.$]
            [(flop rub) +&gt;.$(rtn [~ (add rto now)])]
</pre><p>This returns the packets that we wish to send, and it updates the timeout so that we know when to try resending unacknowledged packets. </p><p>This concludes our discussion of <code>++whap:pu</code>. To finish <code>++wind:ho:um:am</code>, we just need to delve into <code>++busk:ho:um:am</code>. But wait, in the call to <code>++busk</code>, the first argument is <code>xong:diz</code>. What is this? This, my dear reader, is one more detour, this time into <code>++xong:lax:as:go</code>. </p><pre>            ++  xong                                        ::    xong:lax:as:go
              ^-  (list ship)                               ::  route unto
              =+  [fro=xen too=xeno]
              =+  ^=  oot  ^-  (list ship)
                  =|  oot=(list ship)
                  |-  ^+  oot
                  ?~  too  ~
                  ?:  (lien fro |=(a=ship =(a i.too)))  ~
                  [i.too $(too t.too)]
              ::  ~&amp;  [%xong-to [our her] (weld oot ?&gt;(?=(^ fro) t.fro))]
              (weld oot ?&gt;(?=(^ fro) t.fro))
</pre><p>This gets the list of intermediate ships needed to get a packet from us to our neighbor. First, we get <code>fro</code> and <code>too</code>, the “canons” of ourself and our neighbor, respectively. </p><p>What is this “canon”, you ask? A canon is simply a ship plus its “ancestors”, as defined by <code>++sein:title</code>. For example, the canon of <code>~hoclur-bicrel</code> is: </p><pre>    ~hoclur-bicrel/try=&gt; (saxo:title ~hoclur-bicrel)
    ~[~hoclur-bicrel ~tasruc ~tug]
</pre><p>If we follow the algorithm in <code>++xong</code>, we see that we are simply creating a list of ships that form a path from our neighbor to ourself. Essentially, we look through the canon of our neighbor until we find something in our own cannon -- a common ancestor. Or, if we are from different carriers, then there is no common ancestor. We then weld this onto the tail of our own canon. In the end, this is simply a list of possible ships to try to route via to get to our neighbor, ordered by preferability (that is, closeness to our neighbor). We will end up trying, in order, to find a lane to these. </p><p>Now, we can finally get to <code>++busk:ho:um:am</code>. </p><pre>            ++  busk                                        ::    busk:ho:um:am
              |=  [waz=(list ship) pax=(list rock)]         ::  send packets
              %_    +&gt;
                  bin
                |-  ^+  bin
                ?~  pax  bin
                $(pax t.pax, bin (weld (flop (wist:diz now waz ~ i.pax)) bin))
              ==
</pre><p>Thankfully, <code>++busk</code> is fairly simple. We go through the list of packets and convert them to <code>++boon:ames</code>s with <code>++wist:lax:as:go</code>. These boons are placed into <code>bin</code>, and they end up getting processed by <code>++clop</code> (this happens in <code>++knob</code>). </p><pre>            ++  wist                                        ::    wist:lax:as:go
              |=  $:  now=@da                               ::  route via
                      waz=(list ,@p)
                      ryn=(unit lane)
                      pac=rock
                  ==
              ^-  (list boon)
              ?:  =(our her)  [[%ouzo *lane pac] ~]
              ?~  waz  ~
              =+  dyr=?:(=(her i.waz) dur (gur i.waz))
              ?.  ?&amp;  !=(our i.waz)
                      ?=(^ lun.wod.dyr)
                  ==
                $(waz t.waz)
              :_  ?:  ?=(%ix -.u.lun.wod.dyr)
                    $(waz t.waz)
                  ~
              :+  %ouzo  u.lun.wod.dyr
              ?:  &amp;(=(i.waz her) =(~ ryn))  pac
              =+  mal=(jam `meal`[%fore her ryn pac])
              %-  spit
              ^-  cake
              :*  [our i.waz]
                  ?~  yed.caq.dyr  [%none mal]
                  :-  %fast
                  %^  cat  7
                    p.u.yed.caq.dyr
                  (en:crub:crypto q.u.yed.caq.dyr mal)
              ==
</pre><p>This takes a sample of the current time, the list of ships that we just generated, a lane if we already know it, and the packet itself. </p><p>First, if we are sending a message to ourself, then we simply create a <code>%ouzo</code> boon with a bunted lane. Otherwise, if there are no routing candidates, there is nothing we can do, so we return nil. </p><p>Next, we get the <code>++dore:ames</code> of the first routing candidate. If we&#39;re looking at the neighbor to whom we&#39;re trying to send the message, then we simply use the <code>++dore:ames</code> that we already have. Otherwise, we get a default <code>++dore:ames</code>. </p><p>If we&#39;re the first routing candidate, or if we have don&#39;t have a lane to this candidate, then we skip this candidate and move on to the next one. </p><p>If we have only a provisional ip address, then we try to send on it, but we also try to send on later routing candidates as well. Otherwise, we only send on this one candidate. </p><p>Finally, we create the actual <code>%ouzo</code> boon. The lane is the one from our <code>++dore:ames</code>. If we&#39;re sending it directly to our intended recipient, and we haven&#39;t been told to use a specific lane, then we just send the packet directly. Otherwise, we wrap it in a little <code>%fore</code> meal, telling the intermediary to whom we wish it to be sent. If we have already set up a symmetric key with the intermediary, then we encrypt it with that. Otherwise, we send it in the clear. </p><p>Now, if you recall, we have traced all the way through from the beginning when, in <code>++knob</code>, the <code>%wont</code> card was handled by a call to <code>++wise</code>. There is only one more step before the packet is finally sent. Looking in <code>++knob</code>, we see that the resultant list of boons is passed into <code>++clop</code>, which will execute the correct actions and return a list of moves. In <code>++clop</code>, we see the handling of each specific boon. The one we are interested in is <code>%ouzo</code>, since that is the only one we have sent thus far. </p><pre>            %ouzo
          ::  ~&amp;  [%send now p.bon `@p`(mug (shaf %flap q.bon))]
          :_  fox
          [[gad.fox [%give %send p.bon q.bon]] ~]
</pre><p>Very simply, we give a <code>%send</code> gift along the special duct that goes straight into the bowels of unix. This is the last stop before we drop into vere, and later libuv. And then... the world. </p><p>The packet, after its creation, embarks on a journey across physical time and space into the great unknown. Hurtling through fiber-optic cables at hundreds of thousands of kilometers per second, it finally arrives at our neighbor&#39;s network adapter. The adapter tells unix, unix tells libuv, libuv tells vere, and vere sends a <code>%hear</code> kiss to ames. And now we reenter the kernel. </p><p>The <code>%hear</code> kiss goes straight to <code>++knob</code>, just as did the <code>%wont</code> kiss earlier. </p><pre>                %hear
              (~(gnaw am [now fox]) %good p.kyz q.kyz)
</pre><p>Here, though, we call <code>++gnaw:am</code> to process the packet. The arguments to <code>++gnaw</code> are the same as those to the <code>%hear</code> kiss: the lane on which the packet was received and the packet itself. The other argument is just <code>%good</code>, which is a <code>++cape:ames</code> saying that we expect the packet to succeed. If a formal error occurs, then since we have a transactional event system, the <code>%hear</code> event will never be considered to have actually happened, and unix will send a <code>%hole</code> kiss so that we may send a negative acknowledgment. </p><pre>        ++  gnaw                                            ::    gnaw:am
          |=  [kay=cape ryn=lane pac=rock]                  ::  process packet
          ^-  [p=(list boon) q=fort]
          ?.  =(2 (end 0 3 pac))  [~ fox]
          =+  kec=(bite pac)
          ?:  (goop p.p.kec)  [~ fox]
          ?.  (~(has by urb.ton.fox) q.p.kec)
            [~ fox]
          =&lt;  zork
          =&lt;  zank
          %-  ~(chew la:(ho:(um q.p.kec) p.p.kec) kay ryn %none (shaf %flap pac))
          [q.kec r.kec]
</pre><p>First, we check the protocol number. If it is not correct, then we simply ignore the packet entirely. Otherwise, we parse the packet with <code>++bite</code>, which converts a packet atom into a <code>++cake:ames</code>, that is, a triple of the <code>sock</code> (pair of sender and receiver), the <code>skin</code> (encryption type), and the data. </p><pre>      ++  bite                                              ::  packet to cake
        |=  pac=rock  ^-  cake
        =+  [mag=(end 5 1 pac) bod=(rsh 5 1 pac)]
        =+  :*  vez=(end 0 3 mag)                           ::  protocol version
                chk=(cut 0 [3 20] mag)                      ::  checksum
                wix=(bex +((cut 0 [23 2] mag)))             ::  width of receiver
                vix=(bex +((cut 0 [25 2] mag)))             ::  width of sender
                tay=(cut 0 [27 5] mag)                      ::  message type
            ==
        ?&gt;  =(2 vez)
        ?&gt;  =(chk (end 0 20 (mug bod)))
        :+  [(end 3 wix bod) (cut 3 [wix vix] bod)]
          (kins tay)
        (rsh 3 (add wix vix) bod)
</pre><p>This is exactly the inverse of <code>++spit</code>. Note that here we check both the protocol number and the hash, crashing on error. Remember that a crash will result in a negative acknowledgment being sent. </p><p>Continuing in <code>++gnaw</code>, we see that if the intended recipient is not on our pier, then we drop the packet. </p><p>If we&#39;ve gotten this far, then we wish to process the packet. Recall that <code>++ho</code> and <code>++um</code> set up the domestic server and foreign client cores, respectively, and that <code>++zork</code> and <code>++zank</code> resolve any changes to these cores. </p><p>The new stuff here, then, is the <code>++la</code> core and the <code>++chew</code> arm. The <code>++la</code> sets up a core for this particular packet, containing the current success/failure <code>++cape:ames</code>, the lane it was sent on, the encryption type, and a hash of the packet, used as an id. </p><p><code>++chew</code> is called with the encryption type and the message itself. It contains a little helper core inside of it, which starts immediately with <code>++apse</code>. </p><pre>                ++  apse
                  ^+  +&gt;.$
                  =+  oub=bust:puz
                  =+  neg==(~ yed.caq.dur.diz)
                  =.  +&gt;.$  east
                  =+  eng==(~ yed.caq.dur.diz)
                  =+  bou=bust:puz
                  =.  bin
                    ?.  &amp;(oub !bou)  bin
                    :_(bin [%wine [our her] &quot; is ok&quot;])
                  =.  bin
                    ?.  &amp;(neg !eng)  bin
                    :_(bin [%wine [our her] &quot; is your neighbor&quot;])
                  +&gt;.$
</pre><p>First, we let <code>oub</code> be true if our neighbor hasn&#39;t been responding to us for more than sixteen seconds. Let <code>neg</code> be true if we haven&#39;t yet proposed a symmetric key, meaning that we haven&#39;t yet corresponded with this ship, so they are not our neighbor. Next, we run <code>++east</code>, which we&#39;ll go into in just a minute. </p><p>We now do the same two checks and store the results in <code>eng</code> and <code>bou</code>. If our neighbor has, like the prodigal son, returned after an extended absence, then we send a <code>%wine</code> boon as the proverbial fatted calf, which is simply printed out to the console. Likewise, if we are meeting one with whom we have never had the pleasure of acquainting ourselves, we send a message to the console to that effect. </p><p>We skipped over <code>++east</code>, which contains the meat of the processing. It first decrypts the message, then calls <code>++chow:la:ho:um:am</code> with the resultant meal. We&#39;ll go through each of the four cases in turn, but first since each one calls <code>++bilk:pu</code>, we&#39;ll take a brief detour. </p><pre>        ++  bilk                                            ::    bilk:pu
          |=  now=@da                                       ::  inbound packet
          ^+  +&gt;
          =+  trt=(mul 2 rtt)
          %=  +&gt;.$
            rue  [~ now]
            rto  trt
            rtn  ?~(puq ~ [~ (add now trt)])
          ==
</pre><p>This updates the timing information in our packet pump. <code>rue</code>, the last time we have heard from this neighbor, is set to now. <code>rto</code>, the retransmit timeout is set to twice the current ping time, and if there is anything in the packet queue, then we reset the next timeout, since we&#39;ve just heard a message. </p><p>Back to <code>++east</code>. </p><pre>                      %none
                    =.  puz  (bilk:puz now)
                    (chow ((hard meal) (cue msg)))
</pre><p>The simplest case is when the encryption type is <code>%none</code>. We first call <code>++bilk</code> to update the packet pump, then we cue (unjam) the message into a meal. We hard cast it into a meal -- if the cast fails, then we do want to crash since someone is sending us malformed data. Finally, we send the result to <code>++chow</code> for interpretation and handling. </p><pre>                      %fast
                    =+  [mag=`hand`(end 7 1 msg) bod=(rsh 7 1 msg)]
                    =+  dey=(kuch:diz mag)
                    ?~  dey
                      ~&amp;  [%bad-key her mag]
                      +&gt;.$                           ::  ignore unknown key
                    =.  puz  (bilk:puz now)
                    =^  key  diz  u.dey
                    (chow(aut sin) ((hard meal) (cue (dy:q:sen:gus key bod))))
</pre><p>For symmetric encryption, we first get the <code>++hand</code>, which is the hash of the symmetric key. We pass it to <code>++kuch:lax:as:go</code>, which returns the key if we either have used it before or we have proposed it. If we have proposed it, then we change its status from proposed to real. If <code>++kuch</code> fails, then we drop the packet and print out a <code>%bad-key</code> message. </p><p>Otherwise, we call <code>++bilk</code> as before to update the packet pump and pass into <code>++chow</code> the decrypted data. </p><pre>                      %full
                    =+  mex=((hard ,[p=[p=life q=life] q=will r=@]) (cue msg))
                    =.  diz  (deng:diz q.mex)
                    =+  wug=cluy:diz
                    ?&gt;  =(q.p.mex p.wug)
                    =+  gey=(sev:gus p.p.mex)
                    =+  mes=(need (tear:as:q.gey pub:ex:r.wug r.mex))
                    =.  diz  (wasc:diz p.mes)
                    =.  puz  (bilk:puz now)
                    (west(msg q.mes))
</pre><p>For sealed asymmetric encryption, we first take off the the layer of data that gives us the life and will of our neighbor, and we apply try to extend their former will with the new data. <code>++deng</code> will fail if this is impossible. </p><p>Next, we get our most current understanding of our neighbor&#39;s crypto, and we verify that it&#39;s the same life as what they&#39;re sending. Then, we get our own crypto from <code>++sev</code> and decrypt the message with the public key from our neighbor&#39;s crypto. We register the proposed symmetric key, update the packet pump, and call <code>++west</code>, which simply casts the message to a meal and calls <code>++chow</code>, reporting any error. </p><pre>                      %open
                    =+  mex=((hard ,[p=[~ q=life] q=will r=@]) (cue msg))
                    =.  diz  (deng:diz q.mex)
                    =+  wug=cluy:diz
                    ?&gt;  =(q.p.mex p.wug)
                    =+  mes=(need (sure:as:r.wug *code r.mex))
                    =.  puz  (bilk:puz now)
                    (west(msg mes))
</pre><p>Finally, for signed asymmetric encryption, we, as before, take off the layer of data that gives us the life and will of our neighbor. This time, of course, we do not get our own crypto -- only that of our neighbor. </p><p>The rest you have seen. We call <code>++deng</code> to extend the will, we verify that their crypto life is what we think it ought to be, we “decrypt” the data, we update the packet pump, and we call <code>++west</code> to call <code>++chow</code>. </p><pre>              ++  chow                                      ::    chow:la:ho:um:am
                |=  fud=meal                                ::  interpret meal
                ^+  +&gt;
                =.  diz  ?:(=(%none aut) diz (wast:diz ryn))
                (dine fud)
</pre><p>Here, if the message was encrypted at all, then we call <code>++wast:lax:as:go</code>, which simply updates the lane (route) to our neighbor (unless we&#39;re given a provisional route). This ensures that we always have the most direct possible path to them. </p><p>We&#39;ve been handling this meal for so long, we&#39;ve almost forgotten what we want to do with it. The telos is of any meal to be dined on. We will choose out the cases here that are important to our current investigation. </p><pre>                    %fore
                  =+  ^=  lyn  ^-  lane
                      ?~  q.fud  ryn
                      ?.  ?=(%if -.u.q.fud)  u.q.fud
                      [%ix +.u.q.fud]
                      ::  u.q.fud
                  ?:  =(our p.fud)
                    (emit %mead lyn r.fud)
                  =+  zid=(myx:gus p.fud)
                  (emir (wist:zid now xong:zid [~ lyn] r.fud))
</pre><p>Forwarding is the simplest case, since we&#39;ve seen all the arms before, except perhaps <code>++emit</code> and <code>++emir</code>, which simply take a boon or list of boons respectively and queue them up to be handled when the core resolves. If we&#39;re told to forward a packet to ourselves, then we emit a <code>%mead</code> boon which simply sends another <code>%hear</code> kiss to ourselves with the data. Otherwise, we try to find a route to the recipient, as before. </p><pre>                    %carp
                  =+  zol=(~(get by olz.weg) s.fud)
                  ?^  zol  cock(kay u.zol)
                  =^  neb  nys.weg
                      =+  neb=(~(get by nys.weg) s.fud)
                      ?^  neb  [u.neb nys.weg]
                      =+  neb=`bait`[(kins p.fud) 0 r.fud ~]
                      [neb (~(put by nys.weg) s.fud neb)]
                  ?&gt;  (lth q.fud p.r.neb)
                  ?&gt;  =((kins p.fud) p.neb)
                  ?&gt;  =(r.fud p.r.neb)
                  =+  doy=`(unit ,@)`(~(get by q.r.neb) q.fud)
                  ?^  doy  cock
                  =&gt;  ^+  .   %=  .
                        q.r.neb  (~(put by q.r.neb) q.fud t.fud)
                        q.neb    +(q.neb)
                      ==
                  ::  ~&amp;  [%carp q.fud s.fud q.neb p.r.neb]
                  ?:  =(q.neb p.r.neb)
                    =:  nys.weg  (~(del by nys.weg) s.fud)
                        olz.weg  (~(put by olz.weg) s.fud kay)
                      ==
                    (golf p.neb r.neb)
                  =.  +&gt;.$  cock
                  +&gt;.$(nys.weg (~(put by nys.weg) s.fud neb))
</pre><p>Here, we have received a partial message, and we&#39;re just assembling the individual packets into a message. Most of this code is fairly algorithmic, so we&#39;ll just hit the high points. In the beginning, we check if we&#39;ve already received this message, and if so, we resend the acknowledgment. Remember, “always ack a dupe, never ack an ack”. </p><p>In <code>nys.weg</code> we keep track of an incoming set of partial packets, indexed by the <code>flap</code> hash that comes with every packet. We check to see if we have already received this partial message, and if so we acknowledge it. Otherwise, we put it in <code>nys.weg</code> unless this is the last message, in which case we ack the last partial message, move the complete message into <code>olz.weg</code>, and call <code>++golf</code>, which assembles the message and calls <code>++chew</code>, to start the dance again with the complete message. </p><pre>                    %bund
                  ::  ~&amp;  [%bund q.fud r.fud]
                  ?&gt;  =(p:sen:gus p.fud)
                  (deer q.fud r.fud ?-(kay %dead ~, %good [~ s.fud]))
</pre><p>What if we&#39;re just receiving a regular old, garden variety message? We call <code>++deer</code> with the data from the message. If we already know that the message processing will fail (that is, if we got a <code>%hole</code> card from unix rather than a <code>%hear</code> card), then we don&#39;t even send the data at all. Remember, if a packet fails to process, it&#39;s as if it never even arrived, except that we send a negative acknowledgment. </p><pre>              ++  deer                                      ::    deer:la:ho:um:am
                |=  [cha=path num=@ud dut=(unit)]           ::  interpret message
                ^+  +&gt;
                =+  rum=(fall (~(get by raz.bah) cha) *race)
                %=    +&gt;.$
                    +&gt;
                  ?.  (gte num did.rum)                     ::  always ack a dup
                    (cook (~(get by bum.rum) num) cha ~ ryn dam)
                  ?:  dod.rum
                    (coat cha rum(mis (~(put by mis.rum) num [kay ryn dam dut])))
                  %=    +&gt;.+&gt;.$
                      raz.bah
                    %+  ~(put by raz.bah)  cha
                    rum(mis (~(put by mis.rum) num [kay ryn dam dut]))
                  ==
                ==
</pre><p>First, we get the race for this particular triple of sender, receiver, and path, creating it if it doesn&#39;t exist. If we&#39;ve already acked the message, then we resend the ack. Note that <code>did.rum</code> is the number of packets we acknowledged, positively or negatively while <code>bum.rum</code> is a map of message numbers to negative acknowledgments. Thus, if a message number is less than <code>did.rum</code>, then if it&#39;s in <code>bum.rum</code> then it was negatively acknowledged, otherwise it&#39;s positively acknowledged. Thus, we are constant in space with the number of successful messages and linear in the number of failed messages. We&#39;ll document <code>++cook</code> later on, but suffice it to say that it sends an acknowledgment. It is to end-to-end acknowledgments what <code>++cock</code> is to packet-level acknowledgments. </p><p>If we are still processing a message (that is, <code>dod.rum</code> is false), then we simply put this message in the map of misordered packets to be processed when their time comes. “Processing a message” in this case means that we&#39;ve received the message and notified the correct application, but we&#39;re still waiting for the application-level acknowledgment. </p><p>Otherwise, we&#39;re ready for a packet, so we process it. </p><pre>            ++  coat                                        ::    coat:ho:um:am
              |=  [cha=path rum=race]                       ::  update input race
              ^+  +&gt;
              =+  cun=(~(get by mis.rum) did.rum)
              ?~  cun
                +&gt;.$(raz.bah (~(put by raz.bah) cha rum))
              ?.  =(%good p.u.cun)  +&gt;.$
              ?&gt;  ?=(^ s.u.cun)
              %=    +&gt;.$
                  raz.bah  (~(put by raz.bah) cha rum(dod |))
                  bin
                :_  bin
                :^    %mulk
                    [our her]
                  `soap:ames`[[p:sen:gus clon:diz] cha did.rum]
                u.s.u.cun
              ==
</pre><p>First, we grab the message we want to process and store it in <code>cun</code>. If it&#39;s a good packet, then we change <code>dod.rum</code> to false, meaning that we&#39;re in the middle of processing a packet and should not start processing another one. We also put a <code>%mulk</code> boon into the queue so that, when it all resolves, we send a mesage to the intended recipient application. The boon contains the sender, the receiver, the identity of the message, and the message itself. </p><p>This bubbles up all the way back to <code>++knob</code>, where we were handling the <code>%hear</code> card. Following the logic in <code>++knob</code>, we can see that the boons get sent into <code>++clop</code> to be turned into actual arvo-level moves. We&#39;ve been here before, if you recall, when we handled the <code>%cake</code> boon to send a message. Now, we&#39;re handling the <code>%mulk</code> boon, which is unfortunately slightly more complicated. </p><pre>            %mulk
          ::  ~&amp;  [%mulk p.bon q.bon]
          ?&gt;  ?=([@ @ *] q.q.bon)
          ?&gt;  ?=(%q i.q.q.bon)
          ?+  i.t.q.q.bon
            ~&amp;  %mulk-bad
            :_  fox
            :~  :-  (claw p.p.bon)
                [%sick %wart p.bon i.t.q.q.bon t.t.q.q.bon r.bon]
            ==
              %ge                                         ::  %gall request
            ?&gt;  ?=([@ ~] t.t.q.q.bon)
            =+  app=`term`(need ((sand %tas) i.t.t.q.q.bon))
            =+  ^=  pax
                :+  (scot %p p.p.bon)
                  (scot %p q.p.bon)
                q.q.bon
            :_  fox  [hen %pass pax %g %rote p.bon app r.bon]~
              %gh                                         ::  %gall response
            ?&gt;  ?=([@ ~] t.t.q.q.bon)
            =+  app=`term`(need ((sand %tas) i.t.t.q.q.bon))
            =+  ^=  pax
                :+  (scot %p p.p.bon)
                  (scot %p q.p.bon)
                q.q.bon
            :_  fox  [hen %pass pax %g %roth p.bon app r.bon]~
          ==
</pre><p>We&#39;re dispatching messages based on the prefix of their path. Since only <code>%gall</code> apps use end-to-end acknowledgments at the moment, every path must have at least two elements, and the first one must be <code>%q</code>. Beyond that, we handle the <code>/q/ge</code> and <code>/q/gh</code> cases for gall requests and responses, respectively. </p><p>In both cases, we require the next term in the path to be the name of the intended recipient <code>%gall</code> app. Thus, a message to <code>/q/ge/talk</code> for example, will send a message to the talk app. </p><p>We then send a message to the app itself. The message is either a <code>%rote</code> or a <code>%roth</code> for a request and a response, respectively. The content is the <code>rook</code> or <code>roon</code> that was sent (stored in <code>r.bon</code>), but we don&#39;t actually handle that at all here. That&#39;s completely a <code>%gall</code>-level thing. We&#39;re just the messenger. </p><p>Notice the path we send this over. We encode the sender, the receiver, and the path over which it was sent. This fully specifies the <code>race</code> so that when the app gives us the acknowledgment we know where to send it. </p><p>We now have another interlude. We have entrusted our precious data, so carefully guarded and guided from the app on that far-away ship, to our local app. It has the ability to do whatever it pleases with it. It may take a significant amount of time to process. When the message has been handled by this app, though, it must produce an acknowledgment. Our final task is to deliver this acknowledgment to the sending app. </p><p>We should describe here what exactly these oft-mentioned acknowledgments actually consist of. There are two kinds of acknowledgments: positive and negative. A positive acknowledgment contains no data other than its existence. A negative acknowledgment may optionally include a reason for said negativity. Formally, a negative acknowledgment is an <code>ares</code>, which is a unit pair of a term and a list of tanks. If this is null, this is simply a failure with no associated information. If the pair exists, the term is a short error code that is usually both human and computer readable. For example, if you try to send a message to a valid <code>%gall</code> app that doesn&#39;t have any <code>++poke</code> to handle it, then <code>%gall</code> will give a negative acknowledgment with error term <code>%poke-find-fail</code>. The list of tanks is a human-readable description of the error. This often contains a stack trace. At any rate, all this information is returned to the sending app on the other end of the wire. </p><p>After this brief interlude, our story resumes in <code>++knap</code>, where we receive responses. In particular, a <code>%mean</code> indicates a negative acknowledgment while a <code>%nice</code> indicates a positive acknowledgment. </p><pre>            ?(%mean %nice)
          ?&gt;  ?=([@ @ @ *] tea)
          =+  soq=[(slav %p i.tea) (slav %p i.t.tea)]
          =+  pax=t.t.tea
          =+  ^=  fuy
              =&lt;  zork  =&lt;  zank
              %^  ~(rack am [now fox])  soq  pax
              ?-(+&lt;.sih %mean `p.+.sih, %nice ~)
          =&gt;  %_(. fox q.fuy)
          =|  out=(list move)
          |-  ^-  [p=(list move) q=_+&gt;.^$]
          ?~  p.fuy
            [(flop out) +&gt;.^$]
          =^  toe  fox  (clop now hen i.p.fuy)
          $(p.fuy t.p.fuy, out (weld (flop toe) out))
</pre><p>Recall the format of the path we sent the message on, and you&#39;ll understand why <code>soq</code> and <code>pax</code> are the sender/receiver pair and path on which the message was sent. The rest of this is structured much like <code>++knob</code>, so we call <code>++rack:am</code> and send the resulting boons to <code>++clop</code>. Business as usual. </p><pre>        ++  rack                                            ::    rack:am
          |=  [soq=sock cha=path cop=coop]                  ::  e2e ack
          =+  oh=(ho:(um p.soq) q.soq)
          =.  oh  (cook:oh cop cha ~)
          (cans:oh cha)
</pre><p>First, we set up <code>++um</code> and <code>++ho</code>, as we&#39;ve done twice before, for our domestic and foreign servers, respectively. The other two things are new, though. Well, <code>++cook</code> is not actually new, but we delayed the explanation saying only that it sends an acknowledgment. The time has come. </p><pre>            ++  cook                                        ::    cook:ho:um:am
              |=  [cop=coop cha=path ram=(unit ,[ryn=lane dam=flap])]
              ^+  +&gt;                                        ::  acknowledgment
              =+  rum=(need (~(get by raz.bah) cha))
              =+  lat=(~(get by mis.rum) did.rum)
              ?:  &amp;(?=(~ lat) ?=(~ ram))  ~&amp;(%ack-late-or-redundant +&gt;.$)
              =+  ^-  [ryn=lane dam=flap]
                  ?^  ram  [ryn.u.ram dam.u.ram]
                  ?&lt;  ?=(~ lat)
                  [q r]:u.lat
              =.  raz.bah
                ?^  ram  raz.bah
                %+  ~(put by raz.bah)  cha
                rum(dod &amp;, bum ?~(cop bum.rum (~(put by bum.rum) did.rum u.cop)))
              =^  roc  diz  (zuul:diz now [%buck cop dam ~s0])
              (busk(diz (wast:diz ryn)) xong:diz roc)
</pre><p>If we are acknowledging a message that we have already acked, the <code>ram</code> will contain the new lane and flap to send the duplicate ack to. This happens if we call <code>++cook</code> in <code>++deer</code>, but it doesn&#39;t happen from <code>++rack</code>. If there is no message waiting to be acknowledged and we&#39;re not given an explicit lane and flap (that is, we&#39;re not sending a duplicate ack), then the app must have sent us multiple acknowledgments. We do the only sensible thing we can do and drop all acknowledgments after the first, printing a message. This is, in fact, an error, so it could be argued that we ought to crash. Whatever you do, don&#39;t depend on this not crashing. </p><p>First, we grab the race specified by the given path, and we get the most recent in-order message, which must be the one which is being acknowledged. </p><p>Then, we decide which lane/flap to respond on/to. Basically, in the usual case we respond on the lane through which the initial message was sent, which is stored along with the other packet information in <code>mis.rum</code>, since it has to be remembered across calls to ames. However, if we receive a duplicate message, then we must respond to the new message. It&#39;s quite possible the reason the other acknowledgment didn&#39;t get returned was that the lane between the ships was broken. </p><p>At any rate, we update the race by saying that we&#39;ve finished processing this packet (unless we&#39;re sending a duplicate ack) and, if we&#39;re sending a negative acknowledgment, putting the negative ack into <code>bum.rum</code> so that we can resend it if necessary. </p><p>We encode our new message, updating the packet pump, with <code>++zuul</code>, as before, and we send it off with <code>++busk</code>, routed via <code>++wast</code> to one of the ships in <code>++xong</code>. Of course, in practice, we don&#39;t even look at the ships in <code>++xong</code> because we already have a lane directly to our neighbor (the one over which they sent their message to us). </p><p>We glossed over the actual message we&#39;re sending back. We&#39;re sending a <code>%buck</code> meal, which is an acknowledgment. The <code>cop</code> specifies whether this is a positive or a negative ack, <code>dam</code> specifies the message we&#39;re acknowledging, and the <code>~s0</code> is a placeholder for the processing time required. This time is neither calculated (though it is hopefully obvious how to do so) nor used at present, but this information may be used in the future for improved congestion control. Since the round-trip time for an end-to-end acknowledged packet includes the processing time on the other end, most common congestion control algorithms will stumble when some messages take much longer to process than others. As noted, though, this is simply an opportunity for improvement -- our congestion control algorithms are relatively naive at the moment. </p><p>Recall that <code>++busk</code> calls <code>++wist</code> to put the actual <code>%ouzo</code> boon in the queue, which gets handled by <code>++clop</code> to actually send the message. This is the same pipeline as sending any other message, so we&#39;ll refer you to the explanation above if you&#39;ve forgotten it. </p><p>The last thing we need to do on this ship is move on to the next packet in the queue if there is one. If you recall, in <code>++rack</code> after the call to <code>++cook</code> there was a call to <code>++cans:ho:um:am</code>. </p><pre>            ++  cans                                        ::    cans:ho:um:am
              |=  cha=path
              =+  rum=(need (~(get by raz.bah) cha))
              =.  rum
                %=  rum
                  did  +(did.rum)
                  mis  (~(del by mis.rum) did.rum)
                ==
              (coat cha rum)
</pre><p>This is very simple. We increment the number of packets that we&#39;ve acknowledged on this race and we delete the packet that we just acknowledged from the set of misordered packets. </p><p>Then, we call <code>++coat</code> again to process the next packet if we&#39;ve already received it. And that&#39;s it for this. </p><p>The acknowledgment now travels the same path that its forebearer, the original message, once tread, but this time not into the great unknown. The weary traveler is seeking out its familial roots, finding the app from whom sprung forth the original message way back in paragraph three. When it arrives at the network adapter of its ancestors, the adapter tells unix, unix tells libuv, libuv tells vere, and vere sends a <code>%hear</code> kiss to ames. Once more into the kernel. </p><p>The <code>%hear</code> kiss is handled in <code>++knob</code> as before, leading to <code>++gnaw</code>, going over to <code>++chew</code>, <code>++apse</code>, <code>++chow</code>, and eventualy to <code>++dine</code>. We&#39;ve seen most of the cases in <code>++dine</code>, but we haven&#39;t yet looked at the handling of this <code>%buck</code> meal. </p><pre>                    %buck
                  =.  +&gt;  ?.(=(%full aut) +&gt; cock)          ::  finish key exch
                  +&gt;(..la (tock p.fud q.fud r.fud))
</pre><p>We send a packet level acknowledgment if we&#39;re finishing a key exchange, else we call <code>++tock</code> to process the acknowledgment. </p><p>This will get a little involved, so if you don&#39;t much care about how exactly an acknowledgment happens, just know that the result gets gifted as a <code>%woot</code> card back to the app who sent it. For those brave souls who wish to see this thing through to the end, it&#39;s once more into the breach. </p><pre>            ++  tock                                        ::    tock:ho:um:am
              |=  [cop=coop fap=flap cot=@dr]               ::  e2e ack by hash
              ^+  +&gt;
              =^  yoh  puz  (bick:puz now fap)
              =.  +&gt;.$
                ?~  p.yoh  +&gt;.$
                =^  hud  +&gt;.$
                  (done p.u.p.yoh q.u.p.yoh)
                ?~  hud  +&gt;.$
                %=    +&gt;.$
                    bin
                  :_  bin
                  `boon`[%cake [our her] [[p:sen:gus clon:diz] u.p.yoh] cop u.hud]
                ==
              (busk xong:diz q.yoh)
</pre><p>We&#39;re going to work through this one a little backwards since it&#39;s mostly fairly simple except the call to <code>++bick:pu</code>. In fact, we&#39;ll just skip <code>++bick</code> for the moment and finish the rest. </p><p>If <code>++bick</code> succesfully acks the message, then we call <code>++done</code>. </p><pre>            ++  done                                        ::    done:ho:um:am
              |=  [cha=path num=@ud]                        ::  complete outgoing
              ^-  [(unit duct) _+&gt;]
              =+  rol=(need (~(get by ryl.bah) cha))
              =+  rix=(~(get by san.rol) num)
              ?~  rix  [~ +&gt;.$]
              :-  rix
              %_    +&gt;.$
                  ryl.bah
                (~(put by ryl.bah) cha rol(san (~(del by san.rol) num)))
              ==
</pre><p>This very simply gets the rill (the outgoing counterpart to a race, if you recall), pulls out of the map of outstanding messages the duct over which the original message was sent, and produces this duct while deleting that entry from the map of outstanding messages. </p><p>Going back to <code>++tock</code>, we now have the duct we need to return the result over. We do the very sensible thing and put a <code>%cake</code> boon in the queue to be processed later by <code>++clop</code>. </p><p>In <code>q.yoh</code> we have a list of messages that may need to be sent, which we pass to <code>++busk</code> to send, as usual. When an acknowledgment arrives, that may trigger other messages immediately. This often happens when sending more messages than the width of the logical window since for congestion control reasons another message cannot be sent until some of the earlier ones have been acknowledged. </p><p>We&#39;ll look at the processing of the <code>%cake</code> boon in <code>++clop</code> before we get back to talking about <code>++bick</code>. </p><pre>            %cake
          :_  fox
          :~  [s.bon %give %woot q.p.bon r.bon]
          ==
</pre><p>We very simply give, along the duct we found above, a <code>%woot</code> card with the ship who sent us the ack and the ack itself. This allows the application to decide what to do about the result. In case of a failure, we usually either resend the message or display it to the user. Sometimes, we recognize the error term and handle it internally. In any case, the decision of how to handle the acknowledgment is entirely up to the application. Our job is done. </p><p>Well, except that we skipped <code>++bick:pu</code>. Let&#39;s go back to that. </p><pre>        ++  bick                                            ::    bick:pu
          |=  [now=@da fap=flap]                            ::  ack by hash
          ^-  [[p=(unit soup) q=(list rock)] _+&gt;]
          =+  sun=(~(get by diq) fap)
          ?~  sun
            [[~ ~] +&gt;.$]
          =.  diq  (~(del by diq) fap)
          =^  gub  +&gt;.$  (bock now u.sun)
          =^  yop  +&gt;.$  (harv now)
          [[gub yop] +&gt;.$]
</pre><p>If you recall, in <code>++whap:pu</code> we created the packet pump&#39;s representation of the message, which included putting the message into <code>diq</code>, which maps from packet hashes to packet sequence numbers. Thus, <code>u.sun</code> is the sequence number of this particular message. </p><p>We delete this message from <code>diq</code> since we have now received an ack for it. We call <code>++bock</code> to perform the ack by sequence number. We call <code>++harv</code> to harvest the packet queue, sending any messages that are now able to be sent. </p><p>In <code>++bock</code>, there are three arms we haven&#39;t seen before: <code>++bine</code>, <code>+wept</code>, and <code>++beet</code>. We&#39;ll describe each of these before we get to <code>++bock</code>. <code>++bine</code> looks scariest. </p><pre>        ++  bine                                            ::    bine:pu
          |=  [now=@da num=@ud]                             ::  apply ack
          ^-  [(unit soup) _+&gt;]
          ?~  puq  !!
          ?.  =(num p.n.puq)
            ?:  (gth num p.n.puq)
              =+  lef=$(puq l.puq)
              [-.lef +.lef(puq [n.puq puq.lef r.puq])]
            =+  rig=$(puq r.puq)
            [-.rig +.rig(puq [n.puq l.puq puq.rig])]
          =:  rtt  ?.  &amp;(liv.q.n.puq =(1 nux.q.n.puq))  rtt
                   =+  gap=(sub now lys.q.n.puq)
                   ::  ~&amp;  [%bock-trip num (div gap (div ~s1 1.000))]
                   (div (add (mul 2 rtt) gap) 3)
              nif  (sub nif !liv.q.n.puq)
            ==
          =+  lez=(dec (need (~(get by pyz) gom.q.n.puq)))
          =^  gub  pyz
              ?:  =(0 lez)
                [[~ gom.q.n.puq] (~(del by pyz) gom.q.n.puq)]
              [~ (~(put by pyz) gom.q.n.puq lez)]
          :-  gub
          +&gt;.$(puq ~(nap to puq))
</pre><p>The first few lines are simply looking through the packet queue until we find the correct packet to ack. This is basic queue manipulation that operates directly on the treap structure of the queue. If you understand treap queues, the logic is easy to follow. Otherwise, just trust us that by the time we get to the <code>=:</code>, the packet with sequence number <code>num</code> is on the top of the packet queue (that is, at <code>n.puq</code>). </p><p>We first update the round-trip time. If the packet is either not alive or had to be transmitted more than once, then we don&#39;t have any reliable way of calculating the round-trip time since we&#39;re unsure of exactly which transmission was acknowledged. Otherwise, the round-trip time is the difference between now and when the packet was last sent. We set <code>rtt</code> by a little weighted average where the previous smoothed RTT is weighted twice as much as the RTT of the current packet. Thus, <code>(2*rtt+gap)/3</code>. This gives us a nice smooth RTT that is somewhat resilient to outlier data while still being responsive to our ever-changing world. </p><p>If the packet wasn&#39;t already dead, then we decrement the number of live packets, which may allow more packets to be sent. </p><p>We decrement the number of unacknowledged packets in our <code>pyz</code> for this particular message. If you recall, this was set in <code>++whap</code> to the number of packets required to send a message. </p><p>If that was the last packet in the messge that needed to be acked, then we delete the messgae reference from <code>pyz</code> and produce the id of the message. Otherwise, we simply update <code>pyz</code> with the new number of unacked messages. In either case, we remove the packet from the packet queue. </p><pre>        ++  wept                                            ::    wept:pu
          |=  [fip=@ud lap=@ud]                             ::  fip thru lap-1
          =&lt;  abet  =&lt;  apse
          |%
          ++  abet  +&gt;.$
          ++  apse
            ^+  .
            ?~  puq  .
            ?:  (lth p.n.puq fip)  ?~(l.puq . left)
            ?:  (gte p.n.puq lap)  ?~(r.puq . rigt)
            =&gt;  rigt  =&lt;  left
            ?&gt;  ?=(^ puq)
            ?.(liv.q.n.puq . .(nif (dec nif), liv.q.n.puq |))
          ::
          ++  left
            ?&gt;  ?=(^ puq)
            ^+(. =+(lef=apse(puq l.puq) lef(puq [n.puq puq.lef r.puq])))
          ++  rigt
            ?&gt;  ?=(^ puq)
            ^+(. =+(rig=apse(puq r.puq) rig(puq [n.puq l.puq puq.rig])))
          --
</pre><p>The algorithm is a simple case of traversing the packet queue. Essentialy, we mark as dead all packets in the queue between <code>fip</code> and <code>(dec lap)</code>. We also update <code>nif</code>, the number of live packets. Lest you mourn too much the passing of these packets, know that they shall soon rise again. Recall that in <code>++bick</code> after the call to <code>++bock</code> we call <code>++harv</code>. This will resend the packets that have just been labeled dead. </p><pre>        ++  beet                                            ::    beet:pu
          ^+  .                                             ::  advance unacked
          =-  +(nep ?~(foh nus u.foh))
          ^=  foh
          |-  ^-  (unit ,@ud)
          ?~  puq  ~
          ?:  (lte p.n.puq nep)  $(puq l.puq)
          =+  rig=$(puq r.puq)
          ?^(rig rig [~ p.n.puq])
</pre><p>Here we search for the next expected packet number. Basically, we search the queue for the leftmost packet whose number is greater than the current <code>nep</code>. If we don&#39;t find any such packet, we just use the total number of packets sent. </p><p>We can now dive into <code>++bock</code>, our last arm. </p><pre>        ++  bock                                            ::    bock:pu
          |=  [now=@da num=@ud]                             ::  ack by sequence
          ^-  [(unit soup) _+&gt;]
          =^  gym  +&gt;  (bine now num)
          :-  gym
          ?:  (gth num nep)
            =+  cam=(max 2 (div caw 2))
            ::  ~&amp;  [%bock-hole num nep cam]
            beet:(wept(nep num, cag cam, caw cam) nep num)
          =.  caw  ?:  (lth caw cag)  +(caw)
                   (add caw !=(0 (mod (mug now) caw)))
          ?:  =(num nep)
            ::  ~&amp;  [%bock-fine num nif caw cag]
            beet
          ::  ~&amp;  [%bock-fill num nif caw cag]
          +&gt;.$
</pre><p>First, we call <code>++bine</code> to apply the ack to the packet pump information. We produce <code>gym</code>, which, if it exists, is the id of the packet that was acked. If we received an ack for a packet later than the one we expected, then we halve the logical packet window and kill all the earlier packets so that they may be resent. </p><p>Otherwise, we possibly increase the congestion window. If the window is less than the congestion threshold, then we increment the size of the window. Otherwise, we only increment one out of every <code>caw</code> times. </p><p>If we received an ack for the packet we expected, then we simply advance <code>nep</code> with <code>++beet</code>. If we received an ack for a packet earlier than we expected, we do nothing. </p><p>It may be hard to believe, but we are, in fact, done. The message has been sent, received, acknowledged, and the acknowledgment has been returned to the original sender. We hope it&#39;s clear that, while the process has been somewhat involved, the algorithms are not all that complicated. If you&#39;ve read this far, you know <code>%ames</code>. The only other code involves initialization, timeouts, and the like. </p><p>Below, we give detailed reference documentation for the data models involved. </p><h2 id="data-models-">Data Models </h2><h3 id="--sufi-ames--domestic-host-"><code>++sufi:ames</code>, domestic host </h3><pre>    ++  sufi                                                ::  domestic host
              $:  hoy=(list ship)                           ::  hierarchy
                  val=wund                                  ::  private keys
                  law=will                                  ::  server will
                  seh=(map hand ,[p=ship q=@da])            ::  key cache
                  hoc=(map ship dore)                       ::  neighborhood
              ==                                            ::
</pre><p>This is the security state of a domestic server. </p><p><code>hoy</code> is a list of the ships directly above us in the hierarchy of ships. For example, for <code>~hoclur-bicrel</code>, this would be <code>~tasruc</code> and <code>~tug</code>. See <code>++sein:title</code>. </p><p><code>val</code> is a list of our private keys. </p><p><code>law</code> is our certificate, which is a list of the XXX </p><p><code>seh</code> </p><p><code>hoc</code> is a map of ships to <code>++dore:ames</code>. The stores all the security information about foreign ships. The keys to this map are the neighbors (ships we have been in contact with) of this domestic server. </p><h3 id="--wund-ames--private-keys-"><code>++wund:ames</code>, private keys </h3><pre>    ++  wund  (list ,[p=life q=ring r=acru])                ::  mace in action
</pre><p>This is a list of our own private keys, indexed by life. The key itself is the <code>++ring</code>, and the <code>++acru:ames</code> is the encryption engine. We generate the <code>++acru:ames</code> from the private key by calling <code>++weur</code>. Thus, we can at any time regenerate our <code>++wund:ames</code> from a <code>++mace:ames</code>. The current crypto is at the head of the list and can be accessed with <code>++sen:as:go</code>. </p><h3 id="--ring--private-key-"><code>++ring</code>, private key </h3><pre>    ++  ring  ,@                                            ::  private key
</pre><p>This is a private key. The first byte is reserved to identify the type of cryptography. Lower-case means public key, upper-case means public key, and the letter identifies which <code>++acru:ames</code> to use. </p><h3 id="--pass--public-key-"><code>++pass</code>, public key </h3><pre>    ++  pass  ,@                                            ::  public key
</pre><p>This is a public key. The first byte is reserved to identify the type of cryptography. Lower-case means public key, upper-case means public key, and the letter identifies which <code>++acru:ames</code> to use. </p><h3 id="--mace-ames--private-secrets-"><code>++mace:ames</code>, private secrets </h3><pre>    ++  mace  (list ,[p=life q=ring])                       ::  private secrets
</pre><p>This is a list of the our private keys, indexed by life. From this we can generate a <code>++wund:ames</code> for actual use. </p><h3 id="--skin-ames--encoding-stem-"><code>++skin:ames</code>, encoding stem </h3><pre>    ++  skin  ?(%none %open %fast %full)                    ::  encoding stem
</pre><p>This defines the type of encryption used for each message. <code>%none</code> refers to messages sent in the clear, <code>%open</code> refers to signed messages, <code>%full</code> refers to sealed messages, and <code>%fast</code> refers to symmetrically encrypted messages. See <code>++acru:ames</code> for details. </p><h3 id="--acru-ames--asymmetric-cryptosuite-"><code>++acru:ames</code>, asymmetric cryptosuite </h3><pre>    ++  acru                                                ::  asym cryptosuite
              $_  ^?  |%                                    ::  opaque object
              ++  as  ^?                                    ::  asym ops
                |%  ++  seal  |=([a=pass b=@ c=@] _@)       ::  encrypt to a
                    ++  sign  |=([a=@ b=@] _@)              ::  certify as us
                    ++  sure  |=([a=@ b=@] *(unit ,@))      ::  authenticate from us
                    ++  tear  |=  [a=pass b=@]              ::  accept from a
                              *(unit ,[p=@ q=@])            ::
                --                                          ::
              ++  de  |+([a=@ b=@] *(unit ,@))              ::  symmetric de, soft
              ++  dy  |+([a=@ b=@] _@)                      ::  symmetric de, hard
              ++  en  |+([a=@ b=@] _@)                      ::  symmetric en
              ++  ex  ^?                                    ::  export
                |%  ++  fig  _@uvH                          ::  fingerprint
                    ++  pac  _@uvG                          ::  default passcode
                    ++  pub  *pass                          ::  public key
                    ++  sec  *ring                          ::  private key
                --
              ++  nu  ^?                                    ::  reconstructors
                 |%  ++  pit  |=([a=@ b=@] ^?(..nu))        ::  from [width seed]
                     ++  nol  |=(a=@ ^?(..nu))              ::  from naked ring
                     ++  com  |=(a=@ ^?(..nu))              ::  from naked pass
                --
              --
</pre><p>This is an opaque interface for a general asymmetric cryptosuite. Any form of asymmetric cryptography can be dropped in to be used instead of the default. Right now, there is one cryptosuite: <code>++crub:crypto:crypto</code>, which is elliptic-curve cryptography. </p><h4 id="--as-acru-ames--asymmetric-operations-"><code>++as:acru:ames</code>, asymmetric operations </h4><pre>              ++  as  ^?                                    ::  asym ops
                |%  ++  seal  |=([a=pass b=@ c=@] _@)       ::  encrypt to a
                    ++  sign  |=([a=@ b=@] _@)              ::  certify as us
                    ++  sure  |=([a=@ b=@] *(unit ,@))      ::  authenticate from us
                    ++  tear  |=  [a=pass b=@]              ::  accept from a
                              *(unit ,[p=@ q=@])            ::
                --                                          ::
</pre><p>This is the core that defines the standard asymmetric cryptography operations. </p><p><code>++seal:as:acru:ames</code> allows us to send a message encrypted with someone&#39;s public key so that only they may read it. If Alice seals a message with Bob&#39;s public key, then she can be sure that Bob is the only one who can read it. This is associated with the <code>++skin:ames</code> <code>%full</code>. </p><p><code>++sign:as:acru:ames</code> allows us to sign a message with our private key so that others can verify that we sent the message. If Alice signs a message with her private key, then Bob can verify with her public key that it was indeed Alice who sent it. This is associated with the <code>++skin:ames</code> <code>%open</code>. </p><p><code>++sure:as:acru:ames</code> is the dual to <code>++sign:as:acru:ames</code>. It allows us to verify that a message we have received is indeed from the claimed sender. If Alice sends a message with her private key, then Bob can use this arm to verify that it was indeed Alice who sent it. This is associated with the <code>++skin:ames</code> <code>%open</code>. </p><p><code>++tear:as:acru:ames</code> is the dual to <code>++seal:as:acru:ames</code>. It allows us to read a message that we can be sure is only read by us. If Alice seals a message with Bob&#39;s public key, then Bob can use this arm to read it. This is associated with the <code>++skin:ames</code> <code>%full</code>. </p><h4 id="--de-acru-ames----dy-acru-ames--and---en-acru-ames--symmetric-encryption-decryption-"><code>++de:acru:ames</code>, <code>++dy:acru:ames</code>, and <code>++en:acru:ames</code>, symmetric encryption/decryption </h4><pre>              ++  de  |+([a=@ b=@] *(unit ,@))              ::  symmetric de, soft
              ++  dy  |+([a=@ b=@] _@)                      ::  symmetric de, hard
              ++  en  |+([a=@ b=@] _@)                      ::  symmetric en
</pre><p>Symmetric encryption is associated with the <code>++skin:ames</code> <code>%fast</code>. </p><p><code>++de:acru:ames</code> decrypts a message with a symmetric key, returning <code>~</code> on failure and <code>[~ u=data]</code> on success. </p><p><code>++dy:acru:ames</code> decrypts a message with a symmetric key, crashing on failure. This should almost always be defined as, and should always be semantically equivalent to, <code>(need (de a b))</code>. </p><p><code>++en:acru:ames</code> encrypts a message with a symmetric key. </p><h4 id="--ex-acru-ames--exporting-data-"><code>++ex:acru:ames</code>, exporting data </h4><pre>              ++  ex  ^?                                    ::  export
                |%  ++  fig  _@uvH                          ::  fingerprint
                    ++  pac  _@uvG                          ::  default passcode
                    ++  pub  *pass                          ::  public key
                    ++  sec  *ring                          ::  private key
                --
</pre><p><code>++fig:ex:acru:ames</code> is our fingerprint, usually a hash of our public key. This is used, for example, in <code>++zeno</code>, where every carrier owner&#39;s fingerprint is stored so that we can ensure that carriers are indeed owned by their owners </p><p><code>++pac:ex:acru:ames</code> is our default passcode, which is unused at present. </p><p><code>++pub:ex:acru:ames</code> is the <code>++pass</code> form of our public key. </p><p><code>++sec:ex:acru:ames</code> is the <code>++ring</code> form of our private key. </p><h4 id="--nu-acru-ames--reconstructors-"><code>++nu:acru:ames</code>, reconstructors </h4><pre>              ++  nu  ^?                                    ::  reconstructors
                 |%  ++  pit  |=([a=@ b=@] ^?(..nu))        ::  from [width seed]
                     ++  nol  |=(a=@ ^?(..nu))              ::  from naked ring
                     ++  com  |=(a=@ ^?(..nu))              ::  from naked pass
                --
</pre><p>These arms allow us to reconstruct a <code>++acru:ames</code> from basic data. </p><p><code>++pit:nu:acru:ames</code> constructs a <code>++acru:ames</code> from the width of our intended key and seed entropy. This is usually used in the initial construction of the <code>++acru:ames</code>. </p><p><code>++nol:nu:acru:ames</code> constructs a <code>++acru:ames</code> from a “naked ring”, meaning a <code>++ring</code> without the initial byte identifying the type of crypto. </p><p><code>++com:nu:acru:ames</code> constructs a <code>++acru:ames</code> from a “naked pass”, meaning a <code>++ring</code> without the initial byte identifying the type of crypto. </p><h3 id="--will--certificate-"><code>++will</code>, certificate </h3><pre>    ++  will  (list deed)                                   ::  certificate
</pre><p>This is a list of deeds associated with the current ship. There should be an item in this list for every ship from this point up in the hierarchy times the number of lives that each ship has had. For example, ~hoclur-bicrel may have a will with three items: one for itself, one for ~tasruc (who issued ~hoclur-bicrel&#39;s deed) and one for ~tug (who issued ~tasruc&#39;s deed). </p><h3 id="--deed--identity-"><code>++deed</code>, identity </h3><pre>    ++  deed  ,[p=@ q=step r=?]                             ::  sig, stage, fake?
</pre><p><code>p</code> is the signature of a particular deed, which is a signed copy of <code>q</code>. </p><p><code>q</code> is the stage in the identity. </p><p><code>r</code> is true if we&#39;re working on a fake network, where we don&#39;t check that the carrier fingerprints are correct. This allows us to create fake networks for development without interfering with the real network. </p><h3 id="--step-ames--identity-stage-"><code>++step:ames</code>, identity stage </h3><pre>    ++  step  ,[p=bray q=gens r=pass]                       ::  identity stage
</pre><p>This is a single stage in our identity. Thus, this is specific to a single life in a single ship. Everything in here may change between lives. </p><p><code>p</code> </p><p><code>q</code> </p><p><code>r</code> is the public key for this stage in the identity. </p><h3 id="--bray-ames-"><code>++bray:ames</code> </h3><pre>    ++  bray  ,[p=life q=(unit life) r=ship s=@da]          ::  our parent us now
</pre><p>XXX </p><h3 id="--gens-ames--general-identity-"><code>++gens:ames</code>, general identity </h3><pre>    ++  gens  ,[p=lang q=gcos]                              ::  general identity
</pre><p><code>p</code> is the IETF language code for the preferred language of this identity. This is unused at the moment, but in the future text should be localized based on this. </p><p><code>q</code> is the description of the ship. </p><h3 id="--gcos-ames--identity-description-"><code>++gcos:ames</code>, identity description </h3><pre>    ++  gcos                                                ::  id description
              $%  [%czar ~]                                 ::  8-bit ship
                  [%duke p=what]                            ::  32-bit ship
                  [%earl p=@t]                              ::  64-bit ship
                  [%king p=@t]                              ::  16-bit ship
                  [%pawn p=(unit ,@t)]                      ::  128-bit ship
              ==                                            ::
</pre><p>This is the description of the identity of a ship. Most types of identity have a <code>@t</code> field, which is their human-readable name. The identity of a <code>%duke</code> is more involved. </p><p>A <code>%czar</code>, a carrier, is a ship with an 8-bit address. Thus, there are only 256 carriers. These are at the top of the namespace hierarchy, and the fingerprint of each carrier is stored in <code>++zeno</code>. These are the “senators” of Urbit. </p><p>A <code>%king</code>, a cruiser, is a ship with a 16-bit address. Thus, there are 65,536 cruisers. Each carrier may issue 256 cruisers. These are the infrastructure of Urbit. </p><p>A <code>%duke</code>, a destroyer, is a ship with a 32-bit address. Thus, there are 4,294,967,296 destroyers. Each cruiser may issue 65,536 cruisers. These are the individuals of Urbit. </p><p>A <code>%earl</code>, a yacht, is a ship with a 64-bit address. Thus, there are 18,446,744,073,709,551,616 yachts. Each destroyer may issue 4,294,967,296 yachts. These are the devices of Urbit. </p><p>A <code>%pawn</code>, a submarine, is a ship with a 128-bit address. Thus, there are a lot of submarines. The chance of random name collision is negligible, so submarines are not issued by any ship. They must simply assert their presence, and they are all considered children of ~zod. This is the underworld of Urbit, where anonymity reigns supreme. </p><h3 id="--what-ames--logical-destroyer-identity-"><code>++what:ames</code>, logical destroyer identity </h3><pre>    ++  what                                                ::  logical identity
              $%  [%anon ~]                                 ::  anonymous
                  [%lady p=whom]                            ::  female person ()
                  [%lord p=whom]                            ::  male person []
                  [%punk p=sect q=@t]                       ::  opaque handle &quot;&quot;
              ==                                            ::
</pre><p>This is the logical identity of a destroyer. </p><p>A <code>%anon</code> is a completely anonymous destroyer. The difference between this and a submarine is that a submarine is ephemeral while a <code>%anon</code> destroyer is not. Thus, we may not know who ~hoclur-bicrel is, but we do know that it&#39;s always the same person. </p><p>A <code>%lady</code> is a female person. The name used here should be a real name. </p><p>A <code>%lord</code> is a male person. The name used here should be a real name. </p><p>A <code>%punk</code> is a person who is identified only by a handle. </p><h3 id="--whom-ames--real-person-"><code>++whom:ames</code>, real person </h3><pre>    ++  whom  ,[p=@ud q=govt r=sect s=name]                 ::  year/govt/id
</pre><p>Ths is the information associated with a real person. It is mostly information that could be observed with the briefest of interactions. </p><p><code>p</code> is the birth year. </p><p><code>q</code> is the location of a user, usually of the form “country/zip”. </p><p><code>r</code> is the sect of the user. </p><p><code>s</code> is the real name of the person. </p><h3 id="--govt-ames-"><code>++govt:ames</code> </h3><pre>    ++  govt  path                                          ::  country/postcode
</pre><p>This is the location of the user, usually of the form “country/zip”. </p><h3 id="--sect-ames-"><code>++sect:ames</code> </h3><pre>    ++  sect  ?(%black %blue %red %orange %white)           ::  banner
</pre><p>XXX </p><h3 id="--name-ames-"><code>++name:ames</code> </h3><pre>    ++  name  ,[p=@t q=(unit ,@t) r=(unit ,@t) s=@t]        ::  first mid/nick last
</pre><p>This is the given name, possible middle name/initial, possible nickname, and surname of a user. </p></div></div></div></div></div><footer class="mb-36"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>