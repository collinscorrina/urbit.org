<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Docs</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div id="sidebar-mobile" class="bg-gray-light sidebar-hide overflow-y"><div class="container"><div class="col-sm-10"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div><div class="col-sm-1 sidebar-toggle fixed" style="top: 20px; right: 1em"><img class="w-8 h-8 dropdown-right" src="/assets/dropdown.svg" /></div></div></div><div class="container mt-10"><div class="sidebar-container row col-sm-3 fixed pb-30 h-100-md"><div class="col-sm-3 col-lg-6 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-12 mt-7 sidebar-toggle md-hide"><img class="w-8 h-8 dropdown-left" src="/assets/dropdown.svg" /></div><div class="h-100 col-sm-8 col-md-11 overflow-y sm-hide"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-2 col-md-offset-3 docs"><div><div><h1 id="clay-">Clay </h1><p>Our filesystem. </p><p><code>%clay</code> is version-controlled, referentially-transparent, and global. While this filesystem is stored in <code>%clay</code>, it is mirrored to Unix for convenience. Unix tells <code>%clay</code>s whenever a file changes in the Unix copy of the filesystem so that the change may be applied. <code>%clay</code> tells unix whenever an app or vane changes the filesystem so that the change can be effected in Unix. Apps and vanes may use <code>%clay</code> to write to the filesystem, query it, and subscribe to changes in it. Ford and gall use <code>%clay</code> to serve up apps and web pages. </p><p><code>%clay</code> includes three components. First is the filesystem/version control algorithms, which are mostly defined in <code>++ze</code> and <code>++zu</code> in zuse. Second is the write, query, and subscription logic. Finally, there is the logic for communicating requests to, and receiving requests from, foreign ships. </p><h2><div id="architecture">Architecture</div></h2><p>Clay is the primary filesystem for the arvo operating system, which is the core of an urbit. The architecture of clay is intrinsically connected with arvo, but we assume no knowledge of either arvo or urbit. We will point out only those features of arvo that are necessary for an understanding of clay, and we will do so only when they arise. </p><p>The first relevant feature of arvo is that it is a deterministic system where input and output are defined as a series of events and effects. The state of arvo is simply a function of its event log. None of the effects from an event are emitted until the event is entered in the log and persisted, either to disk or another trusted source of persistence, such as a Kafka cluster. Consequently, arvo is a single-level store: everything in its state is persistent. </p><p>In a more traditional OS, everything in RAM can be erased at any time by power failure, and is always erased on reboot. Thus, a primary purpose of a filesystem is to ensure files persist across power failures and reboots. In arvo, both power failures and reboots are special cases of suspending computation, which is done safely since our event log is already persistent. Therefore, clay is not needed in arvo for persistence. Why, then, do we have a filesystem? There are two answers to this question. </p><p>First, clay provides a filesystem tree, which is a convenient user interface for some applications. Unix has the useful concept of virtual filesystems, which are used for everything from direct access to devices, to random number generators, to the /proc tree. It is easy and intuitive to read from and write to a filesystem tree. </p><p>Second, clay has a distributed revision control system baked into it. Traditional filesystems are not revision controlled, so userspace software -- such as git -- is written on top of them to do so. clay natively provides the same functionality as modern DVCSes, and more. </p><p>clay has two other unique properties that we&#39;ll cover later on: it supports typed data and is referentially transparent. </p><h3 id="revision-control-">Revision Control </h3><p>Every urbit has one or more “desks”, which are independently revision-controlled branches. Each desk contains its own mark definitions, apps, doc, and so forth. </p><p>Traditionally, an urbit has at least a base and a home desk. The base desk has all the system software from the distribution. the home desk is a fork of base with all the stuff specific to the user of the urbit. </p><p>A desk is a series of numbered commits, the most recent of which represents the current state of the desk. A commit is composed of (1) an absolute time when it was created, (2) a list of zero or more parents, and (3) a map from paths to data. </p><p>Most commits have exactly one parent, but the initial commit on a desk may have zero parents, and merge commits have more than one parent. </p><p>The non-meta data is stored in the map of paths to data. It&#39;s worth noting that no constraints are put on this map, so, for example, both /a/b and /a/b/c could have data. This is impossible in a traditional Unix filesystem since it means that /a/b is both a file and a directory. Conventionally, the final element in the path is its mark -- much like a filename extension in Unix. Thus, /doc/readme.md in Unix is stored as /doc/readme/md in urbit. </p><p>The data is not stored directly in the map; rather, a hash of the data is stored, and we maintain a master blob store. Thus, if the same data is referred to in multiple commits (as, for example, when a file doesn&#39;t change between commits), only the hash is duplicated. </p><p>In the master blob store, we either store the data directly, or else we store a diff against another blob. The hash is dependent only on the data within and not on whether or not it&#39;s stored directly, so we may on occasion rearrange the contents of the blob store for performance reasons. </p><p>Recall that a desk is a series of numbered commits. Not every commit in a desk must be numbered. For example, if the base desk has had 50 commits since home was forked from it, then a merge from base to home will only add a single revision number to home, although the full commit history will be accessible by traversing the parentage of the individual commits. </p><p>We do guarantee that the first commit is numbered 1, commits are numbered consecutively after that (i.e. there are no “holes”), the topmost commit is always numbered, and every numbered commit is an ancestor of every later numbered commit. </p><p>There are three ways to refer to particular commits in the revision history. Firstly, one can use the revision number. Secondly, one can use any absolute time between the one numbered commit and the next (inclusive of the first, exclusive of the second). Thirdly, every desk has a map of labels to revision numbers. These labels may be used to refer to specific commits. </p><p>Additionally, clay is a global filesystem, so data on other urbit is easily accessible the same way as data on our local urbit. In general, the path to a particular revision of a desk is /~urbit-name/desk-name/revision. Thus, to get /try/readme/md from revision 5 of the home desk on ~sampel-sipnym, we refer to /~sampel-sipnym/home/5/try/readme/md. Clay&#39;s namespace is thus global and referentially transparent. </p><p>XXX reactivity here? </p><h3 id="a-typed-filesystem-">A Typed Filesystem </h3><p>Since clay is a general filesystem for storing data of arbitrary types, in order to revision control correctly it needs to be aware of types all the way through. Traditional revision control does an excellent job of handling source code, so for source code we act very similar to traditional revision control. The challenge is to handle other data similarly well. </p><p>For example, modern VCSs generally support “binary files”, which are files for which the standard textual diffing, patching, and merging algorithms are not helpful. A “diff” of two binary files is just a pair of the files, “patching” this diff is just replacing the old file with the new one, and “merging” non-identical diffs is always a conflict, which can&#39;t even be helpfully annotated. Without knowing anything about the structure of a blob of data, this is the best we can do. </p><p>Often, though, “binary” files have some internal structure, and it is possible to create diff, patch, and merge algorithms that take advantage of this structure. An image may be the result of a base image with some set of operations applied. With algorithms aware of this set of operations, not only can revision control software save space by not having to save every revision of the image individually, these transformations can be made on parallel branches and merged at will. </p><p>Suppose Alice is tasked with touching up a picture, improving the color balance, adjusting the contrast, and so forth, while Bob has the job of cropping the picture to fit where it&#39;s needed and adding textual overlay. Without type-aware revision control, these changes must be made serially, requiring Alice and Bob to explicitly coordinate their efforts. With type-aware revision control, these operations may be performed in parallel, and then the two changesets can be merged programmatically. </p><p>Of course, even some kinds of text files may be better served by diff, patch, and merge algorithms aware of the structure of the files. Consider a file containing a pretty-printed JSON object. Small changes in the JSON object may result in rather significant changes in how the object is pretty-printed (for example, by addding an indentation level, splitting a single line into multiple lines). </p><p>A text file wrapped at 80 columns also reacts suboptimally with unadorned Hunt-McIlroy diffs. A single word inserted in a paragraph may push the final word or two of the line onto the next line, and the entire rest of the paragraph may be flagged as a change. Two diffs consisting of a single added word to different sentences may be flagged as a conflict. In general, prose should be diffed by sentence, not by line. </p><p>As far as the author is aware, clay is the first generalized, type-aware revision control system. We&#39;ll go into the workings of this system in some detail. </p><h3 id="marks-">Marks </h3><p>Central to a typed filesystem is the idea of types. In clay, we call these “marks”. A mark is a file that defines a type, conversion routines to and from the mark, and diff, patch, and merge routines. </p><p>For example, a <code>%txt</code> mark may be a list of lines of text, and it may include conversions to <code>%mime</code> to allow it to be serialized and sent to a browswer or to the unix filesystem. It will also include Hunt-McIlroy diff, patch, and merge algorithms. </p><p>A <code>%json</code> mark would be defined as a json object in the code, and it would have a parser to convert from <code>%txt</code> and a printer to convert back to <code>%txt</code>. The diff, patch, and merge algorithms are fairly straightforward for json, though they&#39;re very different from the text ones. </p><p>More formally, a mark is a core with three arms, <code>++grab</code>, <code>++grow</code>, and <code>++grad</code>. In <code>++grab</code> is a series of functions to convert from other marks to the given mark. In <code>++grow</code> is a series of functions to convert from the given mark to other marks. In <code>++grad</code> is <code>++diff</code>, <code>++pact</code>, <code>++join</code>, and <code>++mash</code>. </p><p>The types are as follows, in an informal pseudocode: </p><pre>    ++  grab:
      ++  mime: &lt;mime&gt; -&gt; &lt;mark-type&gt;
      ++  txt: &lt;txt&gt; -&gt; &lt;mark-type&gt;
      ...
    ++  grow:
      ++  mime: &lt;mark-type&gt; -&gt; &lt;mime&gt;
      ++  txt: &lt;mark-type&gt; -&gt; &lt;txt&gt;
      ...
    ++  grad
      ++  diff: (&lt;mark-type&gt;, &lt;mark-type&gt;) -&gt; &lt;diff-type&gt;
      ++  pact: (&lt;mark-type&gt;, &lt;diff-type&gt;) -&gt; &lt;mark-type&gt;
      ++  join: (&lt;diff-type&gt;, &lt;diff-type&gt;) -&gt; &lt;diff-type&gt; or NULL
      ++  mash: (&lt;diff-type&gt;, &lt;diff-type&gt;) -&gt; &lt;diff-type&gt;
</pre><p>These types are basically what you would expect. Not every mark has each of these functions defined -- all of them are optional in the general case. </p><p>In general, for a particular mark, the <code>++grab</code> and <code>++grow</code> entries (if they exist) should be inverses of each other. </p><p>In <code>++grad</code>, <code>++diff</code> takes two instances of a mark and produces a diff of them. <code>++pact</code> takes an instance of a mark and patches it with the given diff. <code>++join</code> takes two diffs and attempts to merge them into a single diff. If there are conflicts, it produces null. <code>++mash</code> takes two diffs and forces a merge, annotating any conflicts. </p><p>In general, if <code>++diff</code> called with A and B produces diff D, then <code>++pact</code> called with A and D should produce B. Also, if <code>++join</code> of two diffs does not produce null, then <code>++mash</code> of the same diffs should produce the same result. </p><p>Alternately, instead of <code>++diff</code>, <code>++pact</code>, <code>++join</code>, and <code>++mash</code>, a mark can provide the same functionality by defining <code>++sted</code> to be the name of another mark to which we wish to delegate the revision control responsibilities. Then, before running any of those functions, clay will convert to the other mark, and convert back afterward. For example, the <code>%hoon</code> mark is revision-controlled in the same way as <code>%txt</code>, so its <code>++grad</code> is simply <code>++sted %txt</code>. Of course, <code>++txt</code> must be defined in <code>++grow</code> and <code>++grab</code> as well. </p><p>Every file in clay has a mark, and that mark must have a fully-functioning <code>++grad</code>. Marks are used for more than just clay, and other marks don&#39;t need a <code>++grad</code>, but if a piece of data is to be saved to clay, we must know how to revision-control it. </p><p>Additionally, if a file is to be synced out to unix, then it must have conversion routines to and from the <code>%mime</code> mark. </p><h2 id="using-clay-">Using clay </h2><h3 id="reading-and-subscribing-">Reading and Subscribing </h3><p>When reading from Clay, there are three types of requests. A <code>%sing</code> request asks for data at single revsion. A <code>%next</code> request asks to be notified the next time there&#39;s a change to given file. A <code>%many</code> request asks to be notified on every change in a desk for a range of changes. </p><p>For <code>%sing</code> and <code>%next</code>, there are generally three things to be queried. A <code>%u</code> request simply checks for the existence of a file at a path. A <code>%x</code> request gets the data in the file at a path. A <code>%y</code> request gets a hash of the data in the file at the path combined with all its children and their data. Thus, <code>%y</code> of a node changes if it or any of its children change. </p><p>A <code>%sing</code> request is fulfilled immediately if possible. If the requested revision is in the future, or is on another ship for which we don&#39;t have the result cached, we don&#39;t respond immediately. If the requested revision is in the future, we wait until the revision happens before we respond to the request. If the request is for data on another ship, we pass on the request to the other ship. In general, Clay subscriptions, like most things in Urbit, aren&#39;t guaranteed to return immediately. They&#39;ll return when they can, and they&#39;ll do so in a referentially transparent manner. </p><p>A <code>%next</code> request checks query at the given revision, and it produces the result of the query the next time it changes, along with the revsion number when it changes. Thus, a <code>%next</code> of a <code>%u</code> is triggered when a file is added or deleted, a <code>%next</code> of a <code>%x</code> is triggered when a file is added, deleted, or changed, and a <code>%next</code> of a <code>%y</code> is triggered when a file or any of its children is added, deleted, or changed. </p><p>A <code>%many</code> request is triggered every time the given desk has a new revision. Unlike a <code>%next</code>, a <code>%many</code> has both a start and an end revsion, after which it stops returning. For <code>%next</code>, a single change is reported, and if the caller wishes to hear of the next change, it must resubscribe. For <code>%many</code>, every revsion from the start to the end triggers a response. Since a <code>%many</code> request doesn&#39;t ask for any particular data, there aren&#39;t <code>%u</code>, <code>%x</code>, and <code>%y</code> versions for it. </p><h3 id="unix-sync-">Unix sync </h3><p>One of the primary functions of clay is as a convenient user interface. While tools exist to use clay from within urbit, it&#39;s often useful to be able to treat clay like any other filesystem from the Unix perspective -- to “mount” it, as it were. </p><p>From urbit, you can run <code>|mount /path/to/directory %mount-point</code>, and this will mount the given clay directory to the mount-point directory in Unix. Every file is converted to <code>%mime</code> before it&#39;s written to Unix, and converted back when read from Unix. The entire directory is watched (a la Dropbox), and every change is auto-committed to clay. </p><h3 id="merging-">Merging </h3><p>Merging is a fundamental operation for a distributed revision control system. At their root, clay&#39;s merges are similar to git&#39;s, but with some additions to accomodate typed data. There are seven different merge strategies. </p><p>Throughout our discussion, we&#39;ll say that the merge is from Alice&#39;s desk to Bob&#39;s. Recall that a commit is a date (for all new commits this will be the current date), a list of parents, and the data itself. </p><p>A <code>%init</code> merge should be used iff it&#39;s the first commit to a desk. The head of Alice&#39;s desk is used as the number 1 commit to Bob&#39;s desk. Obviously, the ancestry remains intact through traversing the parentage of the commit even though previous commits are not numbered for Bob&#39;s desk. </p><p>A <code>%this</code> merge means to keep what&#39;s in Bob&#39;s desk, but join the ancestry. Thus, the new commit has the head of each desk as parents, but the data is exactly what&#39;s in Bob&#39;s desk. For those following along in git, this is the &#39;ours&#39; merge strategy, not the &#39;--ours&#39; option to the &#39;recursive&#39; merge strategy. In other words, even if Alice makes a change that does not conflict with Bob, we throw it away. It&#39;s Bob&#39;s way or the highway. </p><p>A <code>%that</code> merge means to take what&#39;s in Alice&#39;s desk, but join the ancestry. This is the reverse of <code>%this</code>. </p><p>A <code>%fine</code> merge is a “fast-forward” merge. This succeeds iff one head is in the ancestry of the other. In this case, we use the descendant as our new head. </p><p>For <code>%meet</code>, <code>%mate</code>, and <code>%meld</code> merges, we first find the most recent common ancestor to use as our merge base. If we have no common ancestors, then we fail. If we have more than one most recent common ancestor, then we have a criss-cross situation, which should be handled delicately. At present, we delicately throw up our hands and give up, but something akin to git&#39;s &#39;recursive&#39; strategy should be implemented in the future. </p><p>There&#39;s a functional inclusion ordering on <code>%fine</code>, <code>%meet</code>, <code>%mate</code>, and <code>%meld</code> such that if an earlier strategy would have succeeded, then every later strategy will produce the same result. Put another way, every earlier strategy is the same as every later strategy except with a restricted domain. </p><p>A <code>%meet</code> merge only succeeds if the changes from the merge base to Alice&#39;s head (hereafter, “Alice&#39;s changes”) are in different files than Bob&#39;s changes. In this case, the parents are both Alice&#39;s and Bob&#39;s heads, and the data is the merge base plus Alice&#39;s changed files plus Bob&#39;s changed files. </p><p>A <code>%mate</code> merge attempts to merge changes to the same file when both Alice and bob change it. If the merge is clean, we use it; otherwise, we fail. A merge between different types of changes -- for example, deleting a file vs changing it -- is always a conflict. If we succeed, the parents are both Alice&#39;s and Bob&#39;s heads, and the data is the merge base plus Alice&#39;s changed files plus Bob&#39;s changed files plus the merged files. </p><p>A <code>%meld</code> merge will succeed even if there are conflicts. If there are conflicts in a file, then we use the merge base&#39;s version of that file, and we produce a set of files with conflicts. The parents are both Alice&#39;s and Bob&#39;s heads, and the data is the merge base plus Alice&#39;s changed files plus Bob&#39;s changed files plus the successfully merged files plus the merge base&#39;s version of the conflicting files. </p><p>That&#39;s the extent of the merge options in clay proper. In userspace there&#39;s a final option <code>%auto</code>, which is the most common. <code>%auto</code> checks to see if Bob&#39;s desk exists, and if it doesn&#39;t we use a <code>%init</code> merge. Otherwise, we progressively try <code>%fine</code>, <code>%meet</code>, and <code>%mate</code> until one succeeds. </p><p>If none succeed, we merge Bob&#39;s desk into a scratch desk. Then, we merge Alice&#39;s desk into the scratch desk with the <code>%meld</code> option to force the merge. For each file in the produced set of conflicting files, we call the <code>++mash</code> function for the appropriate mark, which annotates the conflicts if we know how. </p><p>Finally, we display a message to the user informing them of the scratch desk&#39;s existence, which files have annotated conflicts, and which files have unannotated conflicts. When the user has resolved the conflicts, they can merge the scratch desk back into Bob&#39;s desk. This will be a <code>%fine</code> merge since Bob&#39;s head is in the ancestry of the scratch desk. </p><h3 id="autosync-">Autosync </h3><p>Tracking and staying in sync with another desk is another fundamental operation. We call this “autosync”. This doesn&#39;t mean simply mirroring a desk, since that wouldn&#39;t allow local changes. We simply want to apply changes as they are made upstream, as long as there are no conflicts with local changes. </p><p>This is implemented by watching the other desk, and, when it has changes, merging these changes into our desk with the usual merge strategies. </p><p>Note that it&#39;s quite reasonable for two desks to be autosynced to each other. This results in any change on one desk being mirrored to the other and vice versa. </p><p>Additionally, it&#39;s fine to set up an autosync even if one desk, the other desk, or both desks do not exist. The sync will be activated when the upstream desk comes into existence and will create the downstream desk if needed. </p><h2><div id="commentary">Commentary</div></h2><p>The first part of this section will be reference documentation for the data types used by our filesystem. In fact, as a general guide, we recommend reading and attempting to understand the data structures used in any Hoon code before you try to read the code itself. Although complete understanding of the data structures is impossible without seeing them used in the code, an 80% understanding greatly clarifies the code. As another general guide, when reading Hoon, it rarely pays off to understand every line of code when it appears. Try to get the gist of it, and then move on. The next time you come back to it, it&#39;ll likely make a lot more sense. </p><p>After a description of the data models, we&#39;ll give an overview of the interface that vanes and applications can use to interact with the filesystem. </p><p>Finally, we&#39;ll dive into the code and the algorithms themselves. You know, the fun part. </p><h3 id="data-models-">Data Models </h3><p>As you&#39;re reading through this section, remember you can always come back to this when you run into these types later on. You&#39;re not going to remember everything the first time through, but it is worth reading, or at least skimming, this so that you get a rough idea of how our state is organized. </p><p>The types that are certainly worth reading are <code>++raft</code>, <code>++room</code>, <code>++dome:clay</code>, <code>++ankh:clay</code>, <code>++rung:clay</code>, <code>++rang:clay</code>, <code>++blob:clay</code>, <code>++yaki:clay</code>, and <code>++nori:clay</code> (possibly in that order). All in all, though, this section isn&#39;t too long, so many readers may wish to quickly read through all of it. If you get bored, though, just skip to the next section. You can always come back when you need to. </p><h3 id="--raft--formal-state-"><code>++raft</code>, formal state </h3><pre>    ++  raft                                                ::  filesystem
              $:  fat=(map ship room)                       ::  domestic
                  hoy=(map ship rung)                       ::  foreign
                  ran=rang                                  ::  hashes
              ==                                            ::
</pre><p>This is the state of our vane. Anything that must be remembered between calls to clay is stored in this state. </p><p><code>fat</code> is the set of domestic servers. This stores all the information that is specfic to a particular ship on this pier. The keys to this map are the ships on the current pier. all the information that is specific to a particular foreign ship. The keys to this map are all the ships whose filesystems we have attempted to access through clay. </p><p><code>ran</code> is the store of all commits and deltas, keyed by hash. The is where all the “real” data we know is stored; the rest is “just bookkeeping”. </p><h4 id="--room--filesystem-per-domestic-ship-"><code>++room</code>, filesystem per domestic ship </h4><pre>    ++  room                                                ::  fs per ship
              $:  hun=duct                                  ::  terminal duct
                  hez=(unit duct)                           ::  sync duch
                  dos=(map desk dojo)                       ::  native desk
              ==                                            ::
</pre><p>This is the representation of the filesystem of a ship on our pier. </p><p><code>hun</code> is the duct we use to send messages to dill to display notifications of filesystem changes. Only <code>%note</code> gifts should be produced along this duct. This is set by the <code>%init</code> kiss. </p><p><code>hez</code>, if present, is the duct we use to send sync messages to unix so that they end up in the pier unix directory. Only <code>%ergo</code> gifts should be producd along this duct. This is set by <code>%into</code> and <code>%invo</code> kisses. </p><p><code>dos</code> is a well-known operating system released in 1981. It is also the set of desks on this ship, mapped to their data. </p><h4 id="--desk--filesystem-branch-"><code>++desk</code>, filesystem branch </h4><pre>    ++  desk  ,@tas                                         ::  ship desk case spur
</pre><p>This is the name of a branch of the filesystem. The default desks are “arvo”, “main”, and “try”. More may be created by simply referencing them. Desks have independent histories and states, and they may be merged into each other. </p><h3 id="--dojo--domestic-desk-state-"><code>++dojo</code>, domestic desk state </h3><pre>    ++  dojo  ,[p=cult q=dome]                              ::  domestic desk state
</pre><p>This is the all the data that is specific to a particular desk on a domestic ship. <code>p</code> is the set of subscribers to this desk and <code>q</code> is the data in the desk. </p><h4 id="--cult--subscriptions-"><code>++cult</code>, subscriptions </h4><pre>    ++  cult  (map duct rave)                               ::  subscriptions
</pre><p>This is the set of subscriptions to a particular desk. The keys are the ducts from where the subscriptions requests came. The results will be produced along these ducts. The values are a description of the requested information. </p><h4 id="--rave-clay--general-subscription-request-"><code>++rave:clay</code>, general subscription request </h4><pre>    ++  rave                                                ::  general request
              $%  [&amp; p=mood]                                ::  single request
                  [| p=moat]                                ::  change range
              ==                                            ::
</pre><p>This represents a subscription request for a desk. The request can be for either a single item in the desk or else for a range of changes on the desk. </p><h3 id="--rove--stored-general-subscription-request-"><code>++rove</code>, stored general subscription request </h3><pre>    ++  rove  (each mood moot)                              ::  stored request
</pre><p>When we store a request, we store subscriptions with a little extra information so that we can determine whether new versions actually affect the path we&#39;re subscribed to. </p><h4 id="--mood-clay--single-subscription-request-"><code>++mood:clay</code>, single subscription request </h4><pre>    ++  mood  ,[p=care q=case r=path]                       ::  request in desk
</pre><p>This represents a request for the state of the desk at a particular commit, specfied by <code>q</code>. <code>p</code> specifies what kind of information is desired, and <code>r</code> specifies the path we are requesting. </p><h4 id="--moat-clay--range-subscription-request-"><code>++moat:clay</code>, range subscription request </h4><pre>    ++  moat  ,[p=case q=case r=path]                       ::  change range
</pre><p>This represents a request for all changes between <code>p</code> and <code>q</code> on path <code>r</code>. You will be notified when a change is made to the node referenced by the path or to any of its children. </p><h3 id="--moot--stored-range-subscription-request-"><code>++moot</code>, stored range subscription request </h3><pre>    ++  moot  ,[p=case q=case r=path s=(map path lobe)]     ::
</pre><p>This is just a <code>++moat:clay</code> plus a map of paths to lobes. This map represents the data at the node referenced by the path at case <code>p</code>, if we&#39;ve gotten to that case (else null). We only send a notification along the subscription if the data at a new revision is different than it was. </p><h3 id="--care-clay--clay-submode-"><code>++care:clay</code>, clay submode </h3><pre>    ++  care  ?(%u %v %w %x %y %z)                          ::  clay submode
</pre><p>This specifies what type of information is requested in a subscription or a scry. </p><p><code>%u</code> requests the <code>++rang:clay</code> at the current moment. Because this information is not stored for any moment other than the present, we crash if the <code>++case:clay</code> is not a <code>%da</code> for now. </p><p><code>%v</code> requests the <code>++dome:clay</code> at the specified commit. </p><p><code>%w</code> requests the revsion number of the desk. </p><p><code>%x</code> requests the file at a specified path at the specified commit. If there is no node at that path or if the node has no contents (that is, if <code>q:ankh</code> is null), then this produces null. </p><p><code>%y</code> requests a <code>++arch</code> of the specfied commit at the specified path. </p><p><code>%z</code> requests the <code>++ankh</code> of the specified commit at the specfied path. </p><h3 id="--arch--shallow-filesystem-node-"><code>++arch</code>, shallow filesystem node </h3><pre>    ++  arch  ,[p=@uvI q=(unit ,@uvI) r=(map ,@ta ,~)]      ::  fundamental node
</pre><p>This is analogous to <code>++ankh:clay</code> except that the we have neither our contents nor the ankhs of our children. The other fields are exactly the same, so <code>p</code> is a hash of the associated ankh, <code>u.q</code>, if it exists, is a hash of the contents of this node, and the keys of <code>r</code> are the names of our children. <code>r</code> is a map to null rather than a set so that the ordering of the map will be equivalent to that of <code>r:ankh</code>, allowing efficient conversion. </p><h4 id="--case-clay--specifying-a-commit-"><code>++case:clay</code>, specifying a commit </h4><pre>    ++  case                                                ::  ship desk case spur
              $%  [%da p=@da]                               ::  date
                  [%tas p=@tas]                             ::  label
                  [%ud p=@ud]                               ::  number
              ==                                            ::
</pre><p>A commit can be referred to in three ways: <code>%da</code> refers to the commit that was at the head on date <code>p</code>, <code>%tas</code> refers to the commit labeled <code>p</code>, and <code>%ud</code> refers to the commit numbered <code>p</code>. Note that since these all can be reduced down to a <code>%ud</code>, only numbered commits may be referenced with a <code>++case:clay</code>. </p><h4 id="--dome-clay--desk-data-"><code>++dome:clay</code>, desk data </h4><pre>    ++  dome                                                ::  project state
              $:  ang=agon                                  ::  pedigree
                  ank=ankh                                  ::  state
                  let=@ud                                   ::  top id
                  hit=(map ,@ud tako)                       ::  changes by id
                  lab=(map ,@tas ,@ud)                      ::  labels
              ==                                            ::
</pre><p>This is the data that is actually stored in a desk. </p><p><code>ang</code> is unused and should be removed. </p><p><code>ank</code> is the current state of the desk. Thus, it is the state of the filesystem at revison <code>let</code>. The head of a desk is always a numbered commit. </p><p><code>let</code> is the number of the most recently numbered commit. This is also the total number of numbered commits. </p><p><code>hit</code> is a map of numerical ids to hashes of commits. These hashes are mapped into their associated commits in <code>hut:rang:clay</code>. In general, the keys of this map are exactly the numbers from 1 to <code>let</code>, with no gaps. Of course, when there are no numbered commits, <code>let</code> is 0, so <code>hit</code> is null. Additionally, each of the commits is an ancestor of every commit numbered greater than this one. Thus, each is a descendant of every commit numbered less than this one. Since it is true that the date in each commit (<code>t:yaki</code>) is no earlier than that of each of its parents, the numbered commits are totally ordered in the same way by both pedigree and date. Of course, not every commit is numbered. If that sounds too complicated to you, don&#39;t worry about it. It basically behaves exactly as you would expect. </p><p><code>lab</code> is a map of textual labels to numbered commits. Note that labels can only be applied to numbered commits. Labels must be unique across a desk. </p><h4 id="--ankh--filesystem-node-"><code>++ankh</code>, filesystem node </h4><pre>    ++  ankh                                                ::  fs node (new)
              $:  p=cash                                    ::  recursive hash
                  q=(unit ,[p=cash q=*])                    ::  file
                  r=(map ,@ta ankh)                         ::  folders
              ==                                            ::
</pre><p>This is a single node in the filesystem. This may be file or a directory or both. In earth filesystems, a node is a file xor a directory. On mars, we&#39;re inclusive, so a node is a file ior a directory. </p><p><code>p</code> is a recursive hash that depends on the contents of the this file or directory and on any children. </p><p><code>q</code> is the contents of this file, if any. <code>p.q</code> is a hash of the contents while <code>q.q</code> is the data itself. </p><p><code>r</code> is the set of children of this node. In the case of a pure file, this is empty. The keys are the names of the children and the values are, recursively, the nodes themselves. </p><h4 id="--cash--ankh-hash-"><code>++cash</code>, ankh hash </h4><pre>    ++  cash  ,@uvH                                         ::  ankh hash
</pre><p>This is a 128-bit hash of an ankh. These are mostly stored within ankhs themselves, and they are used to check for changes in possibly-deep hierarchies. </p><h4 id="--rung--filesystem-per-neighbor-ship-"><code>++rung</code>, filesystem per neighbor ship </h4><pre>    ++  rung  $:  rus=(map desk rede)                       ::  neighbor desks
              ==                                            ::
</pre><p>This is the filesystem of a neighbor ship. The keys to this map are all the desks we know about on their ship. </p><h4 id="--rede--desk-state-"><code>++rede</code>, desk state </h4><pre>    ++  rede                                                ::  universal project
              $:  lim=@da                                   ::  complete to
                  qyx=cult                                  ::  subscribers
                  ref=(unit rind)                           ::  outgoing requests
                  dom=dome                                  ::  revision state
              ==                                            ::
</pre><p>This is our knowledge of the state of a desk, either foreign or domestic. </p><p><code>lim</code> is the date of the last full update. We only respond to requests for stuff before this time. </p><p><code>qyx</code> is the list of subscribers to this desk. For domestic desks, this is simply <code>p:dojo</code>, all subscribers to the desk, while in foreign desks this is all the subscribers from our ship to the foreign desk. </p><p><code>ref</code> is the request manager for the desk. For domestic desks, this is null since we handle requests ourselves. </p><p><code>dom</code> is the actual data in the desk. </p><h4 id="--rind--request-manager-"><code>++rind</code>, request manager </h4><pre>    ++  rind                                                ::  request manager
              $:  nix=@ud                                   ::  request index
                  bom=(map ,@ud ,[p=duct q=rave])           ::  outstanding
                  fod=(map duct ,@ud)                       ::  current requests
                  haw=(map mood (unit))                     ::  simple cache
              ==                                            ::
</pre><p>This is the request manager for a foreign desk. </p><p><code>nix</code> is one more than the index of the most recent request. Thus, it is the next available request number. </p><p><code>bom</code> is the set of outstanding requests. The keys of this map are some subset of the numbers between 0 and one less than <code>nix</code>. The members of the map are exactly those requests that have not yet been fully satisfied. </p><p><code>fod</code> is the same set as <code>bom</code>, but from a different perspective. In particular, the values of <code>fod</code> are the same as the values of <code>bom</code>, and the <code>p</code> out of the values of <code>bom</code> are the same as the keys of <code>fod</code>. Thus, we can map ducts to their associated request number and <code>++rave:clay</code>, and we can map numbers to their associated duct and <code>++rave:clay</code>. </p><p><code>haw</code> is a map from simple requests to their values. This acts as a cache for requests that have already been made. Thus, the second request for a particular <code>++mood:clay</code> is nearly instantaneous. </p><h4 id="--rang-clay--data-store-"><code>++rang:clay</code>, data store </h4><pre>    ++  rang  $:  hut=(map tako yaki)                       ::
                  lat=(map lobe blob)                       ::
              ==                                            ::
</pre><p>This is a set of data keyed by hash. Thus, this is where the “real” data is stored, but it is only meaningful if we know the hash of what we&#39;re looking for. </p><p><code>hut</code> is a map from hashes to commits. We often get the hashes from <code>hit:dome:clay</code>, which keys them by logical id. Not every commit has an id. </p><p><code>lat</code> is a map from hashes to the actual data. We often get the hashes from a <code>++yaki</code>, a commit, which references this map to get the data. There is no <code>++blob:clay</code> in any <code>++yaki:clay</code>. They are only accessible through this map. </p><h4 id="--tako-clay--commit-reference-"><code>++tako:clay</code>, commit reference </h4><pre>    ++  tako  ,@                                            ::  yaki ref
</pre><p>This is a hash of a <code>++yaki:clay</code>, a commit. These are most notably used as the keys in <code>hut:rang:clay</code>, where they are associated with the actual <code>++yaki:clay</code>, and as the values in <code>hit:dome:clay</code>, where sequential ids are associated with these. </p><h4 id="--yaki-clay--commit-"><code>++yaki:clay</code>, commit </h4><pre>    ++  yaki  ,[p=(list tako) q=(map path lobe) r=tako t=@da] ::  commit
</pre><p>This is a single commit. </p><p><code>p</code> is a list of the hashes of the parents of this commit. In most cases, this will be a single commit, but in a merge there may be more parents. In theory, there may be an arbitrary number of parents, but in practice merges have exactly two parents. This may change in the future. For commit 1, there is no parent. </p><p><code>q</code> is a map of the paths on a desk to the data at that location. If you understand what a <code>++lobe:clay</code> and a <code>++blob:clay</code> is, then the type signature here tells the whole story. </p><p><code>r</code> is the hash associated with this commit. </p><p><code>t</code> is the date at which this commit was made. </p><h4 id="--lobe-clay--data-reference-"><code>++lobe:clay</code>, data reference </h4><pre>    ++  lobe  ,@                                            ::  blob ref
</pre><p>This is a hash of a <code>++blob:clay</code>. These are most notably used in <code>lat:rang:clay</code>, where they are associated with the actual <code>++blob:clay</code>, and as the values in <code>q:yaki:clay</code>, where paths are associated with their data in a commit. </p><h4 id="--blob-clay--data-"><code>++blob:clay</code>, data </h4><pre>    ++  blob  $%  [%delta p=lobe q=lobe r=udon]             ::  delta on q
                  [%direct p=lobe q=* r=umph]               ::
                  [%indirect p=lobe q=* r=udon s=lobe]      ::
              ==                                            ::
</pre><p>This is a node of data. In every case, <code>p</code> is the hash of the blob. </p><p><code>%delta</code> is the case where we define the data by a delta on other data. In practice, the other data is always the previous commit, but nothing depends on this. <code>q</code> is the hash of the parent blob, and <code>r</code> is the delta. </p><p><code>%direct</code> is the case where we simply have the data directly. <code>q</code> is the data itself, and <code>r</code> is any preprocessing instructions. These almost always come from the creation of a file. </p><p><code>%indirect</code> is both of the preceding cases at once. <code>q</code> is the direct data, <code>r</code> is the delta, and <code>s</code> is the parent blob. It should always be the case that applying <code>r</code> to <code>s</code> gives the same data as <code>q</code> directly (with the prepreprocessor instructions in <code>p.r</code>). This exists purely for performance reasons. This is unused, at the moment, but in general these should be created when there are a long line of changes so that we do not have to traverse the delta chain back to the creation of the file. </p><h4 id="--udon--abstract-delta-"><code>++udon</code>, abstract delta </h4><pre>    ++  udon                                                ::  abstract delta
              $:  p=umph                                    ::  preprocessor
                  $=  q                                     ::  patch
                  $%  [%a p=* q=*]                          ::  trivial replace
                      [%b p=udal]                           ::  atomic indel
                      [%c p=(urge)]                         ::  list indel
                      [%d p=upas q=upas]                    ::  tree edit
                  ==                                        ::
              ==                                            ::
</pre><p>This is an abstract change to a file. This is a superset of what would normally be called diffs. Diffs usually refer to changes in lines of text while we have the ability to do more interesting deltas on arbitrary data structures. </p><p><code>p</code> is any preprocessor instructions. </p><p><code>%a</code> refers to the trival delta of a complete replace of old data with new data. </p><p><code>%b</code> refers to changes in an opaque atom on the block level. This has very limited usefulness, and is not used at the moment. </p><p><code>%c</code> refers to changes in a list of data. This is often lines of text, which is your classic diff. We, however, will work on any list of data. </p><p><code>%d</code> refers to changes in a tree of data. This is general enough to describe changes to any hoon noun, but often more special-purpose delta should be created for different content types. This is not used at the moment, and may in fact be unimplemented. </p><h4 id="--urge--list-change-"><code>++urge</code>, list change </h4><pre>    ++  urge  |*(a=_,* (list (unce a)))                     ::  list change
</pre><p>This is a parametrized type for list changes. For example, <code>(urge ,@t)</code> is a list change for lines of text. </p><h4 id="--unce--change-part-of-a-list--"><code>++unce</code>, change part of a list. </h4><pre>    ++  unce  |*  a=_,*                                     ::  change part
              $%  [%&amp; p=@ud]                                ::  skip[copy]
                  [%| p=(list a) q=(list a)]                ::  p -&gt; q[chunk]
              ==                                            ::
</pre><p>This is a single change in a list of elements of type <code>a</code>. For example, <code>(unce ,@t)</code> is a single change in a lines of text. </p><p><code>%&amp;</code> means the next <code>p</code> lines are unchanged. </p><p><code>%|</code> means the lines <code>p</code> have changed to <code>q</code>. </p><h4 id="--umph--preprocessing-information-"><code>++umph</code>, preprocessing information </h4><pre>    ++  umph                                                ::  change filter
              $|  $?  %a                                    ::  no filter
                      %b                                    ::  jamfile
                      %c                                    ::  LF text
                  ==                                        ::
              $%  [%d p=@ud]                                ::  blocklist
              ==                                            ::
</pre><p>This space intentionally left undocumented. This stuff will change once we get a well-typed clay. </p><h4 id="--upas--tree-change-"><code>++upas</code>, tree change </h4><pre>    ++  upas                                                ::  tree change (%d)
              $&amp;  [p=upas q=upas]                           ::  cell
              $%  [%0 p=axis]                               ::  copy old
                  [%1 p=*]                                  ::  insert new
                  [%2 p=axis q=udon]                        ::  mutate!
              ==                                            ::
</pre><p>This space intentionally left undocumented. This stuff is not known to work, and will likely change when we get a well-typed clay. Also, this is not a complicated type; it is not difficult to work out the meaning. </p><h4 id="--nori-clay--repository-action-"><code>++nori:clay</code>, repository action </h4><pre>    ++  nori                                                ::  repository action
              $%  [&amp; q=soba]                                ::  delta
                  [| p=@tas]                                ::  label
              ==                                            ::
</pre><p>This describes a change that we are asking clay to make to the desk. There are two kinds of changes that may be made: we can modify files or we can apply a label to a commit. </p><p>In the <code>|</code> case, we will simply label the current commit with the given label. In the <code>&amp;</code> case, we will apply the given changes. </p><h4 id="--soba-clay--delta-"><code>++soba:clay</code>, delta </h4><pre>    ++  soba  ,[p=cart q=(list ,[p=path q=miso])]           ::  delta
</pre><p>This describes a set of changes to make to a desk. The <code>cart</code> is simply a pair of the old hash and the new hash of the desk. The list is a list of changes keyed by the file they&#39;re changing. Thus, the paths are paths to files to be changed while <code>miso</code> is a description of the change itself. </p><h4 id="--miso-clay--ankh-delta-"><code>++miso:clay</code>, ankh delta </h4><pre>    ++  miso                                                ::  ankh delta
              $%  [%del p=*]                                ::  delete
                  [%ins p=*]                                ::  insert
                  [%mut p=udon]                             ::  mutate
              ==                                            ::
</pre><p>There are three kinds of changes that may be made to a node in a desk. We can insert a file, in which case <code>p</code> is the contents of the new file. We can delete a file, in which case <code>p</code> is the contents of the old file. Finally, we can mutate that file, in which case the <code>udon</code> describes the changes we are applying to the file. </p><h4 id="--mizu-clay--merged-state-"><code>++mizu:clay</code>, merged state </h4><pre>    ++  mizu  ,[p=@u q=(map ,@ud tako) r=rang]              ::  new state
</pre><p>This is the input to the <code>%merg</code> kiss, which allows us to perform a merge. The <code>p</code> is the number of the new head commit. The <code>q</code> is a map from numbers to commit hashes. This is all the new numbered commits that are to be inserted. The keys to this should always be the numbers from <code>let.dom</code> plus one to <code>p</code>, inclusive. The <code>r</code> is the maps of all the new commits and data. Since these are merged into the current state, no old commits or data need be here. </p><h4 id="--riff-clay--request-desist-"><code>++riff:clay</code>, request/desist </h4><pre>    ++  riff  ,[p=desk q=(unit rave)]                       ::  request/desist
</pre><p>This represents a request for data about a particular desk. If <code>q</code> contains a <code>rave</code>, then this opens a subscription to the desk for that data. If <code>q</code> is null, then this tells clay to cancel the subscription along this duct. </p><h4 id="--riot-clay--response-"><code>++riot:clay</code>, response </h4><pre>    ++  riot  (unit rant)                                   ::  response/complete
</pre><p>A riot is a response to a subscription. If null, the subscription has been completed, and no more responses will be sent. Otherwise, the <code>rant</code> is the produced data. </p><h4 id="--rant-clay--response-data-"><code>++rant:clay</code>, response data </h4><pre>    ++  rant                                                ::  namespace binding
              $:  p=[p=care q=case r=@tas]                  ::  clade release book
                  q=path                                    ::  spur
                  r=*                                       ::  data
              ==                                            ::
</pre><p>This is the data at a particular node in the filesystem. <code>p.p</code> specifies the type of data that was requested (and is produced). <code>q.p</code> gives the specific version reported (since a range of versions may be requested in a subscription). <code>r.p</code> is the desk. <code>q</code> is the path to the filesystem node. <code>r</code> is the data itself (in the format specified by <code>p.p</code>). </p><h3 id="--nako--subscription-response-data-"><code>++nako</code>, subscription response data </h3><pre>    ++  nako  $:  gar=(map ,@ud tako)                       ::  new ids
                  let=@ud                                   ::  next id
                  lar=(set yaki)                            ::  new commits
                  bar=(set blob)                            ::  new content
              ==                                            ::
</pre><p>This is the data that is produced by a request for a range of revisions of a desk. This allows us to easily keep track of a remote repository -- all the new information we need is contained in the <code>nako</code>. </p><p><code>gar</code> is a map of the revisions in the range to the hash of the commit at that revision. These hashes can be used with <code>hut:rang:clay</code> to find the commit itself. </p><p><code>let</code> is either the last revision number in the range or the most recent revision number, whichever is smaller. </p><p><code>lar</code> is the set of new commits, and <code>bar</code> is the set of new content. </p><h2 id="public-interface-">Public Interface </h2><p>As with all vanes, there are exactly two ways to interact with clay. <code>%clay</code> exports a namespace accessible through <code>.^</code>, which is described above under <code>++care:clay</code>. The primary way of interacting with clay, though, is by sending kisses and receiving gifts. </p><pre>    ++  gift                                                ::  out result &lt;-$
              $%  [%ergo p=@p q=@tas r=@ud]                 ::  version update
                  [%note p=@tD q=tank]                      ::  debug message
                  [%writ p=riot]                            ::  response
              ==                                            ::
    ++  kiss                                                ::  in request -&gt;$
              $%  [%info p=@p q=@tas r=nori]                ::  internal edit
                  [%ingo p=@p q=@tas r=nori]                ::  internal noun edit
                  [%init p=@p]                              ::  report install
                  [%into p=@p q=@tas r=nori]                ::  external edit
                  [%invo p=@p q=@tas r=nori]                ::  external noun edit
                  [%merg p=@p q=@tas r=mizu]                ::  internal change
                  [%wart p=sock q=@tas r=path s=*]          ::  network request
                  [%warp p=sock q=riff]                     ::  file request
              ==                                            ::
</pre><p>There are only a small number of possible kisses, so it behooves us to describe each in detail. </p><pre>              $%  [%info p=@p q=@tas r=nori]                ::  internal edit

                  [%into p=@p q=@tas r=nori]                ::  external edit
</pre><p>These two kisses are nearly identical. At a high level, they apply changes to the filesystem. Whenever we add, remove, or edit a file, one of these cards is sent. The <code>p</code> is the ship whose filesystem we&#39;re trying to change, the <code>q</code> is the desk we&#39;re changing, and the <code>r</code> is the request change. For the format of the requested change, see the documentation for <code>++nori:clay</code> above. </p><p>When a file is changed in the unix filesystem, vere will send a <code>%into</code> kiss. This tells clay that the duct over which the kiss was sent is the duct that unix is listening on for changes. From within Arvo, though, we should never send a <code>%into</code> kiss. The <code>%info</code> kiss is exactly identical except it does not reset the duct. </p><pre>                  [%ingo p=@p q=@tas r=nori]                ::  internal noun edit

                  [%invo p=@p q=@tas r=nori]                ::  external noun edit
</pre><p>These kisses are currently identical to <code>%info</code> and <code>%into</code>, though this will not always be the case. The intent is for these kisses to allow typed changes to clay so that we may store typed data. This is currently unimplemented. </p><pre>                  [%init p=@p]                              ::  report install
</pre><p>Init is called when a ship is started on our pier. This simply creates a default <code>room</code> to go into our <code>raft</code>. Essentially, this initializes the filesystem for a ship. </p><pre>                  [%merg p=@p q=@tas r=mizu]                ::  internal change
</pre><p>This is called to perform a merge. This is most visibly called by :update to update the filesystem of the current ship to that of its sein. The <code>p</code> and <code>q</code> are as in <code>%info</code>, and the <code>r</code> is the description of the merge. See <code>++mizu:clay</code> above. </p><p>XX <code>XX [%wake ~] :: timer activate XX</code> XX<br />XX This card is sent by unix at the time specified by <code>++doze</code>. This time is XX usually the closest time specified in a subscription request. When <code>%wake</code> is XX called, we update our subscribers if there have been any changes. </p><pre>                  [%wart p=sock q=@tas r=path s=*]          ::  network request
</pre><p>This is a request that has come across the network for a particular file. When another ship asks for a file from us, that request comes to us in the form of a <code>%wart</code> kiss. This is handled by trivially turning it into a <code>%warp</code>. </p><pre>                  [%warp p=sock q=riff]                     ::  file request
</pre><p>This is a request for information about a particular desk. This is, in its most general form, a subscription, though in many cases it is the trivial case of a subscription -- a read. See <code>++riff:clay</code> for the format of the request. </p><h2 id="lifecycle-of-a-local-read-">Lifecycle of a Local Read </h2><p>There are two real types of interaction with a filesystem: you can read, and you can write. We&#39;ll describe each process, detailing both the flow of control followed by the kernel and the algorithms involved. The simpler case is that of the read, so we&#39;ll begin with that. </p><p>When a vane or an application wishes to read a file from the filesystem, it sends a <code>%warp</code> kiss, as described above. Of course, you may request a file on another ship and, being a global filesystem, clay will happily produce it for you. That code pathway will be described in another section; here, we will restrict ourselves to examining the case of a read from a ship on our own pier. </p><p>The kiss can request either a single version of a file node or a range of versions of a desk. Here, we&#39;ll deal only with a request for a single version. </p><p>As in all vanes, a kiss enters clay via a call to <code>++call</code>. Scanning through the arm, we quickly see where <code>%warp</code> is handled. </p><pre>            ?:  =(p.p.q.hic q.p.q.hic)
              =+  une=(un p.p.q.hic now ruf)
              =+  wex=(di:une p.q.q.hic)
              =+  ^=  wao
                ?~  q.q.q.hic
                  (ease:wex hen)
                (eave:wex hen u.q.q.q.hic)
              =+  ^=  woo
                abet:wao
              [-.woo abet:(pish:une p.q.q.hic +.woo ran.wao)]
</pre><p>We&#39;re following the familar patern of producing a list of moves and an updated state. In this case, the state is <code>++raft</code>. </p><p>We first check to see if the sending and receiving ships are the same. If they&#39;re not, then this is a request for data on another ship. We describe that process later. Here, we discuss only the case of a local read. </p><p>At a high level, the call to <code>++un</code> sets up the core for the domestic ship that contains the files we&#39;re looking for. The call to <code>++di</code> sets up the core for the particular desk we&#39;re referring to. </p><p>After this, we perform the actual request. If there is no rave in the riff, then that means we are cancelling a request, so we call <code>++ease:de</code>. Otherwise, we start a subscription with <code>++eave:de</code>. We call <code>++abet:de</code> to resolve our various types of output into actual moves. We produce the moves we found above and the <code>++un</code> core resolved with <code>++pish:un</code> (putting the modified desk in the room) and <code>++abet:un</code> (putting the modified room in the raft). </p><p>Much of this is fairly straightforward, so we&#39;ll only describe <code>++ease</code>, <code>++eave</code>, and <code>++abet:de</code>. Feel free to look up the code to the other steps -- it should be easy to follow. </p><p>Although it&#39;s called last, it&#39;s usually worth examining <code>++abet</code> first, since it defines in what ways we can cause side effects. Let&#39;s do that, and also a few of the lines at the beginning of <code>++de</code>. </p><pre>        =|  yel=(list ,[p=duct q=gift])
        =|  byn=(list ,[p=duct q=riot])
        =|  vag=(list ,[p=duct q=gift])
        =|  say=(list ,[p=duct q=path r=ship s=[p=@ud q=riff]])
        =|  tag=(list ,[p=duct q=path c=note])
        |%
        ++  abet
          ^-  [(list move) rede]
          :_  red
          ;:  weld
            %+  turn  (flop yel)
            |=([a=duct b=gift] [hun %give b])
          ::
            %+  turn  (flop byn)
            |=([a=duct b=riot] [a %give [%writ b]])
          ::
            %+  turn  (flop vag)
            |=([a=duct b=gift] [a %give b])
          ::
            %+  turn  (flop say)
            |=  [a=duct b=path c=ship d=[p=@ud q=riff]]
            :-  a
            [%pass b %a %want [who c] [%q %re p.q.d (scot %ud p.d) ~] q.d]
          ::
            %+  turn  (flop tag)
            |=([a=duct b=path c=note] [a %pass b c])
          ==
</pre><p>This is very simple code. We see there are exactly five different kinds of side effects we can generate. </p><p>In <code>yel</code> we put gifts that we wish to be sent along the <code>hun:room</code> duct to dill. See the documentation for <code>++room</code> above. This is how we display messages to the terminal. </p><p>In <code>byn</code> we put riots that we wish returned to subscribers. Recall that a riot is a response to a subscription. These are returned to our subscribers in the form of a <code>%writ</code> gift. </p><p>In <code>vag</code> we put gifts along with the ducts on which to send them. This allows us to produce arbitrary gifts, but in practice this is only used to produce <code>%ergo</code> gifts. </p><p>In <code>say</code> we put messages we wish to pass to ames. These messages are used to request information from clay on other piers. We must provide not only the duct and the request (the riff), but also the return path, the other ship to talk to, and the sequence number of the request. </p><p>In <code>tag</code> we put arbitrary notes we wish to pass to other vanes. For now, the only notes we pass here are <code>%wait</code> and <code>%rest</code> to the timer vane. </p><p>Now that we know what kinds of side effects we may have, we can jump into the handling of requests. </p><pre>        ++  ease                                          ::  release request
          |=  hen=duct
          ^+  +&gt;
          ?~  ref  +&gt;
            =+  rov=(~(got by qyx) hen)
            =.  qyx  (~(del by qyx) hen)
            (mabe rov (cury best hen))
          =.  qyx  (~(del by qyx) hen)
          |-  ^+  +&gt;+.$
          =+  nux=(~(get by fod.u.ref) hen)
          ?~  nux  +&gt;+.$
          %=  +&gt;+.$
            say        [[hen [(scot %ud u.nux) ~] for [u.nux syd ~]] say]
            fod.u.ref  (~(del by fod.u.ref) hen)
            bom.u.ref  (~(del by bom.u.ref) u.nux)
          ==
</pre><p>This is called when we&#39;re cancelling a subscription. For domestic desks, <code>ref</code> is null, so we&#39;re going to cancel any timer we might have created. We first delete the duct from our map of requests, and then we call <code>++mabe</code> with <code>++best</code> to send a <code>%rest</code> kiss to the timer vane if we have started a timer. We&#39;ll describe <code>++best</code> and <code>++mabe</code> momentarily. </p><p>Although we said we&#39;re not going to talk about foreign requests yet, it&#39;s easy to see that for foreign desks, we cancel any outstanding requests for this duct and send a message over ames to the other ship telling them to cancel the subscription. </p><pre>        ++  best
          |=  [hen=duct tym=@da]
          %_(+&gt; tag :_(tag [hen /tyme %t %rest tym]))
</pre><p>This simply pushes a <code>%rest</code> note onto <code>tag</code>, from where it will be passed back to arvo to be handled. This cancels the timer at the given duct (with the given time). </p><pre>        ++  mabe                                            ::  maybe fire function
          |*  [rov=rove fun=$+(@da _+&gt;.^$)]
          ^+  +&gt;.$
          %-  fall  :_  +&gt;.$
          %-  bind  :_  fun
          ^-  (unit ,@da)
          ?-    -.rov
              %&amp;
            ?.  ?=(%da -.q.p.rov)  ~
            `p.q.p.rov
              %|
            =*  mot  p.rov
            %+  hunt
              ?.  ?=(%da -.p.mot)  ~
              ?.((lth now p.p.mot) ~ [~ p.p.mot])
            ?.  ?=(%da -.q.mot)  ~
            ?.((lth now p.q.mot) [~ now] [~ p.q.mot])
          ==
</pre><p>This decides whether the given request can only be satsified in the future. In that case, we call the given function with the time in the future when we expect to have an update to give to this request. This is called with <code>++best</code> to cancel timers and with <code>++bait</code> to start them. </p><p>For single requests, we have a time if the request is for a particular time (which is assumed to be in the future). For ranges of requests, we check both the start and end cases to see if they are time cases. If so, we choose the earlier time. </p><p>If any of those give us a time, then we call the given funciton with the smallest time. </p><p>The more interesting case is, of course, when we&#39;re not cancelling a subscription but starting one. </p><pre>        ++  eave                                          ::  subscribe
          |=  [hen=duct rav=rave]
          ^+  +&gt;
          ?-    -.rav
              &amp;
            ?:  &amp;(=(p.p.rav %u) !=(p.q.p.rav now))
              ~&amp;  [%clay-fail p.q.p.rav %now now]
              !!
            =+  ver=(aver p.rav)
            ?~  ver
              (duce hen rav)
            ?~  u.ver
              (blub hen)
            (blab hen p.rav u.u.ver)
</pre><p>There are two types of subscriptions -- either we&#39;re requesting a single file or we&#39;re requesting a range of versions of a desk. We&#39;ll dicuss the simpler case first. </p><p>First, we check that we&#39;re not requesting the <code>rang</code> from any time other than the present. Since we don&#39;t store that information for any other time, we can&#39;t produce it in a referentially transparent manner for any time other than the present. </p><p>Then, we try to read the requested <code>mood:clay</code> <code>p.rav</code>. If we can&#39;t access the request data right now, we call <code>++duce</code> to put the request in our queue to be satisfied when the information becomes available. </p><p>This case occurs when we make a request for a case whose (1) date is after the current date, (2) number is after the current number, or (3) label is not yet used. </p><pre>        ++  duce                                            ::  produce request
          |=  [hen=duct rov=rove]
          ^+  +&gt;
          =.  qyx  (~(put by qyx) hen rov)
          ?~  ref
            (mabe rov (cury bait hen))
          |-  ^+  +&gt;+.$                                     ::  XX  why?
          =+  rav=(reve rov)
          =+  ^=  vaw  ^-  rave
            ?.  ?=([%&amp; %v *] rav)  rav
            [%| [%ud let.dom] `case`q.p.rav r.p.rav]
          =+  inx=nix.u.ref
          %=  +&gt;+.$
            say        [[hen [(scot %ud inx) ~] for [inx syd ~ vaw]] say]
            nix.u.ref  +(nix.u.ref)
            bom.u.ref  (~(put by bom.u.ref) inx [hen vaw])
            fod.u.ref  (~(put by fod.u.ref) hen inx)
          ==
</pre><p>The code for <code>++duce</code> is nearly the exact inverse of <code>++ease</code>, which in the case of a domestic desk is very simple -- we simply put the duct and rave into <code>qyx</code> and possibly start a timer with <code>++mabe</code> and <code>++bait</code>. Recall that <code>ref</code> is null for domestic desks and that <code>++mabe</code> fires the given function with the time we need to be woken up at, if we need to be woken up at a particular time. </p><pre>        ++  bait
          |=  [hen=duct tym=@da]
          %_(+&gt; tag :_(tag [hen /tyme %t %wait tym]))
</pre><p>This sets an alarm by sending a <code>%wait</code> card with the given time to the timer vane. </p><p>Back in <code>++eave</code>, if <code>++aver</code> returned <code>[~ ~]</code>, then we cancel the subscription. This occurs when we make (1) a <code>%x</code> request for a file that does not exist, (2) a <code>%w</code> request with a case that is not a number, or (3) a <code>%w</code> request with a nonempty path. The <code>++blub</code> is exactly what you would expect it to be. </p><pre>        ++  blub                                          ::  ship stop
          |=  hen=duct
          %_(+&gt; byn [[hen ~] byn])
</pre><p>We notify the duct that we&#39;re cancelling their subscription since it isn&#39;t satisfiable. </p><p>Otherwise, we have received the desired information, so we send it on to the subscriber with <code>++blab</code>. </p><pre>        ++  blab                                          ::  ship result
          |=  [hen=duct mun=mood dat=*]
          ^+  +&gt;
          +&gt;(byn [[hen ~ [p.mun q.mun syd] r.mun dat] byn])
</pre><p>The most interesting arm called in <code>++eave</code> is, of course, <code>++aver</code>, where we actually try to read the data. </p><pre>        ++  aver                                          ::  read
          |=  mun=mood
          ^-  (unit (unit ,*))
          ?:  &amp;(=(p.mun %u) !=(p.q.mun now))              ::  prevent bad things
            ~&amp;  [%clay-fail p.q.mun %now now]
            !!
          =+  ezy=?~(ref ~ (~(get by haw.u.ref) mun))
          ?^  ezy  ezy
          =+  nao=(~(case-to-aeon ze lim dom ran) q.mun)
          ?~(nao ~ [~ (~(read-at-aeon ze lim dom ran) u.nao mun)])
</pre><p>We check immediately that we&#39;re not requesting the <code>rang</code> for any time other than the present. </p><p>If this is a foreign desk, then we check our cache for the specific request. If either this is a domestic desk or we don&#39;t have the request in our cache, then we have to actually go read the data from our dome. </p><p>We need to do two things. First, we try to find the number of the commit specified by the given case, and then we try to get the data there. </p><p>Here, we jump into <code>arvo/zuse.hoon</code>, which is where much of the algorithmic code is stored, as opposed to the clay interface, which is stored in <code>arvo/clay.hoon</code>. We examine <code>++case-to-aeon:ze</code>. </p><pre>      ++  case-to-aeon                                      ::    case-to-aeon:ze
        |=  lok=case                                        ::  act count through
        ^-  (unit aeon)
        ?-    -.lok
            %da
          ?:  (gth p.lok lim)  ~
          |-  ^-  (unit aeon)
          ?:  =(0 let)  [~ 0]                               ::  avoid underflow
          ?:  %+  gte  p.lok
              =&lt;  t
              %-  tako-to-yaki
              %-  aeon-to-tako
              let
            [~ let]
          $(let (dec let))
        ::
            %tas  (~(get by lab) p.lok)
            %ud   ?:((gth p.lok let) ~ [~ p.lok])
        ==
</pre><p>We handle each type of <code>case:clay</code> differently. The latter two types are easy. </p><p>If we&#39;re requesting a revision by label, then we simply look up the requested label in <code>lab</code> from the given dome. If it exists, that is our aeon; else we produce null, indicating the requested revision does not yet exist. </p><p>If we&#39;re requesting a revision by number, we check if we&#39;ve yet reached that number. If so, we produce the number; else we produce null. </p><p>If we&#39;re requesting a revision by date, we check first if the date is in the future, returning null if so. Else we start from the most recent revision and scan backwards until we find the first revision committed before that date, and we produce that. If we requested a date before any revisions were committed, we produce <code>0</code>. </p><p>The definitions of <code>++aeon-to-tako</code> and <code>++tako-to-yaki</code> are trivial. </p><pre>      ++  aeon-to-tako  ~(got by hit)

      ++  tako-to-yaki  ~(got by hut)                       ::  grab yaki
</pre><p>We simply look up the aeon or tako in their respective maps (<code>hit</code> and <code>hut</code>). </p><p>Assuming we got a valid version number, <code>++aver</code> calls <code>++read-at-aeon:ze</code>, which reads the requested data at the given revision. </p><pre>      ++  read-at-aeon                                      ::    read-at-aeon:ze
        |=  [oan=aeon mun=mood]                             ::  seek and read
        ^-  (unit)
        ?:  &amp;(?=(%w p.mun) !?=(%ud -.q.mun))                ::  NB only for speed
          ?^(r.mun ~ [~ oan])
        (read:(rewind oan) mun)
</pre><p>If we&#39;re requesting the revision number with a case other than by number, then we go ahead and just produce the number we were given. Otherwise, we call <code>++rewind</code> to rewind our state to the given revision, and then we call <code>++read</code> to get the requested information. </p><pre>      ++  rewind                                            ::    rewind:ze
        |=  oan=aeon                                        ::  rewind to aeon
        ^+  +&gt;
        ?:  =(let oan)  +&gt;
        ?:  (gth oan let)  !!                               ::  don&#39;t have version
        +&gt;(ank (checkout-ankh q:(tako-to-yaki (aeon-to-tako oan))), let oan)
</pre><p>If we&#39;re already at the requested version, we do nothing. If we&#39;re requesting a version later than our head, we are unable to comply. </p><p>Otherwise, we get the hash of the commit at the number, and from that we get the commit itself (the yaki), which has the map of path to lobe that represents a version of the filesystem. We call <code>++checkout-ankh</code> to checkout the commit, and we replace <code>ank</code> in our context with the result. </p><pre>      ++  checkout-ankh                                     ::    checkout-ankh:ze
        |=  hat=(map path lobe)                             ::  checkout commit
        ^-  ankh
        %-  cosh
        %+  roll  (~(tap by hat) ~)
        |=  [[pat=path bar=lobe] ank=ankh]
        ^-  ankh
        %-  cosh
        ?~  pat
          =+  zar=(lobe-to-noun bar)
          ank(q [~ (sham zar) zar])
        =+  nak=(~(get by r.ank) i.pat)
        %=  ank
          r  %+  ~(put by r.ank)  i.pat
             $(pat t.pat, ank (fall nak _ankh))
        ==
</pre><p>Twice we call <code>++cosh</code>, which hashes a commit, updating <code>p</code> in an <code>ankh</code>. Let&#39;s jump into that algorithm before we describe <code>++checkout-ankh</code>. </p><pre>    ++  cosh                                                ::  locally rehash
      |=  ank=ankh                                          ::  NB v/unix.c
      ank(p rehash:(zu ank))
</pre><p>We simply replace <code>p</code> in the hash with the <code>cash</code> we get from a call to <code>++rehash:zu</code>. </p><pre>    ++  zu  !:                                              ::  filesystem
      |=  ank=ankh                                          ::  filesystem state
      =|  myz=(list ,[p=path q=miso])                       ::  changes in reverse
      =|  ram=path                                          ::  reverse path into
      |%
      ++  rehash                                            ::  local rehash
        ^-  cash
        %+  mix  ?~(q.ank 0 p.u.q.ank)
        =+  axe=1
        |-  ^-  cash
        ?~  r.ank  _@
        ;:  mix
          (shaf %dash (mix axe (shaf %dush (mix p.n.r.ank p.q.n.r.ank))))
          $(r.ank l.r.ank, axe (peg axe 2))
          $(r.ank r.r.ank, axe (peg axe 3))
        ==
</pre><p><code>++zu</code> is a core we set up with a particular filesystem node to traverse a checkout of the filesystem and access the actual data inside it. One of the things we can do with it is to create a recursive hash of the node. </p><p>In <code>++rehash</code>, if this node is a file, then we xor the remainder of the hash with the hash of the contents of the file. The remainder of the hash is <code>0</code> if we have no children, else we descend into our children. Basically, we do a half SHA-256 of the xor of the axis of this child and the half SHA-256 of the xor of the name of the child and the hash of the child. This is done for each child and all the results are xored together. </p><p>Now we return to our discussion of <code>++checkout-ankh</code>. </p><p>We fold over every path in this version of the filesystem and create a great ankh out of them. First, we call <code>++lobe-to-noun</code> to get the raw data referred to be each lobe. </p><pre>      ++  lobe-to-noun                                      ::  grab blob
        |=  p=lobe                                          ::  ^-  *
        %-  blob-to-noun
        (lobe-to-blob p)
</pre><p>This converts a lobe into the raw data it refers to by first getting the blob with <code>++lobe-to-blob</code> and converting that into data with <code>++blob-to-noun</code>. </p><pre>      ++  lobe-to-blob  ~(got by lat)                       ::  grab blob
</pre><p>This just grabs the blob that the lobe refers to. </p><pre>      ++  blob-to-noun                                      ::  grab blob
        |=  p=blob
        ?-   -.p
           %delta  (lump r.p (lobe-to-noun q.p))
           %direct  q.p
           %indirect  q.p
        ==
</pre><p>If we have either a direct or an indirect blob, then the data is stored right in the blob. Otherwise, we have to reconstruct it from the diffs. We do this by calling <code>++lump</code> on the diff in the blob with the data obtained by recursively calling the parent of this blob. </p><pre>    ++  lump                                                ::  apply patch
      |=  [don=udon src=*]
      ^-  *
      ?+    p.don  ~|(%unsupported !!)
          %a
        ?+  -.q.don  ~|(%unsupported !!)
          %a  q.q.don
          %c  (lurk ((hard (list)) src) p.q.don)
          %d  (lure src p.q.don)
        ==
      ::
          %c
        =+  dst=(lore ((hard ,@) src))
        %-  roly
        ?+  -.q.don  ~|(%unsupported !!)
          %a  ((hard (list ,@t)) q.q.don)
          %c  (lurk dst p.q.don)
        ==
      ==
</pre><p>This is defined in <code>arvo/hoon.hoon</code> for historical reasons which are likely no longer applicable. Since the <code>++umph</code> structure will likely change we convert clay to be a typed filesystem, we&#39;ll only give a high-level description of this process. If we have a <code>%a</code> udon, then we&#39;re performing a trivial replace, so we produce simply <code>q.q.don</code>. If we have a <code>%c</code> udon, then we&#39;re performing a list merge (as in, for example, lines of text). The merge is performed by <code>++lurk</code>. </p><pre>    ++  lurk                                                ::  apply list patch
      |*  [hel=(list) rug=(urge)]
      ^+  hel
      =+  war=`_hel`~
      |-  ^+  hel
      ?~  rug  (flop war)
      ?-    -.i.rug
          &amp;
        %=   $
          rug  t.rug
          hel  (slag p.i.rug hel)
          war  (weld (flop (scag p.i.rug hel)) war)
        ==
      ::
          |
        %=  $
          rug  t.rug
          hel  =+  gur=(flop p.i.rug)
               |-  ^+  hel
               ?~  gur  hel
               ?&gt;(&amp;(?=(^ hel) =(i.gur i.hel)) $(hel t.hel, gur t.gur))
          war  (weld q.i.rug war)
        ==
      ==
</pre><p>We accumulate our final result in <code>war</code>. If there&#39;s nothing more in our list of merge instructions (unces), we just reverse <code>war</code> and produce it. Otherwise, we process another unce. If the unce is of type <code>&amp;</code>, then we have <code>p.i.rug</code> lines of no changes, so we just copy them over from <code>hel</code> to <code>war</code>. If the unice is of type <code>|</code>, then we verify that the source lines (in <code>hel</code>) are what we expect them to be (<code>p.i.rug</code>), crashing on failure. If they&#39;re good, then we append the new lines in <code>q.i.rug</code> onto <code>war</code>. </p><p>And that&#39;s really it. List merges are pretty easy. Anyway, if you recall, we were discussing <code>++checkout-ankh</code>. </p><pre>      ++  checkout-ankh                                     ::    checkout-ankh:ze
        |=  hat=(map path lobe)                             ::  checkout commit
        ^-  ankh
        %-  cosh
        %+  roll  (~(tap by hat) ~)
        |=  [[pat=path bar=lobe] ank=ankh]
        ^-  ankh
        %-  cosh
        ?~  pat
          =+  zar=(lobe-to-noun bar)
          ank(q [~ (sham zar) zar])
        =+  nak=(~(get by r.ank) i.pat)
        %=  ank
          r  %+  ~(put by r.ank)  i.pat
             $(pat t.pat, ank (fall nak _ankh))
        ==
</pre><p>If the path is null, then we calculate <code>zar</code>, the raw data at the path <code>pat</code> in this version. We produce the given ankh with the correct data. </p><p>Otherwise, we try to get the child we&#39;re looking at from our parent ankh. If it&#39;s already been created, this succeeds; otherwise, we simply create a default blank ankh. We place ourselves in our parent after recursively computing our children. </p><p>This algorithm really isn&#39;t that complicated, but it may not be immediately obvious why it works. An example should clear everything up. </p><p>Suppose <code>hat</code> is a map of the following information. </p><pre>    /greeting                 --&gt;  &quot;customary upon meeting&quot;
    /greeting/english         --&gt;  &quot;hello&quot;
    /greeting/spanish         --&gt;  &quot;hola&quot;
    /greeting/russian/short   --&gt;  &quot;привет&quot;
    /greeting/russian/long    --&gt;  &quot;Здравствуйте&quot;
    /farewell/russian         --&gt;  &quot;до свидания&quot;
</pre><p>Furthermore, let&#39;s say that we process them in this order: </p><pre>    /greeting/english
    /greeting/russian/short
    /greeting/russian/long
    /greeting
    /greeting/spanish
    /farewell/russian
</pre><p>Then, the first path we process is <code>/greeting/english</code> . Since our path is not null, we try to get <code>nak</code>, but because our ankh is blank at this point it doesn&#39;t find anything. Thus, update our blank top-level ankh with a child <code>%greeting</code>. and recurse with the blank <code>nak</code> to create the ankh of the new child. </p><p>In the recursion, we our path is <code>/english</code> and our ankh is again blank. We try to get the <code>english</code> child of our ankh, but this of course fails. Thus, we update our blank <code>/greeting</code> ankh with a child <code>english</code> produced by recursing. </p><p>Now our path is null, so we call <code>++lobe-to-noun</code> to get the actual data, and we place it in the brand-new ankh. </p><p>Next, we process <code>/greeting/russian/short</code>. Since our path is not null, we try to get the child named <code>%greeting</code>, which does exist since we created it earlier. We put modify this child by recursing on it. Our path is now <code>/russian/short</code>, so we look for a <code>%russian</code> child in our <code>/greeting</code> ankh. This doesn&#39;t exist, so we add it by recursing. Our path is now <code>/short</code>, so we look for a <code>%short</code> child in our <code>/greeting/russian</code> ankh. This doesn&#39;t exist, so we add it by recursing. Now our path is null, so we set the contents of this node to <code>&quot;привет&quot;</code>, and we&#39;re done processing this path. </p><p>Next, we process <code>/greeting/russian/long</code>. This proceeds similarly to the previous except that now the ankh for <code>/greeting/russian</code> already exists, so we simply reuse it rather than creating a new one. Of course, we still must create a new <code>/greeting/russian/long</code> ankh. </p><p>Next, we process <code>/greeting</code>. This ankh already exists, so after we&#39;ve recursed once, our path is null, and our ankh is not blank -- it already has two children (and two grandchildren). We don&#39;t touch those, though, since a node may be both a file and a directory. We just add the contents of the file -- “customary upon meeting” -- to the existing ankh. </p><p>Next, we process <code>/greeting/spanish</code>. Of course, the <code>/greeting</code> ankh already exists, but it doesn&#39;t have a <code>%spanish</code> child, so we create that, taking care not to disturb the contents of the <code>/greeting</code> file. We put “hola” into the ankh and call it good. </p><p>Finally, we process <code>/farewell/russian</code>. Here, the <code>/farewell</code> ankh doesn&#39;t exist, so we create it. Clearly the newly-created ankh doesn&#39;t have any children, so we have to add a <code>%russian</code> child, and in this child we put our last content -- “до свидания”. </p><p>We hope it&#39;s fairly obvious that the order we process the paths doesn&#39;t affect the final ankh tree. The tree will be constructed in a very different order depending on what order the paths come in, but the resulting tree is independent of order. </p><p>At any rate, we were talking about something important, weren&#39;t we? If you recall, that concludes our discussion of <code>++rewind</code>, which was called from <code>++read-at-aeon</code>. In summary, <code>++rewind</code> returns a context in which our current state is (very nearly) as it was when the specified version of the desk was the head. This allows <code>++read-at-aeon</code> to call <code>++read</code> to read the requested information. </p><pre>      ++  read                                              ::    read:ze
        |=  mun=mood                                        ::  read at point
        ^-  (unit)
        ?:  ?=(%v p.mun)
          [~ `dome`+&lt;+&lt;.read]
        ?:  &amp;(?=(%w p.mun) !?=(%ud -.q.mun))
          ?^(r.mun ~ [~ let])
        ?:  ?=(%w p.mun)
          =+  ^=  yak
              %-  tako-to-yaki
              %-  aeon-to-tako
              let
          ?^(r.mun ~ [~ [t.yak (forge-nori yak)]])
          ::?&gt;  ?=(^ hit)  ?^(r.mun ~ [~ i.hit])     ::  what do?? need [@da nori]
        (query(ank ank:(descend-path:(zu ank) r.mun)) p.mun)
</pre><p>If we&#39;re requesting the dome, then we just return that immediately. </p><p>If we&#39;re requesting the revision number of the desk and we&#39;re not requesting it by number, then we just return the current number of this desk. Note of course that this was really already handled in <code>++read-at-aeon</code>. </p><p>If we&#39;re requesting a <code>%w</code> with a specific revision number, then we do something or other with the commit there. It&#39;s kind of weird, and it doesn&#39;t seem to work, so we&#39;ll ignore this case. </p><p>Otherwise, we descend into the ankh tree to the given path with <code>++descend-path:zu</code>, and then we handle specific request in <code>++query</code>. </p><pre>      ++  descend-path                                      ::  descend recursively
        |=  way=path
        ^+  +&gt;
        ?~(way +&gt; $(way t.way, +&gt; (descend i.way)))
</pre><p>This is simple recursion down into the ankh tree. <code>++descend</code> descends one level, so this will eventually get us down to the path we want. </p><pre>      ++  descend                                           ::  descend
        |=  lol=@ta
        ^+  +&gt;
        =+  you=(~(get by r.ank) lol)
        +&gt;.$(ram [lol ram], ank ?~(you [*cash ~ ~] u.you))
</pre><p><code>ram</code> is the path that we&#39;re at, so to descend one level we push the name of this level onto that path. We update the ankh with the correct one at that path if it exists; else we create a blank one. </p><p>Once we&#39;ve decscended to the correct level, we need to actually deal with the request. </p><pre>      ++  query                                             ::    query:ze
        |=  ren=?(%u %v %x %y %z)                           ::  endpoint query
        ^-  (unit ,*)
        ?-  ren
          %u  [~ `rang`+&lt;+&gt;.query]
          %v  [~ `dome`+&lt;+&lt;.query]
          %x  ?~(q.ank ~ [~ q.u.q.ank])
          %y  [~ as-arch]
          %z  [~ ank]
        ==
</pre><p>Now that everything&#39;s set up, it&#39;s really easy. If they&#39;re requesting the rang, dome, or ankh, we give it to them. If the contents of a file, we give it to them if it is in fact a file. If the <code>arch</code>, then we calculate it with <code>++as-arch</code>. </p><pre>      ++  as-arch                                           ::    as-arch:ze
        ^-  arch                                            ::  arch report
        :+  p.ank
          ?~(q.ank ~ [~ p.u.q.ank])
        |-  ^-  (map ,@ta ,~)
        ?~  r.ank  ~
        [[p.n.r.ank ~] $(r.ank l.r.ank) $(r.ank r.r.ank)]
</pre><p>This very simply strips out all the “real” data and returns just our own hash, the hash of the file contents (if we&#39;re a file), and a map of the names of our immediate children. </p><h2 id="lifecycle-of-a-local-subscription-">Lifecycle of a Local Subscription </h2><p>A subscription to a range of revisions of a desk initially follows the same path that a single read does. In <code>++aver</code>, we checked the head of the given rave. If the head was <code>&amp;</code>, then it was a single request, so we handled it above. If <code>|</code>, then we handle it with the following code. </p><pre>            =+  nab=(~(case-to-aeon ze lim dom ran) p.p.rav)
            ?~  nab
              ?&gt;  =(~ (~(case-to-aeon ze lim dom ran) q.p.rav))
              (duce hen (rive rav))
            =+  huy=(~(case-to-aeon ze lim dom ran) q.p.rav)
            ?:  &amp;(?=(^ huy) |((lth u.huy u.nab) &amp;(=(0 u.huy) =(0 u.nab))))
              (blub hen)
            =+  top=?~(huy let.dom u.huy)
            =+  sar=(~(lobes-at-path ze lim dom ran) u.nab r.p.rav)
            =+  ear=(~(lobes-at-path ze lim dom ran) top r.p.rav)
            =.  +&gt;.$
              ?:  =(sar ear)  +&gt;.$
              =+  fud=(~(make-nako ze lim dom ran) u.nab top)
              (bleb hen u.nab fud)
            ?^  huy
              (blub hen)
            =+  ^=  ptr  ^-  case
                [%ud +(let.dom)]
            (duce hen `rove`[%| ptr q.p.rav r.p.rav ear])
          ==
</pre><p>Recall that <code>++case-to-aeon:ze</code> produces the revision number that a case corresponds to, if it corresponds to any. If it doesn&#39;t yet correspond to a revision, then it produces null. </p><p>Thus, we first check to see if we&#39;ve even gotten to the beginning of the range of revisions requested. If not, then we assert that we haven&#39;t yet gotten to the end of the range either, because that would be really strange. If not, then we immediately call <code>++duce</code>, which, if you recall, for a local request, simply puts this duct and rove into our cult <code>qyx</code>, so that we know who to respond to when the revision does appear. </p><p>If we&#39;ve already gotten to the first revision, then we can produce some content immediately. If we&#39;ve also gotten to the final revision, and that revision is earlier than the start revision, then it&#39;s a bad request and we call <code>++blub</code>, which tells the subscriber that his subscription will not be satisfied. </p><p>Otherwise, we find the data at the given path at the beginning of the subscription and at the last available revision in the subscription. If they&#39;re the same, then we don&#39;t send a notification. Otherwise, we call <code>++gack</code>, which creates the <code>++nako</code> we need to produce. We call <code>++bleb</code> to actually produce the information. </p><p>If we already have the last requested revision, then we also tell the subscriber with <code>++blub</code> that the subscription will receive no further updates. </p><p>If there will be more revisions in the subscription, then we call <code>++duce</code>, adding the duct to our subscribers. We modify the rove to start at the next revision since we&#39;ve already handled all the revisions up to the present. </p><p>We glossed over the calls to <code>++lobes-at-path</code>, <code>++make-nako</code>, and <code>++bleb</code>, so we&#39;ll get back to those right now. <code>++bleb</code> is simple, so we&#39;ll start with that. </p><pre>        ++  bleb                                          ::  ship sequence
          |=  [hen=duct ins=@ud hip=nako]
          ^+  +&gt;
          (blab hen [%w [%ud ins] ~] hip)
</pre><p>We&#39;re given a duct, the beginning revision number, and the nako that contains the updates since that revision. We use <code>++blab</code> to produce this result to the subscriber. The case is <code>%w</code> with a revision number of the beginning of the subscription, and the data is the nako itself. </p><p>We call <code>++lobes-at-path:ze</code> to get the data at the particular path. </p><pre>      ++  lobes-at-path                                     ::    lobes-at-path:ze
        |=  [oan=aeon pax=path]                             ::  data at path
        ^-  (map path lobe)
        ?:  =(0 oan)  ~
        %-  mo
        %+  skim
          %.  ~
          %~  tap  by
          =&lt;  q
          %-  tako-to-yaki
          %-  aeon-to-tako
          oan
        |=  [p=path q=lobe]
        ?|  ?=(~ pax)
            ?&amp;  !?=(~ p)
                =(-.pax -.p)
                $(p +.p, pax +.pax)
        ==  ==
</pre><p>At revision zero, the theoretical common revision between all repositories, there is no data, so we produce null. </p><p>We get the list of paths (paired with their lobe) in the revision referred to by the given number and we keep only those paths which begin with <code>pax</code>. Converting to a map, we now have a map from the subpaths at the given path to the hash of their data. This is simple and efficient to calculate and compare to later revisions. This allows us to easily tell if a node or its children have changed. </p><p>Finally, we will describe <code>++make-nako:ze</code>. </p><pre>      ++  make-nako                                         ::  gack a through b
        |=  [a=aeon b=aeon]
        ^-  [(map aeon tako) aeon (set yaki) (set blob)]
        :_  :-  b
            =-  [(takos-to-yakis -&lt;) (lobes-to-blobs -&gt;)]
            %+  reachable-between-takos
              (~(get by hit) a)                             ::  if a not found, a=0
            (aeon-to-tako b)
        ^-  (map aeon tako)
        %-  mo  %+  skim  (~(tap by hit) ~)
        |=  [p=aeon *]
        &amp;((gth p a) (lte p b))
</pre><p>We need to produce four things -- the numbers of the new commits, the number of the latest commit, the new commits themselves, and the new data itself. </p><p>The first is fairly easy to produce. We simply go over our map of numbered commits and produce all those numbered greater than <code>a</code> and not greater than <code>b</code>. </p><p>The second is even easier to produce -- <code>b</code> is clearly our most recent commit. </p><p>The third and fourth are slightly more interesting, though not too terribly difficult. First, we call <code>++reachable-between-takos</code>. </p><pre>      ++  reachable-between-takos
        |=  [a=(unit tako) b=tako]                          ::  pack a through b
        ^-  [(set tako) (set lobe)]
        =+  ^=  sar
            ?~  a  ~
            (reachable-takos r:(tako-to-yaki u.a))
        =+  yak=`yaki`(tako-to-yaki b)
        %+  new-lobes-takos  (new-lobes ~ sar)              ::  get lobes
        |-  ^-  (set tako)                                  ::  walk onto sar
        ?:  (~(has in sar) r.yak)
          ~
        =+  ber=`(set tako)`(~(put in `(set tako)`~) `tako`r.yak)
        %-  ~(uni in ber)
        ^-  (set tako)
        %+  roll  p.yak
        |=  [yek=tako bar=(set tako)]
        ^-  (set tako)
        ?:  (~(has in bar) yek)                             ::  save some time
          bar
        %-  ~(uni in bar)
        ^$(yak (tako-to-yaki yek))
</pre><p>We take a possible starting commit and a definite ending commit, and we produce the set of commits and the set of data between them. </p><p>We let <code>sar</code> be the set of commits reachable from <code>a</code>. If <code>a</code> is null, then obviously no commits are reachable. Otherwise, we call <code>++reachable-takos</code> to calculate this. </p><pre>      ++  reachable-takos                                   ::  reachable
        |=  p=tako                                          ::  XX slow
        ^-  (set tako)
        =+  y=(tako-to-yaki p)
        =+  t=(~(put in _(set tako)) p)
        %+  roll  p.y
        |=  [q=tako s=_t]
        ?:  (~(has in s) q)                                 ::  already done
          s                                                 ::  hence skip
        (~(uni in s) ^$(p q))                               ::  otherwise traverse
</pre><p>We very simply produce the set of the given tako plus its parents, recursively. </p><p>Back in <code>++reachable-between-takos</code>, we let <code>yak</code> be the yaki of <code>b</code>, the ending commit. With this, we create a set that is the union of <code>sar</code> and all takos reachable from <code>b</code>. </p><p>We pass <code>sar</code> into <code>++new-lobes</code> to get all the lobes referenced by any tako referenced by <code>a</code>. The result is passed into <code>++new-lobes-takos</code> to do the same, but not recomputing those in already calculated last sentence. This produces the sets of takos and lobes we need. </p><pre>      ++  new-lobes                                         ::  object hash set
        |=  [b=(set lobe) a=(set tako)]                     ::  that aren&#39;t in b
        ^-  (set lobe)
        %+  roll  (~(tap in a) ~)
        |=  [tak=tako bar=(set lobe)]
        ^-  (set lobe)
        =+  yak=(tako-to-yaki tak)
        %+  roll  (~(tap by q.yak) ~)
        |=  [[path lob=lobe] far=_bar]
        ^-  (set lobe)
        ?~  (~(has in b) lob)                               ::  don&#39;t need
          far
        =+  gar=(lobe-to-blob lob)
        ?-  -.gar
          %direct  (~(put in far) lob)
          %delta  (~(put in $(lob q.gar)) lob)
          %indirect  (~(put in $(lob s.gar)) lob)
        ==
</pre><p>Here, we&#39;re creating a set of lobes referenced in a commit in <code>a</code>. We start out with <code>b</code> as the initial set of lobes, so we don&#39;t need to recompute any of the lobes referenced in there. </p><p>The algorithm is pretty simple, so we won&#39;t bore you with the details. We simply traverse every commit in <code>a</code>, looking at every blob referenced there, and, if it&#39;s not already in <code>b</code>, we add it to <code>b</code>. In the case of a direct blob, we&#39;re done. For a delta or an indirect blob, we recursively add every blob referenced within the blob. </p><pre>      ++  new-lobes-takos                                   ::  garg &amp; repack
        |=  [b=(set lobe) a=(set tako)]
        ^-  [(set tako) (set lobe)]
        [a (new-lobes b a)]
</pre><p>Here, we just update the set of lobes we&#39;re given with the commits we&#39;re given and produce both sets. </p><p>This concludes our discussion of a local subscription. </p><h2 id="lifecycle-of-a-foreign-read-or-subscription-">Lifecycle of a Foreign Read or Subscription </h2><p>Foreign reads and subscriptions are handled in much the same way as local ones. The interface is the same -- a vane or app sends a <code>%warp</code> kiss with the request. The difference is simply that the <code>sock</code> refers to the foreign ship. </p><p>Thus, we start in the same place -- in <code>++call</code>, handling <code>%warp</code>. However, since the two side of the <code>sock</code> are different, we follow a different path. </p><pre>            =+  wex=(do now p.q.hic p.q.q.hic ruf)
            =+  ^=  woo
              ?~  q.q.q.hic
                abet:(ease:wex hen)
              abet:(eave:wex hen u.q.q.q.hic)
            [-.woo (posh q.p.q.hic p.q.q.hic +.woo ruf)]
</pre><p>If we compare this to how the local case was handled, we see that it&#39;s not all that different. We use <code>++do</code> rather than <code>++un</code> and <code>++de</code> to set up the core for the foreign ship. This gives us a <code>++de</code> core, so we either cancel or begin the request by calling <code>++ease</code> or <code>++eave</code>, exactly as in the local case. In either case, we call <code>++abet:de</code> to resolve our various types of output into actual moves, as described in the local case. Finally, we call <code>++posh</code> to update our raft, putting the modified rung into the raft. </p><p>We&#39;ll first trace through <code>++do</code>. </p><pre>      ++  do
        |=  [now=@da [who=ship him=ship] syd=@tas ruf=raft]
        =+  ^=  rug  ^-  rung
            =+  rug=(~(get by hoy.ruf) him)
            ?^(rug u.rug *rung)
        =+  ^=  red  ^-  rede
            =+  yit=(~(get by rus.rug) syd)
            ?^(yit u.yit `rede`[~2000.1.1 ~ [~ *rind] *dome])
        ((de now ~ ~) [who him] syd red ran.ruf)
</pre><p>If we already have a rung for this foreign ship, then we use that. Otherwise, we create a new blank one. If we already have a rede in this rung, then we use that, otherwise we create a blank one. An important point to note here is that we let <code>ref</code> in the rede be <code>[~ *rind]</code>. Recall, for domestic desks <code>ref</code> is null. We use this to distinguish between foreign and domestic desks in <code>++de</code>. </p><p>With this information, we create a <code>++de</code> core as usual. </p><p>Although we&#39;ve already covered <code>++ease</code> and <code>++eave</code>, we&#39;ll go through them quickly again, highlighting the case of foreign request. </p><pre>        ++  ease                                          ::  release request
          |=  hen=duct
          ^+  +&gt;
          ?~  ref  +&gt;
            =+  rov=(~(got by qyx) hen)
            =.  qyx  (~(del by qyx) hen)
            (mabe rov (cury best hen))
          =.  qyx  (~(del by qyx) hen)
          |-  ^+  +&gt;+.$
          =+  nux=(~(get by fod.u.ref) hen)
          ?~  nux  +&gt;+.$
          %=  +&gt;+.$
            say        [[hen [(scot %ud u.nux) ~] for [u.nux syd ~]] say]
            fod.u.ref  (~(del by fod.u.ref) hen)
            bom.u.ref  (~(del by bom.u.ref) u.nux)
          ==
</pre><p>Here, we still remove the duct from our cult (we maintain a cult even for foreign desks), but we also need to tell the foreign desk to cancel our subscription. We do this by sending a request (by appending to <code>say</code>, which gets resolved in <code>++abet:de</code> to a <code>%want</code> kiss to ames) to the foreign ship to cancel the subscription. Since we don&#39;t anymore expect a response on this duct, we remove it from <code>fod</code> and <code>bom</code>, which are the maps between ducts, raves, and request sequence numbers. Basically, we remove every trace of the subscription from our request manager. </p><p>In the case of <code>++eave</code>, where we&#39;re creating a new request, everything is exactly identical to the case of the local request except <code>++duce</code>. We said that <code>++duce</code> simply puts the request into our cult. This is true for a domestic request, but distinctly untrue for foreign requests. </p><pre>        ++  duce                                          ::  produce request
          |=  [hen=duct rov=rove]
          ^+  +&gt;
          =.  qyx  (~(put by qyx) hen rov)
          ?~  ref  +&gt;.$
          |-  ^+  +&gt;+.$                                   ::  XX  why?
          =+  rav=(reve rov)
          =+  ^=  vaw  ^-  rave
            ?.  ?=([%&amp; %v *] rav)  rav
            [%| [%ud let.dom] `case`q.p.rav r.p.rav]
          =+  inx=nix.u.ref
          %=  +&gt;+.$
            say        [[hen [(scot %ud inx) ~] for [inx syd ~ vaw]] say]
            nix.u.ref  +(nix.u.ref)
            bom.u.ref  (~(put by bom.u.ref) inx [hen vaw])
            fod.u.ref  (~(put by fod.u.ref) hen inx)
          ==
</pre><p>If we have a request manager (i.e. this is a foreign desk), then we do the approximate inverse of <code>++ease</code>. We create a rave out of the given request and send it off to the foreign desk by putting it in <code>say</code>. Note that the rave is created to request the information starting at the next revision number. Since this is a new request, we put it into <code>fod</code> and <code>bom</code> to associate the request with its duct and its sequence number. Since we&#39;re using another sequence number, we must increment <code>nix</code>, which represents the next available sequence number. </p><p>And that&#39;s really it for this side of the request. Requesting foreign information isn&#39;t that hard. Let&#39;s see what it looks like on the other side. When we get a request from another ship for information on our ship, that comes to us in the form of a <code>%wart</code> from ames. </p><p>We handle a <code>%wart</code> in <code>++call</code>, right next to where we handle the <code>%warp</code> case. </p><pre>            %wart
          ?&gt;  ?=(%re q.q.hic)
          =+  ryf=((hard riff) s.q.hic)
          :_  ..^$
          :~  :-  hen
              :^  %pass  [(scot %p p.p.q.hic) (scot %p q.p.q.hic) r.q.hic]
                %c
              [%warp [p.p.q.hic p.p.q.hic] ryf]
          ==
</pre><p>Every request we receive should be of type <code>riff</code>, so we coerce it into that type. We just convert this into a new <code>%warp</code> kiss that we pass to ourself. This gets handled like normal, as a local request. When the request produces a value, it does so like normal as a <code>%writ</code>, which is returned to <code>++take</code> along the path we just sent it on. </p><pre>            %writ
          ?&gt;  ?=([@ @ *] tea)
          =+  our=(need (slaw %p i.tea))
          =+  him=(need (slaw %p i.t.tea))
          :_  ..^$
          :~  :-  hen
              [%pass ~ %a [%want [our him] [%r %re %c t.t.tea] p.+.q.hin]]
          ==
</pre><p>Since we encoded the ship we need to respond to in the path, we can just pass our <code>%want</code> back to ames, so that we tell the requesting ship about the new data. </p><p>This comes back to the original ship as a <code>%waft</code> from ames, which comes into <code>++take</code>, right next to where we handled <code>%writ</code>. </p><pre>            %waft
          ?&gt;  ?=([@ @ ~] tea)
          =+  syd=(need (slaw %tas i.tea))
          =+  inx=(need (slaw %ud i.t.tea))
          =+  ^=  zat
            =&lt;  wake
            (knit:(do now p.+.q.hin syd ruf) [inx ((hard riot) q.+.q.hin)])
          =^  mos  ruf
            =+  zot=abet.zat
            [-.zot (posh q.p.+.q.hin syd +.zot ruf)]
          [mos ..^$(ran.ruf ran.zat)]                         ::  merge in new obj
</pre><p>This gets the desk and sequence number from the path the request was sent over. This determines exactly which request is being responded to. We call <code>++knit:de</code> to apply the changes to our local desk, and we call <code>++wake</code> to update our subscribers. Then we call <code>++abet:de</code> and <code>++posh</code> as normal (like in <code>++eave</code>). </p><p>We&#39;ll examine <code>++knit</code> and <code>++wake</code>, in that order. </p><pre>        ++  knit                                          ::  external change
          |=  [inx=@ud rot=riot]
          ^+  +&gt;
          ?&gt;  ?=(^ ref)
          |-  ^+  +&gt;+.$
          =+  ruv=(~(get by bom.u.ref) inx)
          ?~  ruv  +&gt;+.$
          =&gt;  ?.  |(?=(~ rot) ?=(&amp; -.q.u.ruv))  .
              %_  .
                bom.u.ref  (~(del by bom.u.ref) inx)
                fod.u.ref  (~(del by fod.u.ref) p.u.ruv)
              ==
          ?~  rot
            =+  rav=`rave`q.u.ruv
            %=    +&gt;+.$
                lim
              ?.(&amp;(?=(| -.rav) ?=(%da -.q.p.rav)) lim `@da`p.q.p.rav)
            ::
                haw.u.ref
              ?.  ?=(&amp; -.rav)  haw.u.ref
              (~(put by haw.u.ref) p.rav ~)
            ==
          ?&lt;  ?=(%v p.p.u.rot)
          =.  haw.u.ref
            (~(put by haw.u.ref) [p.p.u.rot q.p.u.rot q.u.rot] ~ r.u.rot)
          ?.  ?=(%w p.p.u.rot)  +&gt;+.$
          |-  ^+  +&gt;+.^$
          =+  nez=[%w [%ud let.dom] ~]
          =+  nex=(~(get by haw.u.ref) nez)
          ?~  nex  +&gt;+.^$
          ?~  u.nex  +&gt;+.^$  ::  should never happen
          =.  +&gt;+.^$     =+  roo=(edis ((hard nako) u.u.nex))
                         ?&gt;(?=(^ ref.roo) roo)
          %=  $
            haw.u.ref  (~(del by haw.u.ref) nez)
          ==
</pre><p>This is kind of a long gate, but don&#39;t worry, it&#39;s not bad at all. </p><p>First, we assert that we&#39;re not a domestic desk. That wouldn&#39;t make any sense at all. </p><p>Since we have the sequence number of the request, we can get the duct and rave from <code>bom</code> in our request manager. If we didn&#39;t actually request this data (or the request was canceled before we got it), then we do nothing. </p><p>Else, we remove the request from <code>bom</code> and <code>fod</code> unless this was a subscription request and we didn&#39;t receive a null riot (which would indicate the last message on the subscription). </p><p>Now, if we received a null riot, then if this was a subscription request by date, then we update <code>lim</code> in our request manager (representing the latest time at which we have complete information for this desk) to the date that was requested. If this was a single read request, then we put the result in our simple cache <code>haw</code> to make future requests faster. Then we&#39;re done. </p><p>If we received actual data, then we put it into our cache <code>haw</code>. Unless it&#39;s a <code>%w</code> request, we&#39;re done. </p><p>If it is a <code>%w</code> request, then we try to get the <code>%w</code> at our current head from the cache. In general, that should be the thing we just put in a moment ago, but that is not guaranteed. The most common case where this is different is when we receive desk updates out of order. At any rate, since we now have new information, we need to apply it to our local copy of the desk. We do so in <code>++edis</code>, and then we remove the stuff we just applied from the cache, since it&#39;s not really a true “single read”, like what should really be in the cache. </p><pre>        ++  edis                                          ::  apply subscription
          |=  nak=nako
          ^+  +&gt;
          %=  +&gt;
            hit.dom  (~(uni by hit.dom) gar.nak)
            let.dom  let.nak
            lat.ran  %+  roll  (~(tap in bar.nak) ~)
                     =&lt;  .(yeb lat.ran)
                     |=  [sar=blob yeb=(map lobe blob)]
                     =+  zax=(blob-to-lobe sar)
                     %+  ~(put by yeb)  zax  sar
            hut.ran  %+  roll  (~(tap in lar.nak) ~)
                     =&lt;  .(yeb hut.ran)
                     |=  [sar=yaki yeb=(map tako yaki)]
                     %+  ~(put by yeb)  r.sar  sar
          ==
</pre><p>This shows, of course, exactly why nako is defined the way it is. To become completely up to date with the foreign desk, we need to merge <code>hit</code> with the foreign one so that we have all the revision numbers. We update <code>let</code> so that we know which revision is the head. </p><p>We merge the new blobs in <code>lat</code>, keying them by their hash, which we get from a call to <code>++blob-to-lobe</code>. Recall that the hash is stored in the actual blob itself. We do the same thing to the new yakis, putting them in <code>hut</code>, keyed by their hash. </p><p>Now, our local dome should be exactly the same as the foreign one. </p><p>This concludes our discussion of <code>++knit</code>. Now the changes have been applied to our local copy of the desk, and we just need to update our subscribers. We do so in <code>++wake:de</code>. </p><pre>        ++  wake                                          ::  update subscribers
          ^+  .
          =+  xiq=(~(tap by qyx) ~)
          =|  xaq=(list ,[p=duct q=rove])
          |-  ^+  ..wake
          ?~  xiq
            ..wake(qyx (~(gas by *cult) xaq))
          ?-    -.q.i.xiq
              &amp;
            =+  cas=?~(ref ~ (~(get by haw.u.ref) `mood`p.q.i.xiq))
            ?^  cas
              %=    $
                  xiq  t.xiq
                  ..wake  ?~  u.cas  (blub p.i.xiq)
                          (blab p.i.xiq p.q.i.xiq u.u.cas)
              ==
            =+  nao=(~(case-to-aeon ze lim dom ran) q.p.q.i.xiq)
            ?~  nao  $(xiq t.xiq, xaq [i.xiq xaq])
            $(xiq t.xiq, ..wake (balk p.i.xiq u.nao p.q.i.xiq))
          ::
              |
            =+  mot=`moot`p.q.i.xiq
            =+  nab=(~(case-to-aeon ze lim dom ran) p.mot)
            ?~  nab
              $(xiq t.xiq, xaq [i.xiq xaq])
            =+  huy=(~(case-to-aeon ze lim dom ran) q.mot)
            ?~  huy
              =+  ptr=[%ud +(let.dom)]
              %=  $
                xiq     t.xiq
                xaq     [[p.i.xiq [%| ptr q.mot r.mot s.mot]] xaq]
                ..wake  =+  ^=  ear
                            (~(lobes-at-path ze lim dom ran) let.dom r.p.q.i.xiq)
                        ?:  =(s.p.q.i.xiq ear)  ..wake
                        =+  fud=(~(make-nako ze lim dom ran) u.nab let.dom)
                        (bleb p.i.xiq let.dom fud)
              ==
            %=  $
              xiq     t.xiq
              ..wake  =-  (blub:- p.i.xiq)
                      =+  ^=  ear
                          (~(lobes-at-path ze lim dom ran) u.huy r.p.q.i.xiq)
                      ?:  =(s.p.q.i.xiq ear)  (blub p.i.xiq)
                      =+  fud=(~(make-nako ze lim dom ran) u.nab u.huy)
                      (bleb p.i.xiq +(u.nab) fud)
            ==
          ==
        --
</pre><p>This is even longer than <code>++knit</code>, but it&#39;s pretty similar to <code>++eave</code>. We loop through each of our subscribers <code>xiq</code>, processing each in turn. When we&#39;re done, we just put the remaining subscribers back in our subscriber list. </p><p>If the subscriber is a single read, then, if this is a foreign desk (note that <code>++wake</code> is called from other arms, and not only on foreign desks). Obviously, if we find an identical request there, then we can produce the result immediately. Referential transparency for the win. We produce the result with a call to <code>++blab</code>. If this is a foreign desk but the result is not in the cache, then we produce <code>++blub</code> (canceled subscription with no data) for reasons entirely opaque to me. Seriously, it seems like we should wait until we get an actual response to the request. If someone figures out why this is, let me know. At any rate, it seems to work. </p><p>If this is a domestic desk, then we check to see if the case exists yet. If it doesn&#39;t, then we simply move on to the next subscriber, consing this one onto <code>xaq</code> so that we can check again the next time around. If it does exist, then we call <code>++balk</code> to fulfill the request and produce it. </p><p><code>++balk</code> is very simple, so we&#39;ll describe it here before we get to the subscription case. </p><pre>        ++  balk                                          ::  read and send
          |=  [hen=duct oan=@ud mun=mood]
          ^+  +&gt;
          =+  vid=(~(read-at-aeon ze lim dom ran) oan mun)
          ?~  vid  (blub hen)  (blab hen mun u.vid)
</pre><p>We call <code>++read-at-aeon</code> on the given request and aeon. If you recall, this processes a <code>mood</code> at a particular aeon and produces the result, if there is one. If there is data at the requested location, then we produce it with <code>++blab</code>. Else, we call <code>++blub</code> to notify the subscriber that no data can ever come over this subscriptioin since it is now impossible for there to ever be data for the given request. Because referential transparency. </p><p>At any rate, back to <code>++wake</code>. If the given rave is a subscription request, then we proceed similarly to how we do in <code>++eave</code>. We first try to get the aeon referred to by the starting case. If it doesn&#39;t exist yet, then we can&#39;t do anything interesting with this subscription, so we move on to the next one. </p><p>Otherwise, we try to get the aeon referred to by the ending case. If it doesn&#39;t exist yet, then we produce all the information we can. We call <code>++lobes-at-path</code> at the given aeon and path to see if the requested path has actually changed. If it hasn&#39;t, then we don&#39;t produce anything; else, we produce the correct nako by calling <code>++bleb</code> on the result of <code>++make-nako</code>, as in <code>++eave</code>. At any rate, we move on to the next subscription, putting back into our cult the current subscription with a new start case of the next aeon after the present. </p><p>If the aeon referred to by the ending case does exist, then we drop this subscriber from our cult and satisfy its request immediately. This is the same as before -- we check to see if the data at the path has actually changed, producing it if it has; else, we call <code>++blub</code> since no more data can be produced over this subscription. </p><p>This concludes our discussion of foreign requests. </p></div></div></div></div></div><footer class="mb-36"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>