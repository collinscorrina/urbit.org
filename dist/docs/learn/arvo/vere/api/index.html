<html><head></head><meta charset="utf-8" /><body><html><head><meta charset="UTF-8" /><title>Urbit / Docs</title><meta name="viewport" content="width=device-width , initial-scale=1" /><link href="/tilde.ico" rel="icon" /><link href="/css/base.css" rel="stylesheet" /><link href="/css/lists.css" rel="stylesheet" /><link href="/css/visibility.css" rel="stylesheet" /><link href="/css/borders.css" rel="stylesheet" /><link href="/css/colors.css" rel="stylesheet" /><link href="/css/inputs.css" rel="stylesheet" /><link href="/css/typography.css" rel="stylesheet" /><link href="/css/menu.css" rel="stylesheet" /><link href="/css/images.css" rel="stylesheet" /><link href="/css/flex.css" rel="stylesheet" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-47054188-1"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-47054188-1');</script></head><body><nav class="bg-black pb-36 menu-hide overflow-y"><div class="container"><div class="row pt-10 mb-3"><div class="col-sm-1 menu-toggle"><img class="w-8 h-8" src="/assets/menu-close.svg" /></div><div class="col-sm-9 col-md-8 col-lg-4 col-sm-offset-2 col-md-offset-1 white"><div class="mb-6"><a href="/primer"><h1>Primer</h1></a><p> </p></div><div class="mb-6"><a href="/posts"><h1>Posts</h1></a><p> </p></div><div class="mb-6"><a href="/docs"><h1>Docs</h1></a><p> </p></div></div></div></div><footer class="container mb-36 white"><div class="row"><div class="col-sm-6 col-sm-offset-3 col-md-offset-2"><div><div class="mb-6"><h4 class="mb-1">Follow</h4><div><a class="text-mono" href="https://twitter.com/@urbit" target="_blank">twitter.com/@urbit</a></div><div><a class="text-mono" href="https://github.com/urbit" target="_blank">github.com/@urbit</a></div></div><div class="mb-6"><h4 class="mb-1">Contact</h4><div class="text-mono text-400">~zod</div><div><a class="text-mono" href="mailto:support@urbit.org">support@urbit.org</a></div></div><div class="mb-6"><h4 class="mb-1">Company</h4><div><a href="/privacy">Privacy Policy</a></div><div><a href="/tos">Terms of Service</a></div><div class="text-400"><a href="/bounty">Bug Bounty + Security</a></div></div></div></div></div></footer></nav><div id="sidebar-mobile" class="bg-gray-light sidebar-hide overflow-y"><div class="container"><div class="col-sm-10"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div><div class="col-sm-1 sidebar-toggle fixed" style="top: 20px; right: 1em"><img class="w-8 h-8 dropdown-right" src="/assets/dropdown.svg" /></div></div></div><div class="container mt-10"><div class="sidebar-container row col-sm-3 fixed pb-30 h-100-md"><div class="col-sm-3 col-lg-6 menu-toggle"><img class="w-8 h-8" src="/assets/menu-open.svg" /></div><div class="col-sm-12 mt-7 sidebar-toggle md-hide"><img class="w-8 h-8 dropdown-left" src="/assets/dropdown.svg" /></div><div class="h-100 col-sm-8 col-md-11 overflow-y sm-hide"><ol class="list-reset h-font mt-6"><li class="mb-4"><a class="h-font text-600" href="/docs/introduction">Introduction</a><ol><li><a class="h-font" href="/docs/introduction/technical-overview">Technical overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/source-code-overview">Source Code Overview</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/contributing">Contributing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/arvo-vs-azimuth">Arvo vs. Azimuth</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/community-tutorials">Community Tutorials</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/introduction/galaxies-stars-and-planets">Galaxies, Stars, and Planets</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/getting-started">Getting Started</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/getting-started/azimuth">Using Bridge</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/installing-urbit">Installing Urbit</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/booting-a-ship">Booting a Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/creating-a-development-ship">Creating a Development Ship</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/getting-started/operating-a-star">Operating a Star</a><ol class="list-reset h-font"></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/learn">Learn</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo">Arvo</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals">Arvo Internals</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ames">Ames</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/behn">Behn</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/admin">Admin and Operations</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/clay">Clay</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/dill">Dill</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/layout">Source layout</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/sail">Sail</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/messaging">Messaging</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/udon">Udon</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/eyre">Eyre</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/gall">Gall Apps</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/shell">Shell (Dojo)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/ford">Ford</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/hall">Hall</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/filesystem">Introduction to the Filesystem</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/publishing">Web (Eyre)</a></li><li><a class="h-font" href="/docs/learn/arvo/arvo-internals/generators">Generators</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/hoon">Hoon</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/hoon/getting-started">Getting Started</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/nouns">Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/the-subject-and-its-legs">The Subject and Its Legs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/arms-and-cores">Arms and Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/gates">Gates (Hoon Functions)</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/multi-gate-cores-and-doors">Multi-gate Cores and Doors</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-programs">Hoon Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/hoon-syntax">Hoon Syntax</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/simple-one-gate-programs">Simple One-Gate Programs</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/atoms-auras-and-simple-cell-types">Atoms, Auras, and Simple Cell Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-checking-and-type-inference">Type Checking and Type Inference</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/structures-and-complex-types">Structures and Complex Types</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores">Cores</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/cores-again">Cores Again</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/lists">Standard Library: Lists</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/trees-sets-and-maps">Standard Library: Trees, Sets, and Maps</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/type-polymorphism">Type Polymorphism</a></li><li><a class="h-font" href="/docs/learn/arvo/hoon/examples">Examples</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/nock">Nock</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/nock/definition">Nock Definition</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/explanation">Explanation</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/example">Example</a></li><li><a class="h-font" href="/docs/learn/arvo/nock/implementations">Implementations</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/vere">Vere</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/vere/runtime">C Runtime System</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/c">C in Urbit</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/nouns">Land of Nouns</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/api">API overview by prefix</a></li><li><a class="h-font" href="/docs/learn/arvo/vere/jetting">Writing Jets</a></li></ol></li><li><a class="h-font" href="/docs/learn/arvo/style">Hoon Style Guide</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/arvo/workbook">Hoon Workbook</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/arvo/workbook/list">List of Numbers</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/caesar">Caesar Cipher</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/recursion">Recursion</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/digits">Digits</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/eightball">Magic 8-Ball</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/traffic-light">Traffic Light</a></li><li><a class="h-font" href="/docs/learn/arvo/workbook/bomb">Bomb Defusing</a></li></ol></li></ol></li><li><a class="h-font" href="/docs/learn/azimuth">Azimuth</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/learn/azimuth/blockchain">Why Urbit Uses a Blockchain</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/learn/azimuth/wallet">The Urbit HD Wallet</a><ol class="list-reset h-font"></ol></li></ol></li></ol></li><li class="mb-4"><a class="h-font text-600" href="/docs/reference">Reference</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions">Hoon Expressions</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune">Runes</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/constants">Atoms and strings</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/dot">Nock . (&quot;dot&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/zap">Wild ! (&quot;zap&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/tis">Change Subject = (&quot;tis&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/wut">Conditionals ? (&quot;wut&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bar">Cores | (&quot;bar&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/lus">Arms + (&quot;lus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/col">Cells : (&quot;col&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/cen">Calls % (&quot;cen&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/ket">Casts ^ (&quot;ket&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/bus">Structures $ (&quot;bus&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/mic">Make ; (&quot;mic&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/sig">Hints ~ (&quot;sig&quot;)</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/rune/terminators">Terminators -- and ==</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb">Limbs and Wings</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/limb">Limbs</a></li><li><a class="h-font" href="/docs/reference/hoon-expressions/limb/wing">Wings</a></li></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/basic">Basic Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/advanced">Advanced Types</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/hoon-expressions/irregular">Irregular forms</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/library">Standard library</a><ol class="list-reset h-font"><li><a class="h-font" href="/docs/reference/library/1a">1a: Basic Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1b">1b: Tree Addressing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/1c">1c: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2a">2a: Unit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2b">2b: List Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2c">2c: Bit Arithmetic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2d">2d: Bit Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2e">2e: Insecure Hashing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2f">2f: Noun Ordering</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2g">2g: Unsigned Powers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2h">2h: Set Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2i">2i: Map Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2j">2j: Jar and Jug Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2k">2k: Queue Logic</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2l">2l: Container from Container</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2m">2m: Container from Noun</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2n">2n: Functional Hacks</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2o">2o: Normalizing Containers</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2p">2p: Serialization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/2q">2q: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3a">3a: Modular and Signed Ints</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3b">3b: Floating Point</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3c">3c: Urbit Time</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3d">3d: SHA Hash Family</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3e">3e: (Removed)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3f">3f: Scrambling</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/3g">3g: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4a">4a: Exotic Bases</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4b">4b: Text Processing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4c">4c: Tank Printer</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4d">4d: Parsing (Tracing)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4e">4e: Parsing (Combinators)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4f">4f: Parsing (Rule-Builders)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4g">4g: Parsing (Outside Caller)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4h">4h: Parsing (ASCII Glyphs)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4i">4i: Parsing (Useful Idioms)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4j">4j: Parsing (Bases and Base Digits)</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4k">4k: Atom Printing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4l">4l: Atom Parsing</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4m">4m: Formatting Functions</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4n">4n: Virtualization</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/4o">4o: Molds</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5a">5a: Compiler Utilities</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5b">5b: Macro Expansion</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5c">5c: Compiler Backend &amp; Prettyprinter</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5d">5d: Parser</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5e">5e: Caching Compiler</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5f">5f: Molds and Mold-Builders</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/5g">5g: profiling support</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/library/zuse">Zuse</a><ol class="list-reset h-font"></ol></li></ol></li><li><a class="h-font" href="/docs/reference/glossary">Glossary</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/cheat-sheet">Cheat sheet</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/troubleshooting">Hoon Errors</a><ol class="list-reset h-font"></ol></li><li><a class="h-font" href="/docs/reference/alphabetical-arms">Alphabetical Arms</a><ol class="list-reset h-font"></ol></li></ol></li></ol></div></div><div class="row pb-80"><div class="col-sm-9 col-md-8 col-sm-offset-2 col-md-offset-3 docs"><div><div><h2 id="u3--api-overview-by-prefix-">u3: API overview by prefix </h2><p>Let&#39;s run through the <code>u3</code> modules one by one. All public functions are commented, but the comments may be cryptic. </p><h3 id="u3m--main-control-">u3m: main control </h3><p>To start <code>u3</code>, run </p><pre>/* u3m_boot(): start the u3 system.
*/
  void
  u3m_boot(c3_o nuu_o, c3_o bug_o, c3_c* dir_c);
</pre><p><code>nuu_o</code> is <code>c3y</code> (yes, <code>0</code>) if you&#39;re creating a new pier, <code>c3n</code> (no, <code>1</code>) if you&#39;re loading an existing one. <code>bug_o</code> is <code>c3y</code> if you want to test the garbage-collector, <code>c3n</code> otherwise. <code>dir_c</code> is the directory for the pier files. </p><p><code>u3m_boot()</code> expects an <code>urbit.pill</code> file to load the kernel from. It will try first <code>$dir/.urb.urbit.pill</code>, then <code>U3_LIB</code>. </p><p>Any significant computation with nouns, certainly anything Turing complete, should be run (a) virtualized and (b) in an inner road. These are slightly different things, but at the highest level we bundle them together for your convenience, in <code>u3m_soft()</code>: </p><pre>/* u3m_soft(): system soft wrapper.  unifies unix and nock errors.
**
**  Produces [%$ result] or [%error (list tank)].
*/
  u3_noun
  u3m_soft(c3_w sec_w, u3_funk fun_f, u3_noun arg);
</pre><p><code>sec_w</code> is the number of seconds to time out the computation. <code>fun_f</code> is a C function accepting <code>arg</code>. </p><p>The result of <code>u3m_soft()</code> is a cell whose head is an atom. If the head is <code>%$</code> - ie, <code>0</code> - the tail is the result of <code>fun_f(arg)</code>. Otherwise, the head is a <code>term</code> (an atom which is an LSB first string), and the tail is a <code>(list tank)</code> (a list of <code>tank</code> printables - see <code>++tank</code> in <code>hoon.hoon</code>). Error terms should be the same as the exception terms above. </p><p>If you&#39;re confident that your computation won&#39;t fail, you can use <code>u3m_soft_sure()</code>, <code>u3m_soft_slam()</code>, or <code>u3m_soft_nock()</code> for C functions, Hoon function calls, and Nock invocations. Caution - this returns just the result, and asserts globally. </p><p>All the <code>u3m_soft</code> functions above work <b>only on the surface</b>. Within the surface, virtualize with <code>u3m_soft_run()</code>. Note that this takes a <code>fly</code> (a namespace gate), thus activating the <code>11</code> super-operator in the nock virtualizer, <code>++mock</code>. When actually using the <code>fly</code>, call <code>u3m_soft_esc()</code>. Don&#39;t do either unless you know what you&#39;re doing! </p><p>For descending into a subroad <b>without</b> Nock virtualization, use <code>u3m_hate()</code> and <code>u3m_love</code> respectively. Hating enters a subroad; loving leaves it, copying out a product noun. </p><p>Other miscellaneous tools in <code>u3m</code>: <code>u3m_file()</code> loads a Unix file as a Nock atom; <code>u3m_water()</code> measures the boundaries of the loom in current use (ie, watermarks); and a variety of prettyprinting routines, none perfect, are available, mainly for debugging printfs: <code>u3m_pretty()</code>, <code>u3m_p()</code>, <code>u3m_tape()</code> and <code>u3m_wall()</code>. </p><p>It&#39;s sometimes nice to run a mark-and-sweep garbage collector, <code>u3m_grab()</code>, which collects the world from a list of roots, and asserts if it finds any leaks or incorrect refcounts. This tool is for debugging and long-term maintenance only; refcounts should never err. </p><h3 id="u3j--jets-">u3j: jets </h3><p>The jet system, <code>u3j</code>, is what makes <code>u3</code> and <code>nock</code> in any sense a useful computing environment. Except perhaps <code>u3a</code> (there is really no such thing as a trivial allocator, though <code>u3a</code> is dumber than most) - <code>u3j</code> is the most interesting code in <code>u3</code>. </p><p>Let&#39;s consider the minor miracle of driver-to-battery binding which lets <code>u3j</code> work - and decrement not be <code>O(n)</code> - without violating the precisely defined semantics of pure Nock, <b>ever</b>. </p><p>It&#39;s easy to assume that jets represent an architectural coupling between Hoon language semantics and Nock interpreter internals. Indeed such a coupling would be wholly wrongtious and un-Urbit. But the jet system is not Hoon-specific. It is specific to nock runtime systems that use a design pattern we call a <code>core</code>. </p><h4 id="u3j--core-structure-">u3j: core structure </h4><p>A core is no more than a cell <code>[code data]</code>, in which a <code>code</code> is either a Nock formula or a cell of <code>code</code>s, and <code>data</code> is anything. In a proper core, the subject each formula expects is the core itself. </p><p>Except for the arbitrary decision to make a core <code>[code data]</code>, (or as we sometimes say, <code>[battery payload]</code>), instead of <code>[data code]</code>, any high-level language transforming itself to Nock would use this design. </p><p>So jets are in fact fully general. Broadly speaking, the jet system works by matching a C <b>driver</b> to a battery. When the battery is invoked with Nock operator <code>9</code>, it must be found in associative memory and linked to its driver. Then we link the formula axis of the operation (<code>a</code> in <code>[9 a b]</code>) to a specific function in the driver. </p><p>To validate this jet binding, we need to know two things. One, we need to know the C function actually is a perfect semantic match for the Nock formula. This can be developed with driver test flags, which work, and locked down with a secure formula hash in the driver, which we haven&#39;t bothered with just yet. (You could also try to develop a formal method for verifying that C functions and Nock formulas are equivalent, but this is a research problem for the future.) </p><p>Two, we need to validate that the payload is appropriate for the battery. We should note that jets are a Nock feature and have no reference to Hoon. A driver which relies on the Hoon type system to only pair it with valid payloads is a broken driver, and breaks the Nock compliance of the system as a whole. So don&#39;t. </p><p>Now, a casual observer might look at <code>[battery payload]</code> and expect the simplest case of it to be <code>[formula subject]</code>. That is: to execute a simple core whose battery is a single formula, we compute </p><pre>nock(+.a -.a)
</pre><p>Then, naturally, when we go from Hoon or a high-level language containing functions down to Nock, <code>[function arguments]</code> turns into <code>[formula subject]</code>. This seems like an obvious design, and we mention it only because it is <b>completely wrong</b>. </p><p>Rather, to execute a one-armed core like the above, we run </p><pre>nock(a -.a)
</pre><p>and the normal structure of a <code>gate</code>, which is simply Urbitese for “function,” is: </p><pre>[formula [sample context]]
</pre><p>where <code>sample</code> is Urbitese for “arguments” - and <code>context</code>, any Lisper will at once recognize, is Urbitese for “environment.” </p><p>To <code>slam</code> or call the gate, we simply replace the default sample with the caller&#39;s data, then nock the formula on the entire gate. </p><p>What&#39;s in the context? Unlike in most dynamic languages, it is not some secret system-level bag of tricks. Almost always it is another core. This onion continues until at the bottom, there is an atomic constant, conventionally is the kernel version number. </p><p>Thus a (highly desirable) <code>static</code> core is one of the form </p><pre>[battery constant]
[battery static-core]
</pre><p>ie, a solid stack of nested libraries without any dynamic data. The typical gate will thus be, for example, </p><pre>[formula [sample [battery battery battery constant]]]
</pre><p>but we would be most foolish to restrict the jet mechanism to cores of this particular structure. We cannot constrain a payload to be <code>[sample static-core]</code>, or even <code>[sample core]</code>. Any such constraint would not be rich enough to handle Hoon, let alone other languages. </p><h4 id="u3j--jet-state-">u3j: jet state </h4><p>There are two fundamental rules of computer science: (1) every system is best understood through its state; (2) less state is better than more state. Sadly, a pier has three different jet state systems: <code>cold</code>, <code>warm</code> and <code>hot</code>. It needs all of them. </p><p>Hot state is associated with this particular Unix process. The persistent pier is portable not just between process and process, but machine and machine or OS and OS. The set of jets loaded into a pier may itself change (in theory, though not in the present implementation) during the lifetime of the process. Hot state is a pure C data structure. </p><p>Cold state is associated with the logical execution history of the pier. It consists entirely of nouns and ignores restarts. </p><p>Warm state contains all dependencies between cold and hot state. It consists of C structures allocated on the loom. </p><p>Warm state is purely a function of cold and hot states, and we can wipe and regenerate it at any time. On any restart where the hot state might have changed, we clear the warm state with <code>u3j_ream()</code>. </p><p>There is only one hot state, the global jet dashboard <code>u3j_Dash</code> or <code>u3D</code> for short. In the present implementation, u3D is a static structure not modified at runtime, except for numbering itself on process initialization. This structure - which embeds function pointers to all the jets - is defined in <code>j/tree.c</code>. The data structures: </p><pre>    /* u3j_harm: driver arm.
    */
      typedef struct _u3j_harm {
        c3_c*               fcs_c;            //  `.axe` or name
        u3_noun           (*fun_f)(u3_noun);  //  compute or 0 / semitransfer
        c3_o                ice;              //  perfect (don&#39;t test)
        c3_o                tot;              //  total (never punts)
        c3_o                liv;              //  live (enabled)
      } u3j_harm;

    /* u3j_core: C core driver.
    */
      typedef struct _u3j_core {
        c3_c*             cos_c;              //  control string
        struct _u3j_harm* arm_u;              //  blank-terminated static list
        struct _u3j_core* dev_u;              //  blank-terminated static list
        struct _u3j_core* par_u;              //  dynamic parent pointer
        c3_l              jax_l;              //  dynamic jet index
      } u3j_core;

    /* u3e_dash, u3_Dash, u3D: jet dashboard singleton
    */
      typedef struct _u3e_dash {
        u3j_core* dev_u;                      //  null-terminated static list
        c3_l      len_l;                      //  ray_u filled length
        c3_l      all_l;                      //  ray_u allocated length
        u3j_core* ray_u;                      //  dynamic driver array
      } u3j_dash;
</pre><p>Warm and cold state is <b>per road</b>. In other words, as we nest roads, we also nest jet state. The jet state in the road is: </p><pre>      struct {                                //  jet dashboard
        u3p(u3h_root) har_p;                  //  warm state
        u3_noun       das;                    //  cold state
      } jed;
</pre><p>In case you understand Hoon, <code>das</code> (cold state) is a <code>++dash</code>, and <code>har_p</code> (warm state) is a map from battery to <code>++calx</code>: </p><pre>    ++  bane  ,@tas                                 ::  battery name
    ++  bash  ,@uvH                                 ::  label hash
    ++  bosh  ,@uvH                                 ::  local battery hash
    ++  batt  ,*                                    ::  battery
    ++  calf                                        ::
      $:  jax=,@ud                                  ::  hot core index
          hap=(map ,@ud ,@ud)                       ::  axis/hot arm index
          lab=path                                  ::  label as path
          jit=*                                     ::  arbitrary data
      ==                                            ::
    ++  calx  (trel calf (pair bash cope) club)     ::  cached by battery
    ++  clog  (pair cope (map batt club))           ::  identity record
    ++  club  (pair corp (map term nock))           ::  battery pattern
    ++  cope  (trel bane axis (each bash noun))     ::  core pattern
    ++  core  ,*                                    ::  core
    ++  corp  (each core batt)                      ::  parent or static
    ++  dash  (map bash clog)                       ::  jet system
</pre><p>The driver index <code>jax</code> in a <code>++calx</code> is an index into <code>ray_u</code> in the dashboard - ie, a pointer into hot state. This is why the warm state has to be reset when we reload the pier in a new process. </p><p>Why is jet state nested? Nock of course is a functional system, so as we compute we don&#39;t explicitly create state. Jet state is an exception to this principle (which works only because it can&#39;t be semantically detected from Nock/Hoon) - but it can&#39;t violate the fundamental rules of the allocation system. </p><p>For instance, when we&#39;re on an inner road, we can&#39;t allocate on an outer road, or point from an outer road to an inner. So if we learn something - like a mapping from battery to jet - in the inner road, we have to keep it in the inner road. </p><p>Mitigating this problem, when we leave an inner road (with <code>u3m_love()</code>), we call <code>u3j_reap()</code> to promote jet information in the dying road. Reaping promotes anything we&#39;ve learned about any battery that either (a) already existed in the outer road, or (b) is being saved to the outer road. </p><h4 id="u3j--jet-binding-">u3j: jet binding </h4><p>Jet binding starts with a <code>%fast</code> hint. (In Hoon, this is produced by the runes <code>~%</code>, for the general case, or <code>~/</code> for simple functions.) To bind a jet, execute a formula of the form: </p><pre>[10 [%fast clue-formula] core-formula]
</pre><p><code>core-formula</code> assembles the core to be jet-propelled. <code>clue-formula</code> produces the hint information, or <code>++clue</code> above, which we want to annotate it with. </p><p>A clue is a triple of name, parent, and hooks: </p><pre>++  clue  (trel chum nock (list (pair term nock)))
</pre><p>The name, or <code>++chum</code>, has a bunch of historical structure which we don&#39;t need (cleaning these things up is tricky), but just gets flattened into a term. </p><p>The parent axis is a nock formula, but always reduces to a simple axis, which is the address of this core&#39;s <b>parent</b>. Consider again an ordinary gate </p><pre>[formula [sample context]]
</pre><p>Typically the <code>context</code> is itself a library core, which itself has a jet binding. If so, the parent axis of this gate is <code>7</code>. </p><p>If the parent is already bound - and the parent <b>must</b> be already bound, in this road or a road containing it - we can hook this core bottom-up into a tree hierarchy. Normally the child core is produced by an arm of the parent core, so this is not a problem - we wouldn&#39;t have the child if we hadn&#39;t already made the parent. </p><p>The clue also contains a list of <b>hooks</b>, named nock formulas on the core. Usually these are arms, but they need not be. The point is that we often want to call a core from C, in a situation where we have no type or other source information. A common case of this is a complex system in which we&#39;re mixing functions which are jet-propelled with functions that aren&#39;t. </p><p>In any case, all the information in the <code>%fast</code> hint goes to <code>u3j_mine()</code>, which registers the battery in cold state (<code>das</code> in <code>jed</code> in <code>u3R</code>), then warm state (<code>har_p</code> in <code>jed</code>). </p><p>It&#39;s essential to understand that the <code>%fast</code> hint has to be, well, fast - because we apply it whenever we build a core. For instance, if the core is a Hoon gate - a function - we will call <code>u3j_mine</code> every time the function is called. </p><h3 id="u3j--the-cold-jet-dashboard-">u3j: the cold jet dashboard </h3><p>For even more fun, the jet tree is not actually a tree of batteries. It&#39;s a tree of battery <b>labels</b>, where a label is an [axis term] path from the root of the tree. (At the root, if the core pattern is always followed properly, is a core whose payload is an atomic constant, conventionally the Hoon version.) </p><p>Under each of these labels, it&#39;s normal to have an arbitrary number of different Nock batteries (not just multiple copies of the same noun, a situation we <b>do</b> strive to avoid). For instance, one might be compiled with debugging hints, one not. </p><p>We might even have changed the semantics of the battery without changing the label - so long as those semantics don&#39;t invalidate any attached driver. </p><p>For instance, it&#39;s normal to have two equivalent Nock batteries at the same time in one pier: one battery compiled with debugging hints, one not. </p><p>Rather, the jet tree is a semantic hierarchy. The root of the hierarchy is a constant, by convention the Hoon kernel version because any normal jet-propelled core has, at the bottom of its onion of libraries, the standard kernel. Thus if the core is </p><pre>[foo-battery [bar-battery [moo-battery 164]]]
</pre><p>we can reverse the nesting to construct a hierarchical core path. The static core </p><pre>164/moo/bar/foo
</pre><p>extends the static core <code>164/moo/bar</code> by wrapping the <code>foo</code> battery (ie, in Hoon, <code>|%</code>) around it. With the core above, you can compute <code>foo</code> stuff, <code>bar</code> stuff, and <code>moo</code> stuff. Rocket science, not. </p><p>Not all cores are static, of course - they may contain live data, like the sample in a gate (ie, argument to a function). Once again, it&#39;s important to remember that we track jet bindings not by the core, which may not be static, but by the battery, which is always static. </p><p>(And if you&#39;re wondering how we can use a deep noun like a Nock formula or battery as a key in a key-value table, remember <code>mug_w</code>, the lazily computed short hash, in all boxed nouns.) </p><p>In any case, <code>das</code>, the dashboard, is a map from <code>bash</code> to jet location record (<code>++clog</code>). A <code>clog</code> in turn contains two kinds of information: the <code>++cope</code>, or per-location noun; and a map of batteries to a per-battery <code>++club</code>. </p><p>The <code>cope</code> is a triple of <code>++bane</code> (battery name, right now just a <code>term</code>); <code>++axis</code>, the axis, within <b>this</b> core, of the parent; and <code>(each bash noun)</code>, which is either <code>[0 bash]</code> if the parent is another core, or <code>[1 noun]</code>, for the constant noun (like <code>164</code>) if there is no parent core. </p><p>A <code>bash</code> is just the noun hash (<code>++sham</code>) of a <code>cope</code>, which uniquely expresses the battery&#39;s hierarchical location without depending on the actual formulas. </p><p>The <code>club</code> contains a <code>++corp</code>, which we use to actually validate the core. Obviously jet execution has to be perfectly compatible with Nock. We search on the battery, but getting the battery right is not enough - a typical battery is dependent on its context. For example, your jet-propelled library function is very likely to call <code>++dec</code> or other advanced kernel technology. If you&#39;ve replaced the kernel in your context with something else, we need to detect this and not run the jet. </p><p>There are two cases for a jet-propelled core - either the entire core is a static constant, or it isn&#39;t. Hence the definition of <code>corp</code>: </p><pre>++  corp  (each core batt)                ::  parent or static
</pre><p>Ie, a <code>corp</code> is <code>[0 core]</code> or <code>[1 batt]</code>. If it&#39;s static - meaning that the jet only works with one specific core, ie, the parent axis of each location in the hierarchy is <code>3</code> - we can validate with a single comparison. Otherwise, we have to recurse upward by checking the parent. </p><p>Note that there is at present no way to force a jet to depend on static <b>data</b>. </p><h3 id="u3j--the-warm-jet-dashboard-">u3j: the warm jet dashboard </h3><p>We don&#39;t use the cold state to match jets as we call them. We use the cold state to register jets as we find them, and also to rebuild the warm state after the hot state is reset. </p><p>What we actually use at runtime is the warm state, <code>jed-&gt;har_p</code>, which is a <code>u3h</code> (built-in hashtable), allocated on the loom, from battery to <code>++calx</code>. </p><p>A <code>calx</code> is a triple of a <code>++calf</code>, a <code>[bash cope]</code> cell, and a <code>club</code>. The latter two are all straight from cold state. </p><p>The <code>calf</code> contains warm data dependent on hot state. It&#39;s a quadruple: of <code>jax</code>, the hot driver index (in <code>ray_u</code> in <code>u3j_dash</code>); <code>hap</code>, a table from arm axis (ie, the axis of each formula within the battery) to driver arm index (into <code>arm_u</code> in <code>u3j_core</code>); <code>lab</code>, the complete label path; and <code>jit</code>, any other dynamic data that may speed up execution. </p><p>We construct <code>hap</code>, when we create the calx, by iterating through the arms registered in the <code>u3j_core</code>. Note the way a <code>u3j_harm</code> declares itself, with the string <code>fcs_c</code> which can contain either an axis or a name. Most jetted cores are of course gates, which have one formula at one axis within the core: <code>fcs_c</code> is <code>&quot;.3&quot;</code>. </p><p>But we do often have fast cores with more complex arm structure, and it would be sad to have to manage their axes by hand. To use an <code>fcs_c</code> with a named arm, it&#39;s sufficient to make sure the name is bound to a formula <code>[0 axis]</code> in the hook table. </p><p><code>jit</code>, as its name suggests, is a stub where any sort of optimization data computed on battery registration might go. To use it, fill in the <code>_cj_jit()</code> function. </p><h3 id="u3j--the-hot-dashboard-">u3j: the hot dashboard </h3><p>Now it should be easy to see how we actually invoke jets. Every time we run a nock <code>9</code> instruction (pretty often, obviously), we have a core and an axis. We pass these to <code>u3j_kick()</code>, which will try to execute them. </p><p>Because nouns with a reference count of 1 are precious, <code>u3j_kick()</code> has a tricky reference control definition. It reserves the right to return <code>u3_none</code> in the case where there is no driver, or the driver does not apply for this case; in this case, it retains argument <code>cor</code>. If it succeeds, though, it transfers <code>cor</code>. </p><p><code>u3j_kick()</code> searches for the battery (always the head of the core, of course) in the hot dashboard. If the battery is registered, it searches for the axis in <code>hap</code> in the <code>calx</code>. If it exists, the core matches a driver and the driver jets this arm. If not, we return <code>u3_none</code>. </p><p>Otherwise, we call <code>fun_f</code> in our <code>u3j_harm</code>. This obeys the same protocol as <code>u3j_kick()</code>; it can refuse to function by returning <code>u3_none</code>, or consume the noun. </p><p>Besides the actual function pointer <code>fun_f</code>, we have some flags in the <code>u3j_harm</code> which tell us how to call the arm function. </p><p>If <code>ice</code> is yes (<code>&amp;</code>, <code>0</code>), the jet is known to be perfect and we can just trust the product of <code>fun_f</code>. Otherwise, we need to run <b>both</b> the Nock arm and <code>fun_f</code>, and compare their results. </p><p>(Note that while executing the C side of this test, we have to set <code>ice</code> to yes; on the Nock side, we have to set <code>liv</code> to no. Otherwise, many non-exponential functions become exponential. When auto-testing jets in this way, the principle is that the test is on the outermost layer of recursion.) </p><p>(Note also that anyone who multi-threads this execution environment has a slight locking problem with these flags if arm testing is multi-threaded.) </p><p>If <code>tot</code> is yes, (<code>&amp;</code>, <code>0</code>), the arm function is <b>total</b> and has to return properly (though it can still return <b>u3_none</b>). Otherwise, it is <b>partial</b> and can <code>u3_cm_bail()</code> out with c3<i></i>punt. This feature has a cost: the jet runs in a subroad. </p><p>Finally, if <code>liv</code> is no (<code>|</code>, 1), the jet is off and doesn&#39;t run. </p><p>It should be easy to see how the tree of cores gets declared - precisely, in <code>j/dash.c</code>. We declare the hierarchy as a tree of <code>u3j_core</code> structures, each of which comes with a static list of arms <code>arm_u</code> and sub-cores <code>dev_u</code>. </p><p>In <code>u3j_boot()</code>, we traverse the hierarchy, fill in parent pointers <code>par_u</code>, and enumerate all <code>u3j_core</code> structures into a single flat array <code>u3j_dash.ray_u</code>. Our hot state then appears ready for action. </p><h3 id="u3j--jet-functions-">u3j: jet functions </h3><p>At present, all drivers are compiled statically into <code>u3</code>. This is not a long-term permanent solution or anything. However, it will always be the case with a certain amount of core functionality. </p><p>For instance, there are some jet functions that we need to call as part of loading the Arvo kernel - like <code>++cue</code> to unpack a noun from an atom. And obviously it makes sense, when jets are significant enough to compile into <code>u3</code>, to export their symbols in headers and the linker. </p><p>There are three interface prefixes for standard jet functions: <code>u3k</code>, <code>u3q</code>, and <code>u3w</code>. All jets have <code>u3w</code> interfaces; most have <code>u3q</code>; some have <code>u3k</code>. Of course the actual logic is shared. </p><p><code>u3w</code> interfaces use the same protocol as <code>fun_f</code> above: the caller passes the entire core, which is retained if the function returns <code>u3_none</code>, transferred otherwise. Why? Again, use counts of 1 are special and precious for performance hackers. </p><p><code>u3q</code> interfaces break the core into C arguments, <b>retain</b> noun arguments, and <b>transfer</b> noun returns. <code>u3k</code> interfaces are the same, except with more use of <code>u3_none</code> and other simple C variations on the Hoon original, but <b>transfer</b> both arguments and returns. Generally, <code>u3k</code> are most convenient for new code. </p><p>Following <code>u3k/q/w</code> is <code>[a-f]</code>, corresponding to the 6 logical tiers of the kernel, or <code>g</code> for user-level jets. Another letter is added for functions within subcores. The filename, under <code>j/</code>, follows the tier and the function name. </p><p>For instance, <code>++add</code> is <code>u3wa_add(cor)</code>, <code>u3qa_add(a, b)</code>, or <code>u3ka_add(a, b)</code>, in <code>j/a/add.c</code>. <code>++get</code> in <code>++by</code> is <code>u3wdb_get(cor)</code>, <code>u3kdb_get(a, b)</code>, etc, in <code>j/d/by_get.c</code>. </p><p>For historical reasons, all internal jet code in <code>j/[a-f]</code> <b>retains</b> noun arguments, and <b>transfers</b> noun results. Please do not do this in new <code>g</code> jets! The new standard protocol is to transfer both arguments and results. </p><h3 id="u3a--allocation-functions-">u3a: allocation functions </h3><p><code>u3a</code> allocates on the current road (u3R). Its internal structures are uninteresting and typical of a naive allocator. </p><p>The two most-used <code>u3a</code> functions are <code>u3a_gain()</code> to add a reference count, and <code>u3a_lose()</code> to release one (and free the noun, if the use count is zero). For convenience, <code>u3a_gain()</code> returns its argument. The pair are generally abbreviated with the macros <code>u3k()</code> and <code>u3z()</code> respectively. </p><p>Normally we create nouns through <code>u3i</code> functions, and don&#39;t call the <code>u3a</code> allocators directly. But if you do: </p><p>One, there are <b>two</b> sets of allocators: the word-aligned allocators and the fully-aligned (ie, malloc compatible) allocators. For instance, on a typical OS X setup, malloc produces 16-byte aligned results - needed for some SSE instructions. </p><p>These allocators are <b>not compatible</b>. For 32-bit alignment as used in nouns, call </p><pre>    /* u3a_walloc(): allocate storage measured in words.
    */
      void*
      u3a_walloc(c3_w len_w);

    /* u3a_wfree(): free storage.
    */
      void
      u3a_wfree(void* lag_v);

    /* u3a_wealloc(): word realloc.
    */
      void*
      u3a_wealloc(void* lag_v, c3_w len_w);
</pre><p>For full alignment, call: </p><pre>    /* u3a_malloc(): aligned storage measured in bytes.
    */
      void*
      u3a_malloc(size_t len_i);

    /* u3a_realloc(): aligned realloc in bytes.
    */
      void*
      u3a_realloc(void* lag_v, size_t len_i);

    /* u3a_realloc2(): gmp-shaped realloc.
    */
      void*
      u3a_realloc2(void* lag_v, size_t old_i, size_t new_i);

    /* u3a_free(): free for aligned malloc.
    */
      void
      u3a_free(void* tox_v);

    /* u3a_free2(): gmp-shaped free.
    */
      void
      u3a_free2(void* tox_v, size_t siz_i);
</pre><p>There are also a set of special-purpose allocators for building atoms. When building atoms, please remember that it&#39;s incorrect to have a high 0 word - the word length in the atom structure must be strictly correct. </p><p>Of course, we don&#39;t always know how large our atom will be. Therefore, the standard way of building large atoms is to allocate a block of raw space with <code>u3a_slab()</code>, then chop off the end with <code>u3a_malt()</code> (which does the measuring itself) or <code>u3a_mint()</code> in case you&#39;ve measured it yourself. </p><p>Once again, <b>do not call <code>malloc()</code></b> (or C++ <code>new</code>) within any code that may be run within a jet. This will cause rare sporadic corruption when we interrupt execution within a <code>malloc()</code>. We&#39;d just override the symbol, but <code>libuv</code> uses <code>malloc()</code> across threads within its own synchronization primitives - for this to work with <code>u3a_malloc()</code>, we&#39;d have to introduce our own locks on the surface-level road (which might be a viable solution). </p><h3 id="u3n--nock-execution-">u3n: nock execution </h3><p>The <code>u3n</code> routines execute Nock itself. On the inside, they have a surprising resemblance to the spec proper (the only interesting detail is how we handle tail-call elimination) and are, as one would expect, quite slow. (There is no such thing as a fast tree interpreter.) </p><p>There is only one Nock, but there are lots of ways to call it. (Remember that all <code>u3n</code> functions <b>transfer</b> C arguments and returns.) </p><p>The simplest interpreter, <code>u3n_nock_on(u3_noun bus, u3_noun fol)</code> invokes Nock on <code>bus</code> (the subject) and <code>fol</code> (the formula). (Why is it<code>[subject formula]</code>, not <code>[formula subject]</code>? The same reason <code>0</code> is true and <code>1</code> is false.) </p><p>A close relative is <code>u3n_slam_on(u3_noun gat, u3_noun sam)</code>, which slams a <b>gate</b> (<code>gat</code>) on a sample (<code>sam</code>). (In a normal programming language which didn&#39;t talk funny and was retarded, <code>u3n_slam_on()</code> would call a function on an argument.) We could write it most simply as: </p><pre>    u3_noun
    u3n_slam_on(u3_noun gat, u3_noun sam)
    {
      u3_noun pro = u3n_nock_on
                      (u3nc(u3k(u3h(gat)),
                            u3nc(sam, u3k(u3t(u3t(gat))))),
                       u3k(u3h(gat)));
      u3z(gat);
      return pro;
    }
</pre><p>Simpler is <code>u3n_kick_on(u3_noun gat)</code>, which slams a gate (or, more generally, a <b>trap</b> - because sample structure is not even needed here) without changing its sample: </p><pre>    u3_noun
    u3n_kick_on(u3_noun gat, u3_noun sam)
    {
      return u3n_nock_on(gat, u3k(u3h(gat)));
    }
</pre><p>The <code>_on</code> functions in <code>u3n</code> are all defined as pure Nock. But actually, even though we say we don&#39;t extend Nock, we do. But we don&#39;t. But we do. </p><p>Note that <code>u3</code> has a well-developed error handling system - <code>u3m_bail()</code> to throw an exception, <code>u3m_soft_*</code> to catch one. But Nock has no exception model at all. That&#39;s okay - all it means if that if an <code>_on</code> function bails, the exception is an exception in the caller. </p><p>However, <code>u3</code>&#39;s exception handling happens to match a convenient virtual super-Nock in <code>hoon.hoon</code>, the infamous <code>++mock</code>. Of course, Nock is slow, and <code>mock</code> is Nock in Nock, so it is (logically) super-slow. Then again, so is decrement. </p><p>With the power of <code>u3</code>, we nest arbitrary layers of <code>mock</code> without any particular performance cost. Moreover, we simply treat Nock proper as a special case of <code>mock</code>. (More precisely, the internal VM loop is <code>++mink</code> and the error compiler is <code>++mook</code>. But we call the whole sandbox system <code>mock</code>.) </p><p>The nice thing about <code>mock</code> functions is that (by executing within <code>u3m_soft_run()</code>, which as you may recall uses a nested road) they provide both exceptions and the namespace operator - <code>.^</code> in Hoon, which becomes operator <code>11</code> in <code>mock</code>. </p><p><code>11</code> requires a namespace function, or <code>fly</code>, which produces a <code>++unit</code> - <code>~</code> (<code>0</code>) for no binding, or <code>[0 value]</code>. The sample to a <code>fly</code> is a <code>++path</code>, just a list of text <code>span</code>. </p><p><code>mock</code> functions produce a <code>++toon</code>. Fully elaborated: </p><pre>    ++  noun  ,*                                      ::  any noun
    ++  path  (list ,@ta)                             ::  namespace path
    ++  span  ,@ta                                    ::  text-atom (ASCII)
    ++  toon  $%  [%0 p=noun]                         ::  success
                  [%1 p=(list path)]                  ::  blocking paths
                  [%2 p=(list tank)]                  ::  stack trace
              ==                                      ::
    ++  tank                                          ::  printable
              $%  [%leaf p=tape]                      ::  flat text
                  $:  %palm                           ::  backstep list
                      p=[p=tape q=tape r=tape s=tape] ::  mid cap open close
                      q=(list tank)                   ::  contents
                  ==                                  ::
                  $:  %rose                           ::  straight list
                      p=[p=tape q=tape r=tape]        ::  mid open close
                      q=(list tank)                   ::  contents
                  ==                                  ::
              ==
</pre><p>(Note that <code>tank</code> is overdesigned and due for replacement.) </p><p>What does a <code>toon</code> mean? Either your computation succeded (<code>[0 noun]</code>, or could not finish because it blocked on one or more global paths (<code>[1 (list path)]</code>), or it exited with a stack trace (<code>[2 (list tank)]</code>). </p><p>Note that of all the <code>u3</code> exceptions, only <code>%exit</code> is produced deterministically by the Nock definition. Therefore, only <code>%exit</code> produces a <code>2</code> result. Any other argument to <code>u3m_bail()</code> will unwind the virtualization stack all the way to the top - or to be more exact, to <code>u3m_soft_top()</code>. </p><p>In any case, the simplest <code>mock</code> functions are <code>u3n_nock_un()</code> and <code>u3n_slam_un()</code>. These provide exception control without any namespace change, as you can see by the code: </p><pre>    /* u3n_nock_un(): produce .*(bus fol), as ++toon.
    */
    u3_noun
    u3n_nock_un(u3_noun bus, u3_noun fol)
    {
      u3_noun fly = u3nt(u3nt(11, 0, 6), 0, 0);  //  |=(a=* .^(a))

      return u3n_nock_in(fly, bus, fol);
    }

    /* u3n_slam_un(): produce (gat sam), as ++toon.
    */
    u3_noun
    u3n_slam_un(u3_noun gat, u3_noun sam)
    {
      u3_noun fly = u3nt(u3nt(11, 0, 6), 0, 0);  //  |=(a=* .^(a))

      return u3n_slam_in(fly, gat, sam);
    }
</pre><p>The <code>fly</code> is added as the first argument to <code>u3n_nock_in()</code> and <code>u3n_slam_in()</code>. Of course, logically, <code>fly</code> executes in the caller&#39;s exception layer. (Maintaining this illusion is slightly nontrivial.) Finally, <code>u3n_nock_an()</code> is a sandbox with a null namespace. </p><h3 id="u3e--persistence-">u3e: persistence </h3><p>The only <code>u3e</code> function you should need to call is <code>u3e_save()</code>, which saves the loom. As it can be restored on any platform, please make sure you don&#39;t have any state in the loom that is bound to your process or architecture - except for exceptions like the warm jet state, which is actively purged on reboot. </p><h3 id="u3r--reading-nouns--weak--">u3r: reading nouns (weak) </h3><p>As befits accessors they don&#39;t make anything, <code>u3r</code> noun reading functions always retain their arguments and their returns. They never bail; rather, when they don&#39;t work, they return a <code>u3_weak</code> result. </p><p>Most of these functions are straightforward and do only what their comments say. A few are interesting enough to discuss. </p><p><code>u3r_at()</code> is the familiar tree fragment function, <code>/</code> from the Nock spec. For taking complex nouns apart, <code>u3r_mean()</code> is a relatively funky way of deconstructing nouns with a varargs list of <code>axis</code>, <code>u3_noun *</code>. For cells, triples, etc, decompose with <code>u3r_cell()</code>, <code>u3r_trel()</code>, etc. For the tagged equivalents, use <code>u3r_pq()</code> and friends. </p><p><code>u3r_sing(u3_noun a, u3_noun b)</code> (true if <code>a</code> and <code>b</code> are a <b>single</b> noun) are interesting because it uses mugs to help it out. Clearly, different nouns may have the same mug, but the same nouns cannot have a different mug. It&#39;s important to understand the performance characteristics of <code>u3r_sing()</code>: the worst possible case is a comparison of duplicate nouns, which have the same value but were created separately. In this case, the tree is traversed </p><p><code>u3r_sung()</code> is a deeply funky and frightening version of <code>u3r_sing()</code> that unifies pointers to the duplicate nouns it finds, freeing the second copy. Obviously, do not use <code>u3r_sung()</code> when you have live, but not reference counted, noun references from C - if they match a noun with a refcount of 1 that gets freed, bad things happen. </p><p>It&#39;s important to remember that <code>u3r_mug()</code>, which produces a 31-bit, nonzero insecure hash, uses the <code>mug_w</code> slot in any boxed noun as a lazy cache. There are a number of variants of <code>u3r_mug()</code> that can get you out of building unneeded nouns. </p><h3 id="u3x--reading-nouns--bail--">u3x: reading nouns (bail) </h3><p><code>u3x</code> functions are like <code>u3r</code> functions, but instead of returning <code>u3_none</code> when (for instance) we try to take the head of an atom, they bail with <code>%exit</code>. In other words, they do what the same operation would do in Nock. </p><h3 id="u3h--hash-tables--">u3h: hash tables. </h3><p>We can of course use the Hoon <code>map</code> structure as an associative array. This is a balanced treap and reasonably fast. However, it&#39;s considerably inferior to a custom structure like an HAMT (hash array-mapped trie). We use <code>u3_post</code> to allocate HAMT structures on the loom. </p><p>(Our HAMT implements the classic Bagwell algorithm which depends on the <code>gcc</code> standard directive <code>__builtin_popcount()</code>. On a CPU which doesn&#39;t support popcount or an equivalent instruction, some other design would probably be preferable.) </p><p>There&#39;s no particular rocket science in the API. <code>u3h_new()</code> creates a hashtable; <code>u3h_free()</code> destroys one; <code>u3h_put()</code> inserts, <code>u3h_get()</code> retrieves. You can transform values in a hashtable with <code>u3h_walk()</code>. </p><p>The only funky function is <code>u3h_gut()</code>, which unifies keys with <code>u3r_sung()</code>. As with all cases of <code>u3r_sung()</code>, this must be used with extreme caution. </p><h3 id="u3z--memoization-">u3z: memoization </h3><p>Connected to the <code>~+</code> rune in Hoon, via the Nock <code>%memo</code> hint, the memoization facility is a general-purpose cache. </p><p>(It&#39;s also used for partial memoization - a feature that&#39;ll probably be removed, in which conservative worklist algorithms (which would otherwise be exponential) memoize everything in the subject <b>except</b> the worklist. This is used heavily in the Hoon compiler jets (j/f/*.c). Unfortunately, it&#39;s probably not possible to make this work perfectly in that it can&#39;t be abused to violate Nock, so we&#39;ll probably remove it at a later date, instead making <code>++ut</code> keep its own monadic cache.) </p><p>Each <code>u3z</code> function comes with a <code>c3_m</code> mote which disambiguates the function mapping key to value. For Nock itself, use 0. For extra speed, small tuples are split out in C; thus, find with </p><pre>    u3_weak u3z_find(c3_m, u3_noun);
    u3_weak u3z_find_2(c3_m, u3_noun, u3_noun);
    u3_weak u3z_find_3(c3_m, u3_noun, u3_noun, u3_noun);
    u3_weak u3z_find_4(c3_m, u3_noun, u3_noun, u3_noun, u3_noun);
</pre><p>and save with </p><pre>    u3_noun u3z_save(c3_m, u3_noun, u3_noun);
    u3_noun u3z_save_2(c3_m, u3_noun, u3_noun, u3_noun);
    u3_noun u3z_save_3(c3_m, u3_noun, u3_noun, u3_noun, u3_noun);
    u3_noun u3z_save_4(c3_m, u3_noun, u3_noun, u3_noun, u3_noun, u3_noun);
</pre><p>where the value is the last argument. To eliminate duplicate nouns, there is also </p><pre>    u3_noun
    u3z_uniq(u3_noun);
</pre><p><code>u3z</code> functions retain keys and transfer values. </p><p>The <code>u3z</code> cache, built on <code>u3h</code> hashes, is part of the current road, and goes away when it goes away. (In future, we may wish to promote keys/values which outlive the road, as we do with jet state.) There is no cache reclamation at present, so be careful. </p><h3 id="u3t--tracing-and-profiling--">u3t: tracing and profiling. </h3><p>TBD. </p><h3 id="u3v--the-arvo-kernel-">u3v: the Arvo kernel </h3><p>An Arvo kernel - or at least, a core that compiles with the Arvo interface - is part of the global <code>u3</code> state. What is an Arvo core? Slightly pseudocoded: </p><pre>    ++  arvo
      |%
      ++  come  |/  {yen/@ ova/(list ovum) nyf/pone}  ::  11
                ^-  {(list ovum) _+&gt;}
                !!
      ++  keep  |/  {now/@da hap/path}                ::  4
                ^-  (unit ,@da)
                !!
      ++  load  |/  {yen/@ ova/(list ovum) nyf/pane}  ::  86
                ^-  {(list ovum) _+&gt;}
                !!
      ++  peek  |/  {now/@da path}                    ::  87
                ^-  (unit)
                !!
      ++  poke  |/  {now/@da ovo/ovum}                ::  42
                ^-  {(list ovum) _+&gt;}
                !!
      ++  wish  |/  txt/@ta                           ::  20
                ^-  *
                !!
      --
    ++  card  {p/@tas q/*}                           ::  typeless card
    ++  ovum  {p/wire q/card}                        ::  Arvo event
    ++  wire  path                                    ::  event cause
</pre><p>This is the Arvo ABI in a very real sense. Arvo is a core with these six arms. To use these arms, we hardcode the axis of the formula (<code>11</code>, <code>4</code>, <code>86</code>, etc) into the C code that calls Arvo, because otherwise we&#39;d need type metadata - which we can get, by calling Arvo. </p><p>It&#39;s important to understand the Arvo event/action structure, or <code>++ovum</code>. An <code>ovum</code> is a <code>card</code>, which is any <code>[term noun]</code> cell, and a <code>++wire</code>, a <code>path</code> which indicates the location of the event. At the Unix level, the <code>wire</code> corresponds to a system module or context. For input events, this is the module that caused the event; for output actions, it&#39;s the module that performs the action. </p><p><code>++poke</code> sends Arvo an event <code>ovum</code>, producing a cell of action ova and a new Arvo core. </p><p><code>++peek</code> dereferences the Arvo namespace. It takes a date and a key, and produces <code>~</code> (<code>0</code>) or <code>[~ value]</code>. </p><p><code>++keep</code> asks Arvo the next time it wants to be woken up, for the given <code>wire</code>. (This input will probably be eliminated in favor of a single global timer.) </p><p><code>++wish</code> compiles a string of Hoon source. While just a convenience, it&#39;s a very convenient convenience. </p><p><code>++come</code> and <code>++load</code> are used by Arvo to reset itself (more precisely, to shift the Arvo state from an old kernel to a new one); there is no need to call them from C. </p><p>Now that we understand the Arvo kernel interface, let&#39;s look at the <code>u3v</code> API. As usual, all the functions in <code>u3v</code> are commented, but unfortunately it&#39;s hard to describe this API as clean at present. The problem is that <code>u3v</code> remains design coupled to the old <code>vere</code> event handling code written for <code>u2</code>. But let&#39;s describe the functions you should be calling, assuming you&#39;re not writing the next event system. There are only two. </p><p><code>u3v_wish(str_c)</code> wraps the <code>++wish</code> functionality in a cache (which is read-only unless you&#39;re on the surface road). </p><p><code>u3v_do()</code> uses <code>wish</code> to provide a convenient interface for calling Hoon kernel functions by name. Even more conveniently, we tend to call <code>u3v_do()</code> with these convenient aliases: </p><pre>    #define  u3do(txt_c, arg)         u3v_do(txt_c, arg)
    #define  u3dc(txt_c, a, b)        u3v_do(txt_c, u3nc(a, b))
    #define  u3dt(txt_c, a, b, c)     u3v_do(txt_c, u3nt(a, b, c))
    #define  u3dq(txt_c, a, b, c, d)  u3v_do(txt_c, u3nt(a, b, c, d))
</pre></div></div></div></div></div><footer class="mb-36"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="/js/main.js"></script></footer></body></html></body></html>